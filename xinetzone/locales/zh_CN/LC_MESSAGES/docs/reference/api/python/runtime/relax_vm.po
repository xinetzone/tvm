# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, xinetzone
# This file is distributed under the same license as the tvm package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tvm \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-05 11:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../doc/docs/reference/api/python/runtime/relax_vm.rst:19
msgid "tvm.runtime.relax_vm"
msgstr ""

#~ msgid "The Relax virtual machine."
#~ msgstr ""

#~ msgid "Relax VM runtime."
#~ msgstr ""

#~ msgid ""
#~ "Get the value output by the "
#~ "function by the given name after a"
#~ " call of `invoke_stateful`."
#~ msgstr ""

#~ msgid ""
#~ "It is an error to call this "
#~ "function without first calling "
#~ "`invoke_stateful`."
#~ msgstr ""

#~ msgid "参数"
#~ msgstr ""

#~ msgid "The name of the function whose output should be fetched."
#~ msgstr ""

#~ msgid "返回"
#~ msgstr ""

#~ msgid ""
#~ "**ret** -- The result of the "
#~ "earlier call to the function via "
#~ "`invoke_stateful`. If the result is a"
#~ " tuple, it returns a list of "
#~ "the fields. The fields are potentially"
#~ " also tuples, so these can be "
#~ "arbitrily nested."
#~ msgstr ""

#~ msgid "返回类型"
#~ msgstr ""

#~ msgid "Invoke a closure."
#~ msgstr ""

#~ msgid "The VMClosure Object."
#~ msgstr ""

#~ msgid "The arguments to the closure."
#~ msgstr ""

#~ msgid "**result** -- The output."
#~ msgstr ""

#~ msgid ""
#~ "Call the named function from the "
#~ "VM module using the arguments set "
#~ "using `set_input`. It is an error "
#~ "to call `invoke_stateful` without using "
#~ "`set_input` first (even if it's to "
#~ "set 0 inputs); conversely, if "
#~ "`set_input` has been called, it is "
#~ "an error to call the function "
#~ "without using `invoke_stateful`."
#~ msgstr ""

#~ msgid "The results of the call can be obtained by calling `get_outputs`."
#~ msgstr ""

#~ msgid "The name of the function to call."
#~ msgstr ""

#~ msgid "Profile a function call."
#~ msgstr ""

#~ msgid "The name of the function."
#~ msgstr ""

#~ msgid "The arguments to the function."
#~ msgstr ""

#~ msgid ""
#~ "**report** -- The formatted profiling "
#~ "result, showing per-op timing "
#~ "measurements."
#~ msgstr ""

#~ msgid ""
#~ "Convenience function. Takes a function "
#~ "from the module and saves a "
#~ "`PackedFunc` that, when called, will "
#~ "invoke the function with the given "
#~ "arguments. The `PackedFunc` can be "
#~ "accessed from the module using "
#~ "`saved_name`. This is included to "
#~ "facilitate timing trials: Invoking the "
#~ "returned `PackedFunc` will have less "
#~ "overhead from dictionary lookups than "
#~ "normally running through the VM."
#~ msgstr ""

#~ msgid ""
#~ "If the saved name is taken, it "
#~ "can be overridden, though it cannot "
#~ "override the name of a function "
#~ "defined in the Relax source."
#~ msgstr ""

#~ msgid ""
#~ "This is really creating a closure, "
#~ "but the function has a different "
#~ "name to avoid confusion with "
#~ "`invoke_closure` (they are not meant to"
#~ " be used together)."
#~ msgstr ""

#~ msgid "The function that should be packaged up."
#~ msgstr ""

#~ msgid "The name that the resulting closure should be saved under."
#~ msgstr ""

#~ msgid ""
#~ "Whether the saved PackedFunc should "
#~ "return its output. If timing over "
#~ "RPC, it may not be desirable to"
#~ " send output between machines."
#~ msgstr ""

#~ msgid "The arguments to package up with the function."
#~ msgstr ""

#~ msgid "Any named arguments to package up with the function"
#~ msgstr ""

#~ msgid ""
#~ "Set the inputs to a function. This"
#~ " interface works when using VM over"
#~ " RPC by internally converting NDArray "
#~ "in the arguments to DLTensor, which "
#~ "is supported in RPC where remote "
#~ "could only have a minimal C "
#~ "runtime."
#~ msgstr ""

#~ msgid ""
#~ "Note: If `set_input` is used, the "
#~ "function *must* be called using "
#~ "`invoke_stateful` and the results must "
#~ "be obtained using `get_outputs`."
#~ msgstr ""

#~ msgid "Named arguments to the function."
#~ msgstr ""

#~ msgid "Set an instrumentation function."
#~ msgstr ""

#~ msgid ""
#~ "If instrument is present, the function"
#~ " will be called before/after each "
#~ "Call instruction. The function have the"
#~ " following signature:"
#~ msgstr ""

#~ msgid ""
#~ "The instrument takes the following "
#~ "parameters: - func: function object to"
#~ " be called. - func_symbol: the symbol"
#~ " name of the function. - before_run:"
#~ " whether it is before or after "
#~ "call. - ret_value: the return value "
#~ "of the call, only valid after run."
#~ " - args: the arguments being passed"
#~ " to call."
#~ msgstr ""

#~ msgid ""
#~ "The instrument function can choose an"
#~ " integer, which corresponds to action "
#~ "direction for the following run. See "
#~ "VMInstrumentReturnKind for more details."
#~ msgstr ""

#~ msgid "A instrumentation function that get invoked every VM call instr."
#~ msgstr ""

#~ msgid ":obj:`VMInstrumentReturnKind`"
#~ msgstr ""

#~ msgid "the possible return values in VM."
#~ msgstr ""

#~ msgid ""
#~ "Returns an evaluator that times a "
#~ "function in the module. This follows "
#~ "the same convention as time_evaluator in"
#~ " tvm.runtime.module. This can be used "
#~ "in combination with save_function() so "
#~ "that the timings avoid extra dictionary"
#~ " lookups."
#~ msgstr ""

#~ msgid "The name of the function in the module."
#~ msgstr ""

#~ msgid "The device we should run this function on."
#~ msgstr ""

#~ msgid ""
#~ "The number of times to run this"
#~ " function for taking average. We call"
#~ " these runs as one `repeat` of "
#~ "measurement."
#~ msgstr ""

#~ msgid ""
#~ "The number of times to repeat the"
#~ " measurement. In total, the function "
#~ "will be invoked (1 + number x "
#~ "repeat) times, where the first one "
#~ "is warm up and will be discarded."
#~ " The returned result contains `repeat` "
#~ "costs, each of which is an average"
#~ " of `number` costs."
#~ msgstr ""

#~ msgid ""
#~ "The minimum duration of one `repeat` "
#~ "in milliseconds. By default, one "
#~ "`repeat` contains `number` runs. If this"
#~ " parameter is set, the parameters "
#~ "`number` will be dynamically adjusted to"
#~ " meet the minimum duration requirement "
#~ "of one `repeat`. i.e., When the "
#~ "run time of one `repeat` falls "
#~ "below this time, the `number` parameter"
#~ " will be automatically increased."
#~ msgstr ""

#~ msgid ""
#~ "The cooldown interval in milliseconds "
#~ "between the number of repeats defined"
#~ " by `repeats_to_cooldown`."
#~ msgstr ""

#~ msgid "The number of repeats before the cooldown is activated."
#~ msgstr ""

#~ msgid ""
#~ "The preprocess function name we want "
#~ "to execute before executing the time "
#~ "evaluator."
#~ msgstr ""

#~ msgid ""
#~ "The function will be invoked  (1 +"
#~ " number x repeat) times, with the "
#~ "first call discarded in case there "
#~ "is lazy initialization."
#~ msgstr ""

#~ msgid "示例"
#~ msgstr ""

#~ msgid ""
#~ "Normal use with a VM function (may"
#~ " not work over RPC if the "
#~ "function returns a tuple):"
#~ msgstr ""

#~ msgid "Use with the stateful API:"
#~ msgstr ""

#~ msgid ""
#~ "With saved closures via `save_function` "
#~ "(this results in fewer dictionary "
#~ "lookups in the timed portion):"
#~ msgstr ""

#~ msgid ""
#~ "**ftimer** -- The function that takes"
#~ " same argument as func and returns"
#~ " a BenchmarkResult. The ProfileResult "
#~ "reports `repeat` time costs in seconds."
#~ msgstr ""

