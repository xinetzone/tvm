# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, xinetzone
# This file is distributed under the same license as the TVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: TVM \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-01-20 16:06+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../doc/docs/reference/api/python/runtime.rst:19
msgid "tvm.runtime"
msgstr ""

#: of tvm.runtime:1
msgid "TVM runtime namespace."
msgstr ""

#: of tvm.runtime:1
msgid "**Classes:**"
msgstr ""

#: of tvm.runtime:1:<autosummary>:1
msgid ":py:obj:`DataType <tvm.runtime.DataType>`\\ \\(type\\_str\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1 tvm.runtime:1:<autosummary>:1
msgid "TVM datatype structure"
msgstr ""

#: of tvm.runtime:1:<autosummary>:1
msgid ":py:obj:`DataTypeCode <tvm.runtime.DataTypeCode>`\\ \\(\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataTypeCode:1 tvm.runtime:1:<autosummary>:1
msgid "DataType code in DLTensor."
msgstr ""

#: of tvm.runtime:1:<autosummary>:1
msgid ":py:obj:`Device <tvm.runtime.Device>`\\ \\(device\\_type\\, device\\_id\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device:1 tvm.runtime:1:<autosummary>:1
msgid "TVM device strucure."
msgstr ""

#: of tvm.runtime:1:<autosummary>:1
msgid ":py:obj:`Module <tvm.runtime.Module>`\\ \\(handle\\)"
msgstr ""

#: of tvm.runtime.module.Module:1 tvm.runtime:1:<autosummary>:1
msgid "Runtime Module."
msgstr ""

#: of tvm.runtime:1:<autosummary>:1
msgid ":py:obj:`Object <tvm.runtime.Object>`\\ \\(\\)"
msgstr ""

#: of tvm.runtime.object.Object:1 tvm.runtime:1:<autosummary>:1
msgid "Base class for all tvm's runtime objects."
msgstr ""

#: of tvm.runtime:1:<autosummary>:1
msgid ":py:obj:`ObjectGeneric <tvm.runtime.ObjectGeneric>`\\ \\(\\)"
msgstr ""

#: of tvm.runtime.object_generic.ObjectGeneric:1 tvm.runtime:1:<autosummary>:1
msgid "Base class for all classes that can be converted to object."
msgstr ""

#: of tvm.runtime:1:<autosummary>:1
msgid ":py:obj:`ObjectPath <tvm.runtime.ObjectPath>`\\ \\(\\)"
msgstr ""

#: of tvm.runtime.object_path.ObjectPath:1 tvm.runtime:1:<autosummary>:1
msgid "Path to an object from some root object."
msgstr ""

#: of tvm.runtime:1:<autosummary>:1
msgid ":py:obj:`ObjectPathPair <tvm.runtime.ObjectPathPair>`\\ \\(\\)"
msgstr ""

#: of tvm.runtime.object_path.ObjectPathPair:1 tvm.runtime:1:<autosummary>:1
msgid ""
"Pair of ObjectPaths, one for each object being tested for structural "
"equality."
msgstr ""

#: of tvm.runtime:1:<autosummary>:1
msgid ""
":py:obj:`PackedFunc <tvm.runtime.PackedFunc>`\\ \\(handle\\, "
"is\\_global\\)"
msgstr ""

#: of tvm.runtime.packed_func.PackedFunc:1 tvm.runtime:1:<autosummary>:1
msgid "The PackedFunc object used in TVM."
msgstr ""

#: of tvm.runtime:1:<autosummary>:1
msgid ""
":py:obj:`Report <tvm.runtime.Report>`\\ \\(calls\\, device\\_metrics\\, "
"configuration\\)"
msgstr ""

#: of tvm.runtime.profiling.Report:1 tvm.runtime:1:<autosummary>:1
msgid "A container for information gathered during a profiling run."
msgstr ""

#: of tvm.runtime:1:<autosummary>:1
msgid ":py:obj:`Scriptable <tvm.runtime.Scriptable>`\\ \\(\\)"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable:1 tvm.runtime:1:<autosummary>:1
msgid "A base class that enables the script() and show() method."
msgstr ""

#: of tvm.runtime:1:<autosummary>:1
msgid ":py:obj:`ShapeTuple <tvm.runtime.ShapeTuple>`\\ \\(shape\\)"
msgstr ""

#: of tvm.runtime:1:<autosummary>:1
msgid ""
"TVM runtime ShapeTuple object. Parameters ---------- shape : list[int]"
"     The shape list used to construct the object."
msgstr ""

#: of tvm.runtime:1:<autosummary>:1
msgid ":py:obj:`String <tvm.runtime.String>`\\ \\(content\\)"
msgstr ""

#: of tvm.runtime.container.String:1 tvm.runtime:1:<autosummary>:1
msgid "TVM runtime.String object, represented as a python str."
msgstr ""

#: of tvm.runtime:1
msgid "**Functions:**"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`cl <tvm.runtime.cl>`\\ \\(\\[dev\\_id\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.ndarray.opencl:1
msgid "Construct a OpenCL device"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`const <tvm.runtime.const>`\\ \\(value\\[\\, dtype\\, span\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.object_generic.const:1
msgid "construct a constant"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`convert <tvm.runtime.convert>`\\ \\(value\\[\\, span\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.object_generic.convert:1
msgid "Convert value to TVM object or function."
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ""
":py:obj:`convert_to_object <tvm.runtime.convert_to_object>`\\ "
"\\(value\\[\\, span\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.object_generic.convert_to_object:1
msgid "Convert a Python value to corresponding object type."
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`cpu <tvm.runtime.cpu>`\\ \\(\\[dev\\_id\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.ndarray.cpu:1
msgid "Construct a CPU device"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`cuda <tvm.runtime.cuda>`\\ \\(\\[dev\\_id\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.ndarray.cuda:1 tvm.runtime.ndarray.gpu:1
msgid "Construct a CUDA GPU device"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`device <tvm.runtime.device>`\\ \\(dev\\_type\\[\\, dev\\_id\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.ndarray.device:1
msgid "Construct a TVM device with given device type and id."
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`enabled <tvm.runtime.enabled>`\\ \\(target\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.module.enabled:1
msgid "Whether module runtime is enabled for target"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`ext_dev <tvm.runtime.ext_dev>`\\ \\(\\[dev\\_id\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.ndarray.ext_dev:1
msgid "Construct a extension device"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`gpu <tvm.runtime.gpu>`\\ \\(\\[dev\\_id\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`load_module <tvm.runtime.load_module>`\\ \\(path\\[\\, fmt\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.module.load_module:1
msgid "Load module from file."
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ""
":py:obj:`load_param_dict <tvm.runtime.load_param_dict>`\\ "
"\\(param\\_bytes\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.params.load_param_dict:1
msgid "Load parameter dictionary from binary bytes."
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ""
":py:obj:`load_param_dict_from_file "
"<tvm.runtime.load_param_dict_from_file>`\\ \\(path\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.params.load_param_dict_from_file:1
msgid "Load parameter dictionary from file."
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ""
":py:obj:`load_static_library <tvm.runtime.load_static_library>`\\ "
"\\(path\\, func\\_names\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid "Load the .o library at path which implements functions with func_names."
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`metal <tvm.runtime.metal>`\\ \\(\\[dev\\_id\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.ndarray.metal:1
msgid "Construct a metal device"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`mtl <tvm.runtime.mtl>`\\ \\(\\[dev\\_id\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`num_threads <tvm.runtime.num_threads>`\\ \\(\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.module.num_threads:1
msgid "Get the number of threads in use by the TVM runtime."
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`opencl <tvm.runtime.opencl>`\\ \\(\\[dev\\_id\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`rocm <tvm.runtime.rocm>`\\ \\(\\[dev\\_id\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.ndarray.rocm:1
msgid "Construct a ROCM device"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`save_param_dict <tvm.runtime.save_param_dict>`\\ \\(params\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.params.save_param_dict:1
msgid "Save parameter dictionary to binary bytes."
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ""
":py:obj:`save_param_dict_to_file <tvm.runtime.save_param_dict_to_file>`\\"
" \\(params\\, path\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.params.save_param_dict_to_file:1
msgid "Save parameter dictionary to file."
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ""
":py:obj:`system_lib <tvm.runtime.system_lib>`\\ "
"\\(\\[symbol\\_prefix\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.module.system_lib:1
msgid "Get system-wide library module singleton."
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`vpi <tvm.runtime.vpi>`\\ \\(\\[dev\\_id\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.ndarray.vpi:1
msgid "Construct a VPI simulated device"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
msgid ":py:obj:`vulkan <tvm.runtime.vulkan>`\\ \\(\\[dev\\_id\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.DataType:1:<autosummary>:1
#: tvm.runtime.ndarray.vulkan:1
msgid "Construct a Vulkan device"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device:3
msgid ""
"Typically constructed using convenience function "
":meth:`tvm.runtime.device`."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device:6
msgid ""
"Exposes uniform interface to device-specific APIs such as CUDA or OpenCL."
"  Some properties may return None depending on whether an API exposes "
"that particular property."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device:10
msgid ""
"NOTE!  The integer values in MASK2STR and STR2MASK *must* correspond to "
"the values provided by the DLDeviceType and TVMDeviceExtType enums."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device:1 tvm.runtime.container.String:1
#: tvm.runtime.module.Module:1 tvm.runtime.object.Object:1
#: tvm.runtime.object_generic.ObjectGeneric:1 tvm.runtime.profiling.Report:1
#: tvm.runtime.script_printer.Scriptable:1
msgid "**Methods:**"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device:1:<autosummary>:1
msgid ""
":py:obj:`_GetDeviceAttr <tvm.runtime.Device._GetDeviceAttr>`\\ "
"\\(device\\_type\\, device\\_id\\, attr\\_id\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1
#: tvm._ffi.runtime_ctypes.Device:1:<autosummary>:1
msgid "Internal helper function to invoke runtime.GetDeviceAttr"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device:1:<autosummary>:1
msgid ""
":py:obj:`create_raw_stream <tvm.runtime.Device.create_raw_stream>`\\ "
"\\(\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device.create_raw_stream:1
#: tvm._ffi.runtime_ctypes.Device:1:<autosummary>:1
msgid "Create a new runtime stream at the context."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device:1:<autosummary>:1
msgid ""
":py:obj:`free_raw_stream <tvm.runtime.Device.free_raw_stream>`\\ "
"\\(stream\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device.free_raw_stream:1
#: tvm._ffi.runtime_ctypes.Device:1:<autosummary>:1
msgid "Free a created stream handle."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device:1:<autosummary>:1
msgid ""
":py:obj:`set_raw_stream <tvm.runtime.Device.set_raw_stream>`\\ "
"\\(stream\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device.set_raw_stream:1
#: tvm._ffi.runtime_ctypes.Device:1:<autosummary>:1
msgid "Set a created stream handle."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device:1:<autosummary>:1
msgid ":py:obj:`sync <tvm.runtime.Device.sync>`\\ \\(\\[stream\\]\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device.sync:1
#: tvm._ffi.runtime_ctypes.Device:1:<autosummary>:1
msgid "Synchronize until jobs finished at the context."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device:1:<autosummary>:1
msgid ""
":py:obj:`texture_spatial_limit "
"<tvm.runtime.Device.texture_spatial_limit>`\\ \\(\\)"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device.texture_spatial_limit:1
#: tvm._ffi.runtime_ctypes.Device:1:<autosummary>:1
msgid "Returns limits for textures by spatial dimensions"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device:1 tvm.runtime.module.Module:1
msgid "**Attributes:**"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
msgid ":py:obj:`api_version <tvm.runtime.Device.api_version>`\\"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
#: tvm.runtime.Device.api_version:1
msgid "Returns version number of the SDK used to compile TVM."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
msgid ":py:obj:`compute_version <tvm.runtime.Device.compute_version>`\\"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
#: tvm.runtime.Device.compute_version:1
msgid "Get compute version number as string."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
msgid ":py:obj:`device_name <tvm.runtime.Device.device_name>`\\"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
#: tvm.runtime.Device.device_name:1
msgid "Return the vendor-specific name of device."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
msgid ":py:obj:`driver_version <tvm.runtime.Device.driver_version>`\\"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
#: tvm.runtime.Device.driver_version:1
msgid "Returns version number of the driver"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
msgid ":py:obj:`exist <tvm.runtime.Device.exist>`\\"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
#: tvm.runtime.Device.exist:1
msgid "Whether this device exists."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
msgid ":py:obj:`l2_cache_size_bytes <tvm.runtime.Device.l2_cache_size_bytes>`\\"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
#: tvm.runtime.Device.l2_cache_size_bytes:1
msgid "Return the size of the device L2 cache in bytes"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
msgid ":py:obj:`max_clock_rate <tvm.runtime.Device.max_clock_rate>`\\"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
#: tvm.runtime.Device.max_clock_rate:1
msgid "Return the max clock frequency of device (kHz)."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
msgid ""
":py:obj:`max_shared_memory_per_block "
"<tvm.runtime.Device.max_shared_memory_per_block>`\\"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
#: tvm.runtime.Device.max_shared_memory_per_block:1
msgid "Total amount of shared memory per block in bytes."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
msgid ""
":py:obj:`max_thread_dimensions "
"<tvm.runtime.Device.max_thread_dimensions>`\\"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
#: tvm.runtime.Device.max_thread_dimensions:1
msgid "Return the maximum size of each thread axis"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
msgid ""
":py:obj:`max_threads_per_block "
"<tvm.runtime.Device.max_threads_per_block>`\\"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
#: tvm.runtime.Device.max_threads_per_block:1
msgid "Maximum number of threads on each block."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
msgid ""
":py:obj:`multi_processor_count "
"<tvm.runtime.Device.multi_processor_count>`\\"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
#: tvm.runtime.Device.multi_processor_count:1
msgid "Return the number of compute units in the device."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
msgid ":py:obj:`total_global_memory <tvm.runtime.Device.total_global_memory>`\\"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
#: tvm.runtime.Device.total_global_memory:1
msgid "Return size of the total global memory."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
msgid ":py:obj:`warp_size <tvm.runtime.Device.warp_size>`\\"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device._GetDeviceAttr:1:<autosummary>:1
#: tvm.runtime.Device.warp_size:1
msgid "Number of threads that execute concurrently."
msgstr ""

#: of tvm.runtime.Device.api_version:3
msgid "For example, CUDA_VERSION for cuda or VK_HEADER_VERSION for Vulkan."
msgstr ""

#: of tvm.runtime.Device.api_version:6 tvm.runtime.Device.compute_version:6
#: tvm.runtime.Device.device_name:3
#: tvm.runtime.Device.max_shared_memory_per_block:3
#: tvm.runtime.Device.max_thread_dimensions:3
msgid ""
"Returns device value for cuda, rocm, opencl, and vulkan. Returns remote "
"device value for RPC devices.  Returns None for all other devices."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device.create_raw_stream:6
#: tvm._ffi.runtime_ctypes.Device.texture_spatial_limit:4
#: tvm.runtime.Device.api_version:11 tvm.runtime.Device.compute_version:11
#: tvm.runtime.Device.device_name:8 tvm.runtime.Device.driver_version:11
#: tvm.runtime.Device.exist:8 tvm.runtime.Device.l2_cache_size_bytes:6
#: tvm.runtime.Device.max_clock_rate:8
#: tvm.runtime.Device.max_shared_memory_per_block:8
#: tvm.runtime.Device.max_thread_dimensions:8
#: tvm.runtime.Device.max_threads_per_block:8
#: tvm.runtime.Device.multi_processor_count:8
#: tvm.runtime.Device.total_global_memory:6 tvm.runtime.Device.warp_size:9
#: tvm.runtime.Module.entry_func:4 tvm.runtime.Module.imported_modules:4
#: tvm.runtime.Module.is_binary_serializable:7
#: tvm.runtime.Module.is_dso_exportable:5 tvm.runtime.Module.is_runnable:5
#: tvm.runtime.module.Module._collect_from_import_tree:10
#: tvm.runtime.module.Module.export_library:45
#: tvm.runtime.module.Module.get_function:12
#: tvm.runtime.module.Module.get_property_mask:4
#: tvm.runtime.module.Module.get_source:9
#: tvm.runtime.module.Module.implements_function:16
#: tvm.runtime.module.Module.time_evaluator:53 tvm.runtime.module.enabled:9
#: tvm.runtime.module.load_module:13 tvm.runtime.module.num_threads:4
#: tvm.runtime.module.system_lib:20 tvm.runtime.ndarray.cpu:9
#: tvm.runtime.ndarray.cuda:9 tvm.runtime.ndarray.device:12
#: tvm.runtime.ndarray.ext_dev:9 tvm.runtime.ndarray.gpu:12
#: tvm.runtime.ndarray.metal:9 tvm.runtime.ndarray.opencl:9
#: tvm.runtime.ndarray.rocm:9 tvm.runtime.ndarray.vpi:9
#: tvm.runtime.ndarray.vulkan:9 tvm.runtime.object.Object._move:25
#: tvm.runtime.object_generic.const:15 tvm.runtime.object_generic.convert:11
#: tvm.runtime.object_generic.convert_to_object:12
#: tvm.runtime.params.load_param_dict:9
#: tvm.runtime.params.load_param_dict_from_file:9
#: tvm.runtime.params.save_param_dict:12 tvm.runtime.profiling.Report.csv:6
#: tvm.runtime.profiling.Report.from_json:9
#: tvm.runtime.profiling.Report.json:51 tvm.runtime.profiling.Report.table:21
#: tvm.runtime.script_printer.Scriptable.script:46
msgid "Returns"
msgstr ""

#: of tvm.runtime.Device.api_version:12 tvm.runtime.Device.compute_version:12
#: tvm.runtime.Device.driver_version:12
msgid "version"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device.texture_spatial_limit:-1
#: tvm.runtime.Device.api_version:-1 tvm.runtime.Device.l2_cache_size_bytes:-1
#: tvm.runtime.Device.max_clock_rate:-1
#: tvm.runtime.Device.max_shared_memory_per_block:-1
#: tvm.runtime.Device.max_threads_per_block:-1
#: tvm.runtime.Device.multi_processor_count:-1
#: tvm.runtime.Device.total_global_memory:-1 tvm.runtime.Device.warp_size:-1
msgid "int or None"
msgstr ""

#: of tvm.runtime.Device.api_version:13
msgid "The version of the SDK"
msgstr ""

#: of tvm.runtime.Device.compute_version:3
msgid ""
"Returns maximum API version (e.g. CUDA/OpenCL/Vulkan) supported by the "
"device."
msgstr ""

#: of tvm.runtime.Device.compute_version:-1 tvm.runtime.Device.device_name:-1
#: tvm.runtime.Device.driver_version:-1
msgid "str or None"
msgstr ""

#: of tvm.runtime.Device.compute_version:13
msgid "The version string in `major.minor` format."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device.create_raw_stream:3
msgid "User should free the stream after use."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device.create_raw_stream:7
#: tvm._ffi.runtime_ctypes.Device.free_raw_stream:5
#: tvm._ffi.runtime_ctypes.Device.set_raw_stream:5
#: tvm._ffi.runtime_ctypes.Device.sync:5
msgid "stream"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device.create_raw_stream:-1
#: tvm._ffi.runtime_ctypes.Device.free_raw_stream:-1
#: tvm._ffi.runtime_ctypes.Device.set_raw_stream:-1
#: tvm._ffi.runtime_ctypes.Device.sync:-1
msgid "TVMStreamHandle"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device.create_raw_stream:8
msgid "The created runtime stream."
msgstr ""

#: of tvm.runtime.Device.device_name:9
msgid "device_name"
msgstr ""

#: of tvm.runtime.Device.device_name:10
msgid "The name of the device."
msgstr ""

#: of tvm.runtime.Device.driver_version:3
msgid ""
"Returns driver vendor's internal version number. (e.g. \"450.408.256\" "
"for nvidia-driver-450)"
msgstr ""

#: of tvm.runtime.Device.driver_version:6
msgid ""
"Returns device value for opencl and vulkan.  Returns remote device value "
"for RPC devices.  Returns None for all other devices."
msgstr ""

#: of tvm.runtime.Device.driver_version:13
msgid "The version string in `major.minor.patch` format."
msgstr ""

#: of tvm.runtime.Device.exist:3
msgid ""
"Returns True if TVM has support for the device, if the physical device is"
" present, and the device is accessible through appropriate drivers (e.g. "
"cuda/vulkan)."
msgstr ""

#: of tvm.runtime.Device.exist:9
msgid "exist"
msgstr ""

#: of tvm.runtime.Device.exist:-1 tvm.runtime.module.Module.get_function:-1
#: tvm.runtime.module.Module.implements_function:-1
#: tvm.runtime.module.enabled:-1
msgid "bool"
msgstr ""

#: of tvm.runtime.Device.exist:10
msgid "True if the device exists"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device.free_raw_stream:4
#: tvm._ffi.runtime_ctypes.Device.set_raw_stream:4
#: tvm._ffi.runtime_ctypes.Device.sync:4 tvm.runtime.container.String:4
#: tvm.runtime.module.Module._collect_from_import_tree:4
#: tvm.runtime.module.Module.export_library:10
#: tvm.runtime.module.Module.get_function:4
#: tvm.runtime.module.Module.get_source:4
#: tvm.runtime.module.Module.implements_function:8
#: tvm.runtime.module.Module.import_module:4 tvm.runtime.module.Module.save:7
#: tvm.runtime.module.Module.time_evaluator:4 tvm.runtime.module.enabled:4
#: tvm.runtime.module.load_module:4 tvm.runtime.module.system_lib:14
#: tvm.runtime.ndarray.cpu:4 tvm.runtime.ndarray.cuda:4
#: tvm.runtime.ndarray.device:4 tvm.runtime.ndarray.ext_dev:4
#: tvm.runtime.ndarray.gpu:7 tvm.runtime.ndarray.metal:4
#: tvm.runtime.ndarray.opencl:4 tvm.runtime.ndarray.rocm:4
#: tvm.runtime.ndarray.vpi:4 tvm.runtime.ndarray.vulkan:4
#: tvm.runtime.object_generic.const:4 tvm.runtime.object_generic.convert:4
#: tvm.runtime.object_generic.convert_to_object:4
#: tvm.runtime.params.load_param_dict:4
#: tvm.runtime.params.load_param_dict_from_file:4
#: tvm.runtime.params.save_param_dict:7
#: tvm.runtime.params.save_param_dict_to_file:4
#: tvm.runtime.profiling.Report.__init__:4
#: tvm.runtime.profiling.Report.from_json:4
#: tvm.runtime.profiling.Report.table:4
#: tvm.runtime.script_printer.Scriptable.script:4
#: tvm.runtime.script_printer.Scriptable.show:4
msgid "Parameters"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device.free_raw_stream:6
msgid "The stream which should to be released."
msgstr ""

#: of tvm.runtime.Device.l2_cache_size_bytes:3
msgid "Supported devices include CUDA/ROCM/OpenCL."
msgstr ""

#: of tvm.runtime.Device.l2_cache_size_bytes:9
msgid "l2_cache_size_bytes"
msgstr ""

#: of tvm.runtime.Device.l2_cache_size_bytes:8
msgid ""
"The size of the device L2 cache in bytes returned by device runtime API. "
"Return None if the device does not support this feature."
msgstr ""

#: of tvm.runtime.Device.l2_cache_size_bytes:12
#: tvm.runtime.module.Module.time_evaluator:48
#: tvm.runtime.module.load_module:18 tvm.runtime.ndarray.ext_dev:14
#: tvm.runtime.object.Object._move:10 tvm.runtime.object_generic.convert:16
msgid "Note"
msgstr ""

#: of tvm.runtime.Device.l2_cache_size_bytes:13
msgid ""
"The value returned by opencl's API is smaller than actual device L2 cache"
" size."
msgstr ""

#: of tvm.runtime.Device.max_clock_rate:3
#: tvm.runtime.Device.multi_processor_count:3
msgid ""
"Returns device value for cuda, rocm, and opencl.  Returns remote device "
"value for RPC devices.  Returns None for all other devices."
msgstr ""

#: of tvm.runtime.Device.max_clock_rate:9
msgid "max_clock_rate"
msgstr ""

#: of tvm.runtime.Device.max_clock_rate:10
msgid "The maximum clock frequency of the device (kHz)"
msgstr ""

#: of tvm.runtime.Device.max_shared_memory_per_block:9
msgid "max_shared_memory_per_block"
msgstr ""

#: of tvm.runtime.Device.max_shared_memory_per_block:10
msgid "Total amount of shared memory per block in bytes"
msgstr ""

#: of tvm.runtime.Device.max_thread_dimensions:9
msgid "dims: List of int, or None"
msgstr ""

#: of tvm.runtime.Device.max_thread_dimensions:10
msgid "The maximum length of threadIdx.x, threadIdx.y, threadIdx.z"
msgstr ""

#: of tvm.runtime.Device.max_threads_per_block:3
msgid ""
"Returns device value for cuda, metal, rocm, opencl, and vulkan devices.  "
"Returns remote device value for RPC devices. Returns None for all other "
"devices."
msgstr ""

#: of tvm.runtime.Device.max_threads_per_block:9
msgid "max_threads_per_block"
msgstr ""

#: of tvm.runtime.Device.max_threads_per_block:10
msgid "The number of threads on each block"
msgstr ""

#: of tvm.runtime.Device.multi_processor_count:9
msgid "multi_processor_count"
msgstr ""

#: of tvm.runtime.Device.multi_processor_count:10
msgid "Thee number of compute units in the device"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device.set_raw_stream:6
msgid "The stream which should to be set to the device."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device.sync:6
msgid "Jobs in this stream should be finished."
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device.texture_spatial_limit:5
msgid "limit"
msgstr ""

#: of tvm._ffi.runtime_ctypes.Device.texture_spatial_limit:6
msgid "Maximum size of the texture by spatial dimensions"
msgstr ""

#: of tvm.runtime.Device.total_global_memory:3
msgid "Supported devices include CUDA/ROCm/Metal/OpenCL."
msgstr ""

#: of tvm.runtime.Device.total_global_memory:8
msgid "total_global_memory"
msgstr ""

#: of tvm.runtime.Device.total_global_memory:8
msgid ""
"Return the global memory available on device in bytes. Return None if the"
" device does not support this feature."
msgstr ""

#: of tvm.runtime.Device.warp_size:3
msgid ""
"Returns device value for cuda, rocm, and vulkan.  Returns 1 for metal and"
" opencl devices, regardless of the physical device.  Returns remote "
"device value for RPC devices.  Returns None for all other devices."
msgstr ""

#: of tvm.runtime.Device.warp_size:10
msgid "warp_size"
msgstr ""

#: of tvm.runtime.Device.warp_size:11
msgid "Number of threads that execute concurrently"
msgstr ""

#: of tvm.runtime.module.Module:1:<autosummary>:1
msgid ""
":py:obj:`_collect_from_import_tree "
"<tvm.runtime.Module._collect_from_import_tree>`\\ \\(filter\\_func\\)"
msgstr ""

#: of tvm.runtime.module.Module._collect_from_import_tree:1
#: tvm.runtime.module.Module:1:<autosummary>:1
msgid ""
"Helper function to collect modules from the tree matching a filter_func, "
"then return it."
msgstr ""

#: of tvm.runtime.module.Module:1:<autosummary>:1
msgid ":py:obj:`clear_imports <tvm.runtime.Module.clear_imports>`\\ \\(\\)"
msgstr ""

#: of tvm.runtime.module.Module.clear_imports:1
#: tvm.runtime.module.Module:1:<autosummary>:1
msgid "Remove all imports of the module."
msgstr ""

#: of tvm.runtime.module.Module:1:<autosummary>:1
msgid ""
":py:obj:`export_library <tvm.runtime.Module.export_library>`\\ "
"\\(file\\_name\\, \\*\\[\\, fcompile\\, ...\\]\\)"
msgstr ""

#: of tvm.runtime.module.Module.export_library:1
#: tvm.runtime.module.Module:1:<autosummary>:1
msgid "Export the module and all imported modules into a single device library."
msgstr ""

#: of tvm.runtime.module.Module:1:<autosummary>:1
msgid ""
":py:obj:`get_function <tvm.runtime.Module.get_function>`\\ \\(name\\[\\, "
"query\\_imports\\]\\)"
msgstr ""

#: of tvm.runtime.module.Module.get_function:1
#: tvm.runtime.module.Module:1:<autosummary>:1
msgid "Get function from the module."
msgstr ""

#: of tvm.runtime.module.Module:1:<autosummary>:1
msgid ""
":py:obj:`get_property_mask <tvm.runtime.Module.get_property_mask>`\\ "
"\\(\\)"
msgstr ""

#: of tvm.runtime.module.Module:1:<autosummary>:1
msgid "Get the runtime module property mask."
msgstr ""

#: of tvm.runtime.module.Module:1:<autosummary>:1
msgid ":py:obj:`get_source <tvm.runtime.Module.get_source>`\\ \\(\\[fmt\\]\\)"
msgstr ""

#: of tvm.runtime.module.Module.get_source:1
#: tvm.runtime.module.Module:1:<autosummary>:1
msgid "Get source code from module, if available."
msgstr ""

#: of tvm.runtime.module.Module:1:<autosummary>:1
msgid ""
":py:obj:`implements_function <tvm.runtime.Module.implements_function>`\\ "
"\\(name\\[\\, query\\_imports\\]\\)"
msgstr ""

#: of tvm.runtime.module.Module:1:<autosummary>:1
msgid ""
"Returns True if the module has a definition for the global function with "
"name."
msgstr ""

#: of tvm.runtime.module.Module:1:<autosummary>:1
msgid ":py:obj:`import_module <tvm.runtime.Module.import_module>`\\ \\(module\\)"
msgstr ""

#: of tvm.runtime.module.Module.import_module:1
#: tvm.runtime.module.Module:1:<autosummary>:1
msgid "Add module to the import list of current one."
msgstr ""

#: of tvm.runtime.module.Module:1:<autosummary>:1
msgid ":py:obj:`save <tvm.runtime.Module.save>`\\ \\(file\\_name\\[\\, fmt\\]\\)"
msgstr ""

#: of tvm.runtime.module.Module.save:1
#: tvm.runtime.module.Module:1:<autosummary>:1
msgid "Save the module to file."
msgstr ""

#: of tvm.runtime.module.Module:1:<autosummary>:1
msgid ""
":py:obj:`time_evaluator <tvm.runtime.Module.time_evaluator>`\\ "
"\\(func\\_name\\, dev\\[\\, number\\, ...\\]\\)"
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:1
#: tvm.runtime.module.Module:1:<autosummary>:1
msgid "Get an evaluator that measures time cost of running function."
msgstr ""

#: of tvm.runtime.module.Module._collect_from_import_tree:1:<autosummary>:1
msgid ":py:obj:`entry_func <tvm.runtime.Module.entry_func>`\\"
msgstr ""

#: of tvm.runtime.Module.entry_func:1
#: tvm.runtime.module.Module._collect_from_import_tree:1:<autosummary>:1
msgid "Get the entry function"
msgstr ""

#: of tvm.runtime.module.Module._collect_from_import_tree:1:<autosummary>:1
msgid ":py:obj:`format <tvm.runtime.Module.format>`\\"
msgstr ""

#: of tvm.runtime.Module.format:1
#: tvm.runtime.module.Module._collect_from_import_tree:1:<autosummary>:1
msgid "Get the format of the module."
msgstr ""

#: of tvm.runtime.module.Module._collect_from_import_tree:1:<autosummary>:1
msgid ":py:obj:`imported_modules <tvm.runtime.Module.imported_modules>`\\"
msgstr ""

#: of tvm.runtime.Module.imported_modules:1
#: tvm.runtime.module.Module._collect_from_import_tree:1:<autosummary>:1
msgid "Get imported modules"
msgstr ""

#: of tvm.runtime.module.Module._collect_from_import_tree:1:<autosummary>:1
msgid ""
":py:obj:`is_binary_serializable "
"<tvm.runtime.Module.is_binary_serializable>`\\"
msgstr ""

#: of tvm.runtime.Module.is_binary_serializable:4
#: tvm.runtime.module.Module._collect_from_import_tree:1:<autosummary>:1
msgid ""
"Returns true if module is 'binary serializable', ie can be serialzed into"
" binary"
msgstr ""

#: of tvm.runtime.module.Module._collect_from_import_tree:1:<autosummary>:1
msgid ":py:obj:`is_dso_exportable <tvm.runtime.Module.is_dso_exportable>`\\"
msgstr ""

#: of tvm.runtime.Module.is_dso_exportable:1
#: tvm.runtime.module.Module._collect_from_import_tree:1:<autosummary>:1
msgid ""
"Returns true if module is 'DSO exportable', ie can be included in result "
"of export_library by the external compiler directly."
msgstr ""

#: of tvm.runtime.module.Module._collect_from_import_tree:1:<autosummary>:1
msgid ":py:obj:`is_runnable <tvm.runtime.Module.is_runnable>`\\"
msgstr ""

#: of tvm.runtime.module.Module._collect_from_import_tree:1:<autosummary>:1
msgid "Returns true if module is 'runnable'."
msgstr ""

#: of tvm.runtime.module.Module._collect_from_import_tree:1:<autosummary>:1
msgid ":py:obj:`type_key <tvm.runtime.Module.type_key>`\\"
msgstr ""

#: of tvm.runtime.Module.type_key:1
#: tvm.runtime.module.Module._collect_from_import_tree:1:<autosummary>:1
msgid "Get type key of the module."
msgstr ""

#: of tvm.runtime.module.Module._collect_from_import_tree:7
msgid "filter_func"
msgstr ""

#: of tvm.runtime.module.Module._collect_from_import_tree:-1
msgid "Callable[[Module], bool]"
msgstr ""

#: of tvm.runtime.module.Module._collect_from_import_tree:6
msgid ""
"A function which is invoked for each Module discovered in the import tree"
" (including self)."
msgstr ""

#: of tvm.runtime.module.Module._collect_from_import_tree:11
msgid "list[Module] :"
msgstr ""

#: of tvm.runtime.module.Module._collect_from_import_tree:12
msgid "A list of matching Module."
msgstr ""

#: of tvm.runtime.Module.entry_func:5 tvm.runtime.module.Module.get_function:13
msgid "f"
msgstr ""

#: of tvm.runtime.Module.entry_func:-1
#: tvm.runtime.module.Module.get_function:-1
msgid "tvm.runtime.PackedFunc"
msgstr ""

#: of tvm.runtime.Module.entry_func:6
msgid "The entry function if exist"
msgstr ""

#: of tvm.runtime.module.Module.export_library:3
msgid ""
"This function only works on host LLVM modules, other runtime::Module "
"subclasses will work with this API but they must support implement the "
"save and load mechanisms of modules completely including saving from "
"streams and files. This will pack your non-shared library module into a "
"single shared library which can later be loaded by TVM."
msgstr ""

#: of tvm.runtime.module.Module.export_library:12
#: tvm.runtime.module.Module.save:8
msgid "file_name"
msgstr ""

#: of tvm.runtime.container.String:-1
#: tvm.runtime.module.Module.export_library:-1
#: tvm.runtime.module.Module.get_function:-1
#: tvm.runtime.module.Module.get_source:-1
#: tvm.runtime.module.Module.implements_function:-1
#: tvm.runtime.module.Module.save:-1 tvm.runtime.module.enabled:-1
#: tvm.runtime.module.load_module:-1
#: tvm.runtime.object_generic.convert_to_object:-1
#: tvm.runtime.profiling.Report.csv:-1
#: tvm.runtime.profiling.Report.from_json:-1
#: tvm.runtime.profiling.Report.json:-1
#: tvm.runtime.script_printer.Scriptable.script:-1
msgid "str"
msgstr ""

#: of tvm.runtime.module.Module.export_library:12
msgid "The name of the shared library."
msgstr ""

#: of tvm.runtime.module.Module.export_library:24
msgid "fcompile"
msgstr ""

#: of tvm.runtime.module.Module.export_library:-1
msgid "function(target, file_list, kwargs), optional"
msgstr ""

#: of tvm.runtime.module.Module.export_library:15
msgid ""
"The compilation function to use create the final library object during "
"export."
msgstr ""

#: of tvm.runtime.module.Module.export_library:18
msgid ""
"For example, when fcompile=_cc.create_shared, or when it is not supplied "
"but module is \"llvm,\" this is used to link all produced artifacts into "
"a final dynamic library."
msgstr ""

#: of tvm.runtime.module.Module.export_library:22
msgid ""
"This behavior is controlled by the type of object exported. If fcompile "
"has attribute object_format, will compile host library to that format. "
"Otherwise, will use default format \"o\"."
msgstr ""

#: of tvm.runtime.module.Module.export_library:34
msgid ""
"fpack_imports: function(mod: runtime.Module, is_system_lib: bool, "
"symbol_prefix: str,"
msgstr ""

#: of tvm.runtime.module.Module.export_library:27
msgid "workspace_dir: str) -> str"
msgstr ""

#: of tvm.runtime.module.Module.export_library:28
msgid ""
"Function used to pack imported modules from `mod` into a file suitable "
"for passing to fcompile as an input file. The result can be a C source, "
"or an .o object file, or any other file that the fcompile function can "
"handle. The function returns the name of the created file."
msgstr ""

#: of tvm.runtime.module.Module.export_library:33
msgid ""
"If not provided, the imported modules will be serialized either via "
"packing to an LLVM module, or to a C source file."
msgstr ""

#: of tvm.runtime.module.Module.export_library:39
msgid "workspace_dir"
msgstr ""

#: of tvm.runtime.module.Module.export_library:-1
#: tvm.runtime.module.Module.get_source:-1 tvm.runtime.module.load_module:-1
#: tvm.runtime.script_printer.Scriptable.show:-1
msgid "str, optional"
msgstr ""

#: of tvm.runtime.module.Module.export_library:37
msgid ""
"The path of the directory used to create the intermediate artifacts when "
"exporting the module. If this is not provided a temporary dir will be "
"created."
msgstr ""

#: of tvm.runtime.module.Module.export_library:42
msgid "kwargs"
msgstr ""

#: of tvm.runtime.module.Module.export_library:-1
msgid "dict, optional"
msgstr ""

#: of tvm.runtime.module.Module.export_library:42
msgid "Additional arguments passed to fcompile"
msgstr ""

#: of tvm.runtime.module.Module.export_library:47
msgid "result of fcompile()"
msgstr ""

#: of tvm.runtime.module.Module.export_library:-1
msgid "unknown, optional"
msgstr ""

#: of tvm.runtime.module.Module.export_library:47
msgid ""
"If the compilation function returns an artifact it would be returned via "
"export_library, if any."
msgstr ""

#: of tvm.runtime.module.Module.get_function:6
#: tvm.runtime.module.Module.implements_function:10
#: tvm.runtime.script_printer.Scriptable.script:5
#: tvm.runtime.script_printer.Scriptable.show:28
msgid "name"
msgstr ""

#: of tvm.runtime.module.Module.get_function:6
#: tvm.runtime.module.Module.implements_function:10
msgid "The name of the function"
msgstr ""

#: of tvm.runtime.module.Module.get_function:9
#: tvm.runtime.module.Module.implements_function:13
msgid "query_imports"
msgstr ""

#: of tvm.runtime.module.Module.get_function:9
msgid "Whether also query modules imported by this module."
msgstr ""

#: of tvm.runtime.module.Module.get_function:14
msgid "The result function."
msgstr ""

#: of tvm.runtime.module.Module.get_property_mask:1
msgid ""
"Get the runtime module property mask. The mapping is stated in "
"ModulePropertyMask."
msgstr ""

#: of tvm.runtime.module.Module.get_property_mask:5
msgid "mask"
msgstr ""

#: of tvm.runtime.module.Module.get_property_mask:-1
#: tvm.runtime.module.num_threads:5
msgid "int"
msgstr ""

#: of tvm.runtime.module.Module.get_property_mask:6
msgid "Bitmask of runtime module property"
msgstr ""

#: of tvm.runtime.module.Module.get_source:6 tvm.runtime.module.Module.save:11
#: tvm.runtime.module.load_module:10
msgid "fmt"
msgstr ""

#: of tvm.runtime.module.Module.get_source:6
msgid "The specified format."
msgstr ""

#: of tvm.runtime.module.Module.get_source:10
msgid "source"
msgstr ""

#: of tvm.runtime.module.Module.get_source:11
msgid "The result source code."
msgstr ""

#: of tvm.runtime.module.Module.implements_function:1
msgid ""
"Returns True if the module has a definition for the global function with "
"name. Note that has_function(name) does not imply get_function(name) is "
"non-null since the module may be, eg, a CSourceModule which cannot supply"
" a packed-func implementation of the function without further "
"compilation. However, get_function(name) non null should always imply "
"has_function(name)."
msgstr ""

#: of tvm.runtime.module.Module.implements_function:13
msgid "Whether to also query modules imported by this module."
msgstr ""

#: of tvm.runtime.Module.is_binary_serializable:8
#: tvm.runtime.Module.is_dso_exportable:6 tvm.runtime.Module.is_runnable:6
#: tvm.runtime.module.Module.implements_function:17
msgid "b"
msgstr ""

#: of tvm.runtime.Module.is_binary_serializable:-1
#: tvm.runtime.Module.is_dso_exportable:-1 tvm.runtime.Module.is_runnable:-1
#: tvm.runtime.module.Module.implements_function:-1
msgid "Bool"
msgstr ""

#: of tvm.runtime.module.Module.implements_function:18
msgid "True if module (or one of its imports) has a definition for name."
msgstr ""

#: of tvm.runtime.module.Module.import_module:5
#: tvm.runtime.module.load_module:15 tvm.runtime.module.system_lib:21
msgid "module"
msgstr ""

#: of tvm.runtime.module.Module.import_module:-1
msgid "tvm.runtime.Module"
msgstr ""

#: of tvm.runtime.module.Module.import_module:6
msgid "The other module."
msgstr ""

#: of tvm.runtime.Module.imported_modules:5
msgid "modules"
msgstr ""

#: of tvm.runtime.Module.imported_modules:-1
msgid "list of Module"
msgstr ""

#: of tvm.runtime.Module.imported_modules:6
msgid "The module"
msgstr ""

#: of tvm.runtime.Module.is_binary_serializable:4
msgid "stream and loaded back to the runtime module."
msgstr ""

#: of tvm.runtime.Module.is_binary_serializable:9
msgid "True if the module is binary serializable."
msgstr ""

#: of tvm.runtime.Module.is_dso_exportable:7
msgid "True if the module is DSO exportable."
msgstr ""

#: of tvm.runtime.Module.is_runnable:1
msgid ""
"Returns true if module is 'runnable'. ie can be executed without any "
"extra compilation/linking steps."
msgstr ""

#: of tvm.runtime.Module.is_runnable:7
msgid "True if the module is runnable."
msgstr ""

#: of tvm.runtime.module.Module.save:3
msgid "This do not save the dependent device modules. See also export_shared"
msgstr ""

#: of tvm.runtime.module.Module.save:9
msgid "The name of the file."
msgstr ""

#: of tvm.runtime.module.Module.save:11
msgid "The format of the file."
msgstr ""

#: of tvm.runtime.module.Module.save:14 tvm.runtime.packed_func.PackedFunc:17
msgid "See Also"
msgstr ""

#: of tvm.runtime.module.Module.save:15
msgid "runtime.Module.export_library : export the module to shared library."
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:6
msgid "func_name: str"
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:6
msgid "The name of the function in the module."
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:9
msgid "dev: Device"
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:9
msgid "The device we should run this function on."
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:13
msgid "number: int"
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:12
msgid ""
"The number of times to run this function for taking average. We call "
"these runs as one `repeat` of measurement."
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:20
msgid "repeat: int, optional"
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:16
msgid ""
"The number of times to repeat the measurement. In total, the function "
"will be invoked (1 + number x repeat) times, where the first one is warm "
"up and will be discarded. The returned result contains `repeat` costs, "
"each of which is an average of `number` costs."
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:28
msgid "min_repeat_ms: int, optional"
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:23
msgid ""
"The minimum duration of one `repeat` in milliseconds. By default, one "
"`repeat` contains `number` runs. If this parameter is set, the parameters"
" `number` will be dynamically adjusted to meet the minimum duration "
"requirement of one `repeat`. i.e., When the run time of one `repeat` "
"falls below this time, the `number` parameter will be automatically "
"increased."
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:32
msgid "limit_zero_time_iterations: int, optional"
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:31
msgid ""
"The maximum number of repeats when measured time is equal to 0. It helps "
"to avoid hanging during measurements."
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:36
msgid "cooldown_interval_ms: int, optional"
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:35
msgid ""
"The cooldown interval in milliseconds between the number of repeats "
"defined by `repeats_to_cooldown`."
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:39
msgid "repeats_to_cooldown: int, optional"
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:39
msgid "The number of repeats before the cooldown is activated."
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:42
msgid "cache_flush_bytes: int, optional"
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:42
msgid "The number of bytes to flush from the cache before each repeat."
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:45
msgid "f_preproc: str, optional"
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:45
msgid ""
"The preprocess function name we want to execute before executing the time"
" evaluator."
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:49
msgid ""
"The function will be invoked  (1 + number x repeat) times, with the first"
" call discarded in case there is lazy initialization."
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:55
msgid "ftimer"
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:-1
msgid "function"
msgstr ""

#: of tvm.runtime.module.Module.time_evaluator:55
msgid ""
"The function that takes same argument as func and returns a "
"BenchmarkResult. The ProfileResult reports `repeat` time costs in "
"seconds."
msgstr ""

#: of tvm.runtime.object.Object._move:1:<autosummary>:1
msgid ":py:obj:`_move <tvm.runtime.Object._move>`\\ \\(\\)"
msgstr ""

#: of tvm.runtime.object.Object._move:1
#: tvm.runtime.object.Object._move:1:<autosummary>:1
msgid "Create an RValue reference to the object and mark the object as moved."
msgstr ""

#: of tvm.runtime.object.Object._move:3
msgid ""
"This is a advanced developer API that can be useful when passing an "
"unique reference to an Object that you no longer needed to a function."
msgstr ""

#: of tvm.runtime.object.Object._move:6
msgid ""
"A unique reference can trigger copy on write optimization that avoids "
"copy when we transform an object."
msgstr ""

#: of tvm.runtime.object.Object._move:11
msgid ""
"All the reference of the object becomes invalid after it is moved. Be "
"very careful when using this feature."
msgstr ""

#: of tvm.runtime.module.enabled:14 tvm.runtime.ndarray.device:17
#: tvm.runtime.object.Object._move:15 tvm.runtime.params.save_param_dict:17
msgid "Examples"
msgstr ""

#: of tvm.runtime.object.Object._move:26
msgid "rvalue : The rvalue reference."
msgstr ""

#: of tvm.runtime.object_generic.ObjectGeneric.asobject:1:<autosummary>:1
msgid ":py:obj:`asobject <tvm.runtime.ObjectGeneric.asobject>`\\ \\(\\)"
msgstr ""

#: of tvm.runtime.object_generic.ObjectGeneric.asobject:1
#: tvm.runtime.object_generic.ObjectGeneric.asobject:1:<autosummary>:1
msgid "Convert value to object"
msgstr ""

#: of tvm.runtime.packed_func.PackedFunc:3
msgid ""
"Function plays an key role to bridge front and backend in TVM. Function "
"provide a type-erased interface, you can call function with positional "
"arguments."
msgstr ""

#: of tvm.runtime.packed_func.PackedFunc:6
msgid ""
"The compiled module returns Function. TVM backend also registers and "
"exposes its API as Functions."
msgstr ""

#: of tvm.runtime.packed_func.PackedFunc:9
msgid "The following are list of common usage scenario of tvm.runtime.PackedFunc."
msgstr ""

#: of tvm.runtime.packed_func.PackedFunc:11
msgid "Automatic exposure of C++ API into python"
msgstr ""

#: of tvm.runtime.packed_func.PackedFunc:12
msgid "To call PackedFunc from python side"
msgstr ""

#: of tvm.runtime.packed_func.PackedFunc:13
msgid "To call python callbacks to inspect results in generated code"
msgstr ""

#: of tvm.runtime.packed_func.PackedFunc:14
msgid "Bring python hook into C++ backend"
msgstr ""

#: of tvm.runtime.packed_func.PackedFunc:18
msgid ""
"tvm.register_func: How to register global function. tvm.get_global_func: "
"How to get global function."
msgstr ""

#: of tvm.runtime.profiling.Report:4
msgid "Attributes"
msgstr ""

#: of tvm.runtime.profiling.Report:6 tvm.runtime.profiling.Report.__init__:6
msgid "calls"
msgstr ""

#: of tvm.runtime.profiling.Report:-1
msgid "Array[Dict[str, Object]]"
msgstr ""

#: of tvm.runtime.profiling.Report:6
msgid "Per-call profiling metrics (function name, runtime, device, ...)."
msgstr ""

#: of tvm.runtime.profiling.Report:9 tvm.runtime.profiling.Report.__init__:9
msgid "device_metrics"
msgstr ""

#: of tvm.runtime.profiling.Report:-1
msgid "Dict[Device, Dict[str, Object]]"
msgstr ""

#: of tvm.runtime.profiling.Report:9
msgid "Per-device metrics collected over the entire run."
msgstr ""

#: of tvm.runtime.profiling.Report.__init__:1:<autosummary>:1
msgid ""
":py:obj:`__init__ <tvm.runtime.Report.__init__>`\\ \\(calls\\, "
"device\\_metrics\\, configuration\\)"
msgstr ""

#: of tvm.runtime.profiling.Report.__init__:1
#: tvm.runtime.profiling.Report.__init__:1:<autosummary>:1
msgid ""
"Construct a profiling report from a list of metrics and per-device "
"metrics."
msgstr ""

#: of tvm.runtime.profiling.Report.__init__:1:<autosummary>:1
msgid ":py:obj:`csv <tvm.runtime.Report.csv>`\\ \\(\\)"
msgstr ""

#: of tvm.runtime.profiling.Report.__init__:1:<autosummary>:1
#: tvm.runtime.profiling.Report.csv:1
msgid "Convert this profiling report into CSV format."
msgstr ""

#: of tvm.runtime.profiling.Report.__init__:1:<autosummary>:1
msgid ":py:obj:`from_json <tvm.runtime.Report.from_json>`\\ \\(s\\)"
msgstr ""

#: of tvm.runtime.profiling.Report.__init__:1:<autosummary>:1
#: tvm.runtime.profiling.Report.from_json:1
msgid "Deserialize a report from JSON."
msgstr ""

#: of tvm.runtime.profiling.Report.__init__:1:<autosummary>:1
msgid ":py:obj:`json <tvm.runtime.Report.json>`\\ \\(\\)"
msgstr ""

#: of tvm.runtime.profiling.Report.__init__:1:<autosummary>:1
#: tvm.runtime.profiling.Report.json:1
msgid "Convert this profiling report into JSON format."
msgstr ""

#: of tvm.runtime.profiling.Report.__init__:1:<autosummary>:1
msgid ""
":py:obj:`table <tvm.runtime.Report.table>`\\ \\(\\[sort\\, aggregate\\, "
"col\\_sums\\]\\)"
msgstr ""

#: of tvm.runtime.profiling.Report.__init__:1:<autosummary>:1
#: tvm.runtime.profiling.Report.table:1
msgid "Generate a human-readable table"
msgstr ""

#: of tvm.runtime.profiling.Report.__init__:-1
msgid "Sequence[Dict[str, Object]]"
msgstr ""

#: of tvm.runtime.profiling.Report.__init__:6
msgid "Per function call metrics."
msgstr ""

#: of tvm.runtime.profiling.Report.__init__:-1
msgid "Dict[str, Dict[str, Object]]"
msgstr ""

#: of tvm.runtime.profiling.Report.__init__:9
msgid "Per device metrics."
msgstr ""

#: of tvm.runtime.profiling.Report.__init__:12
msgid "configuration"
msgstr ""

#: of tvm.runtime.profiling.Report.__init__:-1
msgid "Dict[str, Object]"
msgstr ""

#: of tvm.runtime.profiling.Report.__init__:12
msgid ""
"Configuration of TVM for this profiling run. Includes number of threads, "
"executor."
msgstr ""

#: of tvm.runtime.profiling.Report.csv:3
msgid "This only includes calls and not overall metrics."
msgstr ""

#: of tvm.runtime.profiling.Report.csv:7
msgid "csv"
msgstr ""

#: of tvm.runtime.profiling.Report.csv:8
msgid "`calls` in CSV format."
msgstr ""

#: of tvm.runtime.profiling.Report.from_json:6
msgid "s"
msgstr ""

#: of tvm.runtime.profiling.Report.from_json:6
msgid "Report serialize via :py:meth:`json`."
msgstr ""

#: of tvm.runtime.profiling.Report.from_json:10
msgid "report"
msgstr ""

#: of tvm.runtime.profiling.Report.from_json:-1
msgid "Report"
msgstr ""

#: of tvm.runtime.profiling.Report.from_json:11
msgid "The deserialized report."
msgstr ""

#: of tvm.runtime.profiling.Report.json:3
msgid "Example output:"
msgstr ""

#: of tvm.runtime.profiling.Report.json:52
msgid "json"
msgstr ""

#: of tvm.runtime.profiling.Report.json:53
msgid "Formatted JSON"
msgstr ""

#: of tvm.runtime.profiling.Report.table:5
msgid "sort : bool"
msgstr ""

#: of tvm.runtime.profiling.Report.table:7
msgid ""
"If aggregate is true, whether to sort call frames by descending duration."
"  If aggregate is False, whether to sort frames by order of appearancei n"
" the program."
msgstr ""

#: of tvm.runtime.profiling.Report.table:11
msgid "aggregate : bool"
msgstr ""

#: of tvm.runtime.profiling.Report.table:13
msgid "Whether to join multiple calls to the same op into a single line."
msgstr ""

#: of tvm.runtime.profiling.Report.table:16
msgid "col_sums : bool"
msgstr ""

#: of tvm.runtime.profiling.Report.table:18
msgid "Whether to include the sum of each column."
msgstr ""

#: of tvm.runtime.profiling.Report.table:22
msgid "table : str"
msgstr ""

#: of tvm.runtime.profiling.Report.table:24
msgid "A human-readable table"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:1:<autosummary>:1
msgid ""
":py:obj:`script <tvm.runtime.Scriptable.script>`\\ \\(\\*\\[\\, name\\, "
"show\\_meta\\, ir\\_prefix\\, ...\\]\\)"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:1
#: tvm.runtime.script_printer.Scriptable.script:1:<autosummary>:1
msgid "Print TVM IR into TVMScript text format"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:1:<autosummary>:1
msgid ""
":py:obj:`show <tvm.runtime.Scriptable.show>`\\ \\(\\[style\\, "
"black\\_format\\, name\\, show\\_meta\\, ...\\]\\)"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:1:<autosummary>:1
#: tvm.runtime.script_printer.Scriptable.show:1
msgid "A sugar for print highlighted TVM script."
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:-1
#: tvm.runtime.script_printer.Scriptable.show:-1
msgid "Optional[str] = None"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:6
#: tvm.runtime.script_printer.Scriptable.show:29
msgid "The name of the object"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:7
#: tvm.runtime.script_printer.Scriptable.show:30
msgid "show_meta"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:-1
#: tvm.runtime.script_printer.Scriptable.show:-1
msgid "bool = False"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:8
#: tvm.runtime.script_printer.Scriptable.show:31
msgid "Whether to print the meta data of the object"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:9
#: tvm.runtime.script_printer.Scriptable.show:32
msgid "ir_prefix"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:-1
#: tvm.runtime.script_printer.Scriptable.show:-1
msgid "str = \"I\""
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:10
#: tvm.runtime.script_printer.Scriptable.show:33
msgid "The prefix of AST nodes from tvm.ir"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:11
#: tvm.runtime.script_printer.Scriptable.show:34
msgid "tir_prefix"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:-1
#: tvm.runtime.script_printer.Scriptable.show:-1
msgid "str = \"T\""
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:12
#: tvm.runtime.script_printer.Scriptable.show:35
msgid "The prefix of AST nodes from tvm.tir"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:13
#: tvm.runtime.script_printer.Scriptable.show:36
msgid "relax_prefix"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:-1
#: tvm.runtime.script_printer.Scriptable.show:-1
msgid "str = \"R\""
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:14
#: tvm.runtime.script_printer.Scriptable.show:37
msgid "The prefix of AST nodes from tvm.relax"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:16
#: tvm.runtime.script_printer.Scriptable.show:39
msgid "module_alias"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:-1
#: tvm.runtime.script_printer.Scriptable.show:-1
msgid "str = \"cls\""
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:16
#: tvm.runtime.script_printer.Scriptable.show:39
msgid ""
"The alias of the current module at cross-function call, Directly use "
"module name if it's empty."
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:18
#: tvm.runtime.script_printer.Scriptable.show:41
msgid "buffer_dtype"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:-1
#: tvm.runtime.script_printer.Scriptable.show:-1
msgid "str = \"float32\""
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:19
#: tvm.runtime.script_printer.Scriptable.show:42
msgid "The default data type of buffer"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:20
#: tvm.runtime.script_printer.Scriptable.show:43
msgid "int_dtype"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:-1
#: tvm.runtime.script_printer.Scriptable.show:-1
msgid "str = \"int32\""
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:21
#: tvm.runtime.script_printer.Scriptable.show:44
msgid "The default data type of integer"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:22
#: tvm.runtime.script_printer.Scriptable.show:45
msgid "float_dtype"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:-1
#: tvm.runtime.script_printer.Scriptable.show:-1
msgid "str = \"void\""
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:23
#: tvm.runtime.script_printer.Scriptable.show:46
msgid "The default data type of float"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:24
#: tvm.runtime.script_printer.Scriptable.show:47
msgid "verbose_expr"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:25
#: tvm.runtime.script_printer.Scriptable.show:48
msgid ""
"Whether to print the detailed definition of each variable in the "
"expression"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:26
#: tvm.runtime.script_printer.Scriptable.show:49
msgid "indent_spaces"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:-1
#: tvm.runtime.script_printer.Scriptable.show:-1
msgid "int = 4"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:27
#: tvm.runtime.script_printer.Scriptable.show:50
msgid "The number of spaces for indentation"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:28
#: tvm.runtime.script_printer.Scriptable.show:51
msgid "print_line_numbers"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:29
#: tvm.runtime.script_printer.Scriptable.show:52
msgid "Whether to print line numbers"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:30
#: tvm.runtime.script_printer.Scriptable.show:53
msgid "num_context_lines"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:-1
#: tvm.runtime.script_printer.Scriptable.show:-1
msgid "int = -1"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:31
#: tvm.runtime.script_printer.Scriptable.show:54
msgid ""
"The number of lines of context to print before and after the line to "
"underline."
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:32
#: tvm.runtime.script_printer.Scriptable.show:55
msgid "syntax_sugar: bool = True"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:33
#: tvm.runtime.script_printer.Scriptable.show:56
msgid "Whether to output with syntax sugar, set false for complete printing."
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:34
#: tvm.runtime.script_printer.Scriptable.show:57
msgid "show_object_address: bool = False"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:35
#: tvm.runtime.script_printer.Scriptable.show:58
msgid "Whether to include the object's address as part of the TVMScript name"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:36
#: tvm.runtime.script_printer.Scriptable.show:59
msgid "path_to_underline"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:-1
#: tvm.runtime.script_printer.Scriptable.show:-1
msgid "Optional[List[ObjectPath]] = None"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:37
#: tvm.runtime.script_printer.Scriptable.show:60
msgid "Object path to be underlined"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:38
#: tvm.runtime.script_printer.Scriptable.show:61
msgid "path_to_annotate"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:-1
#: tvm.runtime.script_printer.Scriptable.show:-1
msgid "Optional[Dict[ObjectPath, str]] = None"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:39
#: tvm.runtime.script_printer.Scriptable.show:62
msgid "Object path to be annotated"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:40
#: tvm.runtime.script_printer.Scriptable.show:63
msgid "obj_to_underline"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:-1
#: tvm.runtime.script_printer.Scriptable.show:-1
msgid "Optional[List[Object]] = None"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:41
#: tvm.runtime.script_printer.Scriptable.show:64
msgid "Object to be underlined"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:43
#: tvm.runtime.script_printer.Scriptable.show:65
msgid "obj_to_annotate"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:-1
#: tvm.runtime.script_printer.Scriptable.show:-1
msgid "Optional[Dict[Object, str]] = None"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:43
#: tvm.runtime.script_printer.Scriptable.show:66
msgid "Object to be annotated"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:47
msgid "script"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.script:48
msgid "The TVM Script of the given TVM IR"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.show:7
msgid "style"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.show:6
msgid ""
"Pygmentize printing style, auto-detected if None.  See "
"`tvm.script.highlight.cprint` for more details."
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.show:9
msgid "black_format: Optional[bool]"
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.show:11
msgid ""
"If true, use the formatter Black to format the TVMScript. If false, do "
"not apply the auto-formatter."
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.show:14
msgid ""
"If None (default), determine the behavior based on the environment "
"variable \"TVM_BLACK_FORMAT\".  If this environment variable is unset, "
"set to the empty string, or set to the integer zero, black auto-"
"formatting will be disabled.  If the environment variable is set to a "
"non-zero integer, black auto-formatting will be enabled."
msgstr ""

#: of tvm.runtime.script_printer.Scriptable.show:21
msgid ""
"Note that the \"TVM_BLACK_FORMAT\" environment variable only applies to "
"the `.show()` method, and not the underlying `.script()` method.  The "
"`.show()` method is intended for human-readable output based on "
"individual user preferences, while the `.script()` method is intended to "
"provided a consistent output regardless of environment."
msgstr ""

#: of tvm.runtime.container.ShapeTuple:1
msgid "TVM runtime ShapeTuple object. Parameters ---------- shape : list[int]"
msgstr ""

#: of tvm.runtime.container.ShapeTuple:5
msgid "The shape list used to construct the object."
msgstr ""

#: of tvm.runtime.container.String:6
msgid "content"
msgstr ""

#: of tvm.runtime.container.String:6
msgid "The content string used to construct the object."
msgstr ""

#: of tvm.runtime.container.String.__from_tvm_object__:1:<autosummary>:1
msgid ""
":py:obj:`__from_tvm_object__ <tvm.runtime.String.__from_tvm_object__>`\\ "
"\\(obj\\)"
msgstr ""

#: of tvm.runtime.container.String.__from_tvm_object__:1
#: tvm.runtime.container.String.__from_tvm_object__:1:<autosummary>:1
msgid "Construct from a given tvm object."
msgstr ""

#: of tvm.runtime.container.String.__from_tvm_object__:1:<autosummary>:1
msgid ":py:obj:`__new__ <tvm.runtime.String.__new__>`\\ \\(cls\\, content\\)"
msgstr ""

#: of tvm.runtime.container.String.__from_tvm_object__:1:<autosummary>:1
#: tvm.runtime.container.String.__new__:1
msgid "Construct from string content."
msgstr ""

#: of tvm.runtime.ndarray.cpu:6 tvm.runtime.ndarray.cuda:6
#: tvm.runtime.ndarray.device:9 tvm.runtime.ndarray.ext_dev:6
#: tvm.runtime.ndarray.gpu:9 tvm.runtime.ndarray.metal:6
#: tvm.runtime.ndarray.opencl:6 tvm.runtime.ndarray.rocm:6
#: tvm.runtime.ndarray.vpi:6 tvm.runtime.ndarray.vulkan:6
msgid "dev_id"
msgstr ""

#: of tvm.runtime.ndarray.cpu:-1 tvm.runtime.ndarray.cuda:-1
#: tvm.runtime.ndarray.device:-1 tvm.runtime.ndarray.ext_dev:-1
#: tvm.runtime.ndarray.gpu:-1 tvm.runtime.ndarray.metal:-1
#: tvm.runtime.ndarray.opencl:-1 tvm.runtime.ndarray.rocm:-1
#: tvm.runtime.ndarray.vpi:-1 tvm.runtime.ndarray.vulkan:-1
msgid "int, optional"
msgstr ""

#: of tvm.runtime.ndarray.cpu:6 tvm.runtime.ndarray.cuda:6
#: tvm.runtime.ndarray.device:9 tvm.runtime.ndarray.ext_dev:6
#: tvm.runtime.ndarray.gpu:9 tvm.runtime.ndarray.metal:6
#: tvm.runtime.ndarray.opencl:6 tvm.runtime.ndarray.rocm:6
#: tvm.runtime.ndarray.vpi:6 tvm.runtime.ndarray.vulkan:6
msgid "The integer device id"
msgstr ""

#: of tvm.runtime.ndarray.cpu:10 tvm.runtime.ndarray.cuda:10
#: tvm.runtime.ndarray.ext_dev:11 tvm.runtime.ndarray.gpu:13
#: tvm.runtime.ndarray.metal:10 tvm.runtime.ndarray.opencl:10
#: tvm.runtime.ndarray.rocm:10 tvm.runtime.ndarray.vpi:10
#: tvm.runtime.ndarray.vulkan:10
msgid "dev"
msgstr ""

#: of tvm.runtime.ndarray.cpu:-1 tvm.runtime.ndarray.cuda:-1
#: tvm.runtime.ndarray.ext_dev:-1 tvm.runtime.ndarray.gpu:-1
#: tvm.runtime.ndarray.metal:-1 tvm.runtime.ndarray.opencl:-1
#: tvm.runtime.ndarray.rocm:-1 tvm.runtime.ndarray.vpi:-1
#: tvm.runtime.ndarray.vulkan:-1
msgid "Device"
msgstr ""

#: of tvm.runtime.ndarray.cpu:11 tvm.runtime.ndarray.cuda:11
#: tvm.runtime.ndarray.ext_dev:11 tvm.runtime.ndarray.gpu:14
#: tvm.runtime.ndarray.metal:11 tvm.runtime.ndarray.opencl:11
#: tvm.runtime.ndarray.rocm:11 tvm.runtime.ndarray.vpi:11
#: tvm.runtime.ndarray.vulkan:11
msgid "The created device"
msgstr ""

#: of tvm.runtime.object_generic.const:6
#: tvm.runtime.object_generic.convert_to_object:6
msgid "value"
msgstr ""

#: of tvm.runtime.object_generic.const:-1
msgid "number"
msgstr ""

#: of tvm.runtime.object_generic.const:6
msgid "The content of the constant number."
msgstr ""

#: of tvm.runtime.object_generic.const:9
msgid "dtype"
msgstr ""

#: of tvm.runtime.object_generic.const:-1
msgid "str or None, optional"
msgstr ""

#: of tvm.runtime.object_generic.const:9
msgid "The data type."
msgstr ""

#: of tvm.runtime.object_generic.const:12 tvm.runtime.object_generic.convert:8
#: tvm.runtime.object_generic.convert_to_object:9
msgid "span"
msgstr ""

#: of tvm.runtime.object_generic.const:-1 tvm.runtime.object_generic.convert:-1
#: tvm.runtime.object_generic.convert_to_object:-1
msgid "Optional[Span]"
msgstr ""

#: of tvm.runtime.object_generic.const:12
msgid "The location of the constant value in the source."
msgstr ""

#: of tvm.runtime.object_generic.const:16
msgid "const_val: tvm.Expr"
msgstr ""

#: of tvm.runtime.object_generic.const:17
msgid "The result expression."
msgstr ""

#: of tvm.runtime.object_generic.convert:5
msgid "value : python value"
msgstr ""

#: of tvm.runtime.object_generic.convert:8
msgid "The location of this statement in the source code."
msgstr ""

#: of tvm.runtime.object_generic.convert:13
msgid "tvm_val"
msgstr ""

#: of tvm.runtime.object_generic.convert:-1
msgid "Object or Function"
msgstr ""

#: of tvm.runtime.object_generic.convert:13
msgid "Converted value in TVM"
msgstr ""

#: of tvm.runtime.object_generic.convert:17
msgid ""
"This function is redirected to `convert_to_object` as it is widely used "
"in the codebase. We can choose one to keep and discard the other one "
"later."
msgstr ""

#: of tvm.runtime.object_generic.convert_to_object:6
msgid "The value to be inspected."
msgstr ""

#: of tvm.runtime.object_generic.convert_to_object:9
msgid "The location of this itervar in the source code."
msgstr ""

#: of tvm.runtime.object_generic.convert_to_object:13
msgid "obj"
msgstr ""

#: of tvm.runtime.object_generic.convert_to_object:-1
msgid "Object"
msgstr ""

#: of tvm.runtime.object_generic.convert_to_object:14
msgid "The corresponding object value."
msgstr ""

#: of tvm.runtime.ndarray.device:6
msgid "dev_type: int or str"
msgstr ""

#: of tvm.runtime.ndarray.device:6
msgid "The device type mask or name of the device."
msgstr ""

#: of tvm.runtime.ndarray.device:14
msgid "dev: tvm.runtime.Device"
msgstr ""

#: of tvm.runtime.ndarray.device:14
msgid "The corresponding device."
msgstr ""

#: of tvm.runtime.ndarray.device:18
msgid ""
"Device can be used to create reflection of device by string "
"representation of the device type."
msgstr ""

#: of tvm.runtime.module.enabled:6
msgid "target"
msgstr ""

#: of tvm.runtime.module.enabled:6
msgid "The target device type."
msgstr ""

#: of tvm.runtime.module.enabled:11
msgid "enabled"
msgstr ""

#: of tvm.runtime.module.enabled:11
msgid "Whether runtime is enabled."
msgstr ""

#: of tvm.runtime.module.enabled:15
msgid "The following code checks if gpu is enabled."
msgstr ""

#: of tvm.runtime.ndarray.ext_dev:15
msgid ""
"This API is reserved for quick testing of new device by plugin device API"
" as ext_dev."
msgstr ""

#: of tvm.runtime.ndarray.gpu:3
msgid "deprecated:: 0.9.0 Use :py:func:`tvm.cuda` instead."
msgstr ""

#: of tvm.runtime.module.load_module:6
msgid "path"
msgstr ""

#: of tvm.runtime.module.load_module:6
msgid "The path to the module file."
msgstr ""

#: of tvm.runtime.module.load_module:9
msgid ""
"The format of the file, if not specified it will be inferred from suffix "
"of the file."
msgstr ""

#: of tvm.runtime.module.load_module:-1 tvm.runtime.module.system_lib:-1
msgid "runtime.Module"
msgstr ""

#: of tvm.runtime.module.load_module:15
msgid "The loaded module"
msgstr ""

#: of tvm.runtime.module.load_module:19
msgid ""
"This function will automatically call cc.create_shared if the path is in "
"format .o or .tar"
msgstr ""

#: of tvm.runtime.params.load_param_dict:6
#: tvm.runtime.params.save_param_dict:14
msgid "param_bytes: bytearray"
msgstr ""

#: of tvm.runtime.params.load_param_dict:6
#: tvm.runtime.params.save_param_dict:14
msgid "Serialized parameters."
msgstr ""

#: of tvm.runtime.params.load_param_dict:10
#: tvm.runtime.params.load_param_dict_from_file:10
#: tvm.runtime.params.save_param_dict:9
#: tvm.runtime.params.save_param_dict_to_file:6
msgid "params"
msgstr ""

#: of tvm.runtime.params.load_param_dict:-1
#: tvm.runtime.params.load_param_dict_from_file:-1
#: tvm.runtime.params.save_param_dict:-1
#: tvm.runtime.params.save_param_dict_to_file:-1
msgid "dict of str to NDArray"
msgstr ""

#: of tvm.runtime.params.load_param_dict:11
#: tvm.runtime.params.load_param_dict_from_file:11
#: tvm.runtime.params.save_param_dict:9
#: tvm.runtime.params.save_param_dict_to_file:6
msgid "The parameter dictionary."
msgstr ""

#: of tvm.runtime.params.load_param_dict_from_file:6
#: tvm.runtime.params.save_param_dict_to_file:8
msgid "path: str"
msgstr ""

#: of tvm.runtime.params.load_param_dict_from_file:6
msgid "The path to the parameter file to load from."
msgstr ""

#: of tvm.runtime.module.load_static_library:1
msgid ""
"Load the .o library at path which implements functions with func_names. "
"Unlike the generic load_module the result will remain as a static_library"
" and will not be relinked on-the-fly into a .so library."
msgstr ""

#: of tvm.runtime.module.num_threads:6
msgid "Number of threads in use."
msgstr ""

#: of tvm.runtime.params.save_param_dict:3
msgid ""
"The result binary bytes can be loaded by the GraphModule with API "
"\"load_params\"."
msgstr ""

#: of tvm.runtime.params.save_param_dict_to_file:9
msgid "The path to the parameter file."
msgstr ""

#: of tvm.runtime.module.system_lib:3
msgid ""
"System lib is a global module that contains self register functions in "
"startup. Unlike normal dso modules which need to be loaded explicitly. It"
" is useful in environments where dynamic loading api like dlopen is "
"banned."
msgstr ""

#: of tvm.runtime.module.system_lib:7
msgid ""
"To build system lib function, simply specify target option ```llvm "
"--system-lib``` The system lib will be available as long as the result "
"code is linked by the program."
msgstr ""

#: of tvm.runtime.module.system_lib:10
msgid ""
"The system lib is intended to be linked and loaded during the entire "
"life-cyle of the program. If you want dynamic loading features, use dso "
"modules instead."
msgstr ""

#: of tvm.runtime.module.system_lib:17
msgid "symbol_prefix: Optional[str]"
msgstr ""

#: of tvm.runtime.module.system_lib:16
msgid ""
"Optional symbol prefix that can be used for search. When we lookup a "
"symbol symbol_prefix + name will first be searched, then the name without"
" symbol_prefix."
msgstr ""

#: of tvm.runtime.module.system_lib:22
msgid "The system-wide library module."
msgstr ""

#~ msgid ":py:obj:`Object <tvm.runtime.Object>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`PackedFunc <tvm.runtime.PackedFunc>`\\ "
#~ "\\(handle\\, is\\_global\\)"
#~ msgstr ""

#~ msgid ":py:obj:`Report <tvm.runtime.Report>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ":py:obj:`Object <tvm.runtime.Object>`\\"
#~ msgstr ""

#~ msgid ":py:obj:`PackedFunc <tvm.runtime.PackedFunc>`\\"
#~ msgstr ""

#~ msgid ":py:obj:`Report <tvm.runtime.Report>`\\"
#~ msgstr ""

#~ msgid "TVM runtime namespace."
#~ msgstr ""

#~ msgid "**Classes:**"
#~ msgstr ""

#~ msgid ":py:obj:`DataType <tvm.runtime.DataType>`\\ \\(type\\_str\\)"
#~ msgstr ""

#~ msgid "TVM datatype structure"
#~ msgstr ""

#~ msgid ":py:obj:`DataTypeCode <tvm.runtime.DataTypeCode>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "DataType code in DLTensor."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`Device <tvm.runtime.Device>`\\ "
#~ "\\(device\\_type\\, device\\_id\\)"
#~ msgstr ""

#~ msgid "TVM device strucure."
#~ msgstr ""

#~ msgid ":py:obj:`Module <tvm.runtime.Module>`\\ \\(handle\\)"
#~ msgstr ""

#~ msgid "Runtime Module."
#~ msgstr ""

#~ msgid "Base class for all tvm's runtime objects."
#~ msgstr ""

#~ msgid ":py:obj:`ObjectGeneric <tvm.runtime.ObjectGeneric>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Base class for all classes that can be converted to object."
#~ msgstr ""

#~ msgid "The PackedFunc object used in TVM."
#~ msgstr ""

#~ msgid "A container for information gathered during a profiling run."
#~ msgstr ""

#~ msgid ":py:obj:`ShapeTuple <tvm.runtime.ShapeTuple>`\\ \\(shape\\)"
#~ msgstr ""

#~ msgid "TVM runtime ShapeTuple object."
#~ msgstr ""

#~ msgid ":py:obj:`String <tvm.runtime.String>`\\ \\(content\\)"
#~ msgstr ""

#~ msgid "TVM runtime.String object, represented as a python str."
#~ msgstr ""

#~ msgid "**Functions:**"
#~ msgstr ""

#~ msgid ":py:obj:`cl <tvm.runtime.cl>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a OpenCL device"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`const <tvm.runtime.const>`\\ \\(value\\[\\, "
#~ "dtype\\, span\\]\\)"
#~ msgstr ""

#~ msgid "construct a constant"
#~ msgstr ""

#~ msgid ":py:obj:`convert <tvm.runtime.convert>`\\ \\(value\\[\\, span\\]\\)"
#~ msgstr ""

#~ msgid "Convert value to TVM object or function."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`convert_to_object <tvm.runtime.convert_to_object>`\\"
#~ " \\(value\\[\\, span\\]\\)"
#~ msgstr ""

#~ msgid "Convert a Python value to corresponding object type."
#~ msgstr ""

#~ msgid ":py:obj:`cpu <tvm.runtime.cpu>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a CPU device"
#~ msgstr ""

#~ msgid ":py:obj:`cuda <tvm.runtime.cuda>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a CUDA GPU device"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`device <tvm.runtime.device>`\\ "
#~ "\\(dev\\_type\\[\\, dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a TVM device with given device type and id."
#~ msgstr ""

#~ msgid ":py:obj:`enabled <tvm.runtime.enabled>`\\ \\(target\\)"
#~ msgstr ""

#~ msgid "Whether module runtime is enabled for target"
#~ msgstr ""

#~ msgid ":py:obj:`ext_dev <tvm.runtime.ext_dev>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a extension device"
#~ msgstr ""

#~ msgid ":py:obj:`gpu <tvm.runtime.gpu>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`load_module <tvm.runtime.load_module>`\\ "
#~ "\\(path\\[\\, fmt\\]\\)"
#~ msgstr ""

#~ msgid "Load module from file."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`load_param_dict <tvm.runtime.load_param_dict>`\\ "
#~ "\\(param\\_bytes\\)"
#~ msgstr ""

#~ msgid "Load parameter dictionary to binary bytes."
#~ msgstr ""

#~ msgid ":py:obj:`metal <tvm.runtime.metal>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a metal device"
#~ msgstr ""

#~ msgid ":py:obj:`mtl <tvm.runtime.mtl>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid ":py:obj:`opencl <tvm.runtime.opencl>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid ":py:obj:`rocm <tvm.runtime.rocm>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a ROCM device"
#~ msgstr ""

#~ msgid ":py:obj:`save_param_dict <tvm.runtime.save_param_dict>`\\ \\(params\\)"
#~ msgstr ""

#~ msgid "Save parameter dictionary to binary bytes."
#~ msgstr ""

#~ msgid ":py:obj:`system_lib <tvm.runtime.system_lib>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Get system-wide library module singleton."
#~ msgstr ""

#~ msgid ":py:obj:`vpi <tvm.runtime.vpi>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a VPI simulated device"
#~ msgstr ""

#~ msgid ":py:obj:`vulkan <tvm.runtime.vulkan>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a Vulkan device"
#~ msgstr ""

#~ msgid ""
#~ "Typically constructed using convenience "
#~ "function :meth:`tvm.runtime.device`."
#~ msgstr ""

#~ msgid ""
#~ "Exposes uniform interface to device-"
#~ "specific APIs such as CUDA or "
#~ "OpenCL.  Some properties may return None"
#~ " depending on whether an API exposes"
#~ " that particular property."
#~ msgstr ""

#~ msgid "**Attributes:**"
#~ msgstr ""

#~ msgid ":py:obj:`api_version <tvm.runtime.Device.api_version>`\\"
#~ msgstr ""

#~ msgid "Returns version number of the SDK used to compile TVM."
#~ msgstr ""

#~ msgid ":py:obj:`compute_version <tvm.runtime.Device.compute_version>`\\"
#~ msgstr ""

#~ msgid "Get compute version number as string."
#~ msgstr ""

#~ msgid ":py:obj:`device_name <tvm.runtime.Device.device_name>`\\"
#~ msgstr ""

#~ msgid "Return the vendor-specific name of device."
#~ msgstr ""

#~ msgid ":py:obj:`driver_version <tvm.runtime.Device.driver_version>`\\"
#~ msgstr ""

#~ msgid "Returns version number of the driver"
#~ msgstr ""

#~ msgid ":py:obj:`exist <tvm.runtime.Device.exist>`\\"
#~ msgstr ""

#~ msgid "Whether this device exists."
#~ msgstr ""

#~ msgid ":py:obj:`max_clock_rate <tvm.runtime.Device.max_clock_rate>`\\"
#~ msgstr ""

#~ msgid "Return the max clock frequency of device (kHz)."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`max_shared_memory_per_block "
#~ "<tvm.runtime.Device.max_shared_memory_per_block>`\\"
#~ msgstr ""

#~ msgid "Total amount of shared memory per block in bytes."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`max_thread_dimensions "
#~ "<tvm.runtime.Device.max_thread_dimensions>`\\"
#~ msgstr ""

#~ msgid "Return the maximum size of each thread axis"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`max_threads_per_block "
#~ "<tvm.runtime.Device.max_threads_per_block>`\\"
#~ msgstr ""

#~ msgid "Maximum number of threads on each block."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`multi_processor_count "
#~ "<tvm.runtime.Device.multi_processor_count>`\\"
#~ msgstr ""

#~ msgid "Return the number of compute units in the device."
#~ msgstr ""

#~ msgid ":py:obj:`warp_size <tvm.runtime.Device.warp_size>`\\"
#~ msgstr ""

#~ msgid "Number of threads that execute concurrently."
#~ msgstr ""

#~ msgid "**Methods:**"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`create_raw_stream "
#~ "<tvm.runtime.Device.create_raw_stream>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Create a new runtime stream at the context."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`free_raw_stream <tvm.runtime.Device.free_raw_stream>`\\"
#~ " \\(stream\\)"
#~ msgstr ""

#~ msgid "Free a created stream handle."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`set_raw_stream <tvm.runtime.Device.set_raw_stream>`\\"
#~ " \\(stream\\)"
#~ msgstr ""

#~ msgid "Set a created stream handle."
#~ msgstr ""

#~ msgid ":py:obj:`sync <tvm.runtime.Device.sync>`\\ \\(\\[stream\\]\\)"
#~ msgstr ""

#~ msgid "Synchronize until jobs finished at the context."
#~ msgstr ""

#~ msgid "For example, CUDA_VERSION for cuda or VK_HEADER_VERSION for Vulkan."
#~ msgstr ""

#~ msgid ""
#~ "Returns device value for cuda, rocm, "
#~ "opencl, and vulkan. Returns remote "
#~ "device value for RPC devices.  Returns"
#~ " None for all other devices."
#~ msgstr ""

#~ msgid "返回"
#~ msgstr ""

#~ msgid "**version** -- The version of the SDK"
#~ msgstr ""

#~ msgid "返回类型"
#~ msgstr ""

#~ msgid ""
#~ "Returns maximum API version (e.g. "
#~ "CUDA/OpenCL/Vulkan) supported by the device."
#~ msgstr ""

#~ msgid "**version** -- The version string in `major.minor` format."
#~ msgstr ""

#~ msgid "User should free the stream after use."
#~ msgstr ""

#~ msgid "**stream** -- The created runtime stream."
#~ msgstr ""

#~ msgid "**device_name** -- The name of the device."
#~ msgstr ""

#~ msgid ""
#~ "Returns driver vendor's internal version "
#~ "number. (e.g. \"450.408.256\" for nvidia-"
#~ "driver-450)"
#~ msgstr ""

#~ msgid ""
#~ "Returns device value for opencl and "
#~ "vulkan.  Returns remote device value for"
#~ " RPC devices.  Returns None for all"
#~ " other devices."
#~ msgstr ""

#~ msgid "**version** -- The version string in `major.minor.patch` format."
#~ msgstr ""

#~ msgid ""
#~ "Returns True if TVM has support "
#~ "for the device, if the physical "
#~ "device is present, and the device "
#~ "is accessible through appropriate drivers "
#~ "(e.g. cuda/vulkan)."
#~ msgstr ""

#~ msgid "**exist** -- True if the device exists"
#~ msgstr ""

#~ msgid "参数"
#~ msgstr ""

#~ msgid "The stream which should to be released."
#~ msgstr ""

#~ msgid ""
#~ "Returns device value for cuda, rocm, "
#~ "and opencl.  Returns remote device value"
#~ " for RPC devices.  Returns None for"
#~ " all other devices."
#~ msgstr ""

#~ msgid "**max_clock_rate** -- The maximum clock frequency of the device (kHz)"
#~ msgstr ""

#~ msgid ""
#~ "**max_shared_memory_per_block** -- Total amount "
#~ "of shared memory per block in "
#~ "bytes"
#~ msgstr ""

#~ msgid "**dims** -- The maximum length of threadIdx.x, threadIdx.y, threadIdx.z"
#~ msgstr ""

#~ msgid ""
#~ "Returns device value for cuda, metal,"
#~ " rocm, opencl, and vulkan devices.  "
#~ "Returns remote device value for RPC "
#~ "devices. Returns None for all other "
#~ "devices."
#~ msgstr ""

#~ msgid "**max_threads_per_block** -- The number of threads on each block"
#~ msgstr ""

#~ msgid "**multi_processor_count** -- Thee number of compute units in the device"
#~ msgstr ""

#~ msgid "The stream which should to be set to the device."
#~ msgstr ""

#~ msgid "Jobs in this stream should be finished."
#~ msgstr ""

#~ msgid ""
#~ "Returns device value for for cuda, "
#~ "rocm, and vulkan.  Returns 1 for "
#~ "metal and opencl devices, regardless of"
#~ " the physical device.  Returns remote "
#~ "device value for RPC devices.  Returns"
#~ " None for all other devices."
#~ msgstr ""

#~ msgid "**warp_size** -- Number of threads that execute concurrently"
#~ msgstr ""

#~ msgid ":py:obj:`entry_func <tvm.runtime.Module.entry_func>`\\"
#~ msgstr ""

#~ msgid "Get the entry function"
#~ msgstr ""

#~ msgid ":py:obj:`format <tvm.runtime.Module.format>`\\"
#~ msgstr ""

#~ msgid "Get the format of the module."
#~ msgstr ""

#~ msgid ":py:obj:`imported_modules <tvm.runtime.Module.imported_modules>`\\"
#~ msgstr ""

#~ msgid "Get imported modules"
#~ msgstr ""

#~ msgid ":py:obj:`type_key <tvm.runtime.Module.type_key>`\\"
#~ msgstr ""

#~ msgid "Get type key of the module."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`export_library <tvm.runtime.Module.export_library>`\\"
#~ " \\(file\\_name\\[\\, fcompile\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ "Export the module and all imported "
#~ "modules into a single device library."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`get_function <tvm.runtime.Module.get_function>`\\ "
#~ "\\(name\\[\\, query\\_imports\\]\\)"
#~ msgstr ""

#~ msgid "Get function from the module."
#~ msgstr ""

#~ msgid ":py:obj:`get_source <tvm.runtime.Module.get_source>`\\ \\(\\[fmt\\]\\)"
#~ msgstr ""

#~ msgid "Get source code from module, if available."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`import_module <tvm.runtime.Module.import_module>`\\ "
#~ "\\(module\\)"
#~ msgstr ""

#~ msgid "Add module to the import list of current one."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`save <tvm.runtime.Module.save>`\\ "
#~ "\\(file\\_name\\[\\, fmt\\]\\)"
#~ msgstr ""

#~ msgid "Save the module to file."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`time_evaluator <tvm.runtime.Module.time_evaluator>`\\"
#~ " \\(func\\_name\\, dev\\[\\, number\\, ...\\]\\)"
#~ msgstr ""

#~ msgid "Get an evaluator that measures time cost of running function."
#~ msgstr ""

#~ msgid "**f** -- The entry function if exist"
#~ msgstr ""

#~ msgid ""
#~ "This function only works on host "
#~ "LLVM modules, other runtime::Module subclasses"
#~ " will work with this API but "
#~ "they must support implement the save "
#~ "and load mechanisms of modules "
#~ "completely including saving from streams "
#~ "and files. This will pack your "
#~ "non-shared library module into a "
#~ "single shared library which can later"
#~ " be loaded by TVM."
#~ msgstr ""

#~ msgid "The name of the shared library."
#~ msgstr ""

#~ msgid ""
#~ "The compilation function to use create"
#~ " the final library object during "
#~ "export.  For example, when "
#~ "fcompile=_cc.create_shared, or when it is "
#~ "not supplied but module is \"llvm,\" "
#~ "this is used to link all produced"
#~ " artifacts into a final dynamic "
#~ "library.  This behavior is controlled by"
#~ " the type of object exported. If "
#~ "fcompile has attribute object_format, will "
#~ "compile host library to that format. "
#~ "Otherwise, will use default format "
#~ "\"o\"."
#~ msgstr ""

#~ msgid ""
#~ "The compilation function to use create"
#~ " the final library object during "
#~ "export."
#~ msgstr ""

#~ msgid ""
#~ "For example, when fcompile=_cc.create_shared, "
#~ "or when it is not supplied but "
#~ "module is \"llvm,\" this is used "
#~ "to link all produced artifacts into "
#~ "a final dynamic library."
#~ msgstr ""

#~ msgid ""
#~ "This behavior is controlled by the "
#~ "type of object exported. If fcompile "
#~ "has attribute object_format, will compile "
#~ "host library to that format. Otherwise,"
#~ " will use default format \"o\"."
#~ msgstr ""

#~ msgid ""
#~ "The path of the directory used to"
#~ " create the intermediate artifacts when "
#~ "exporting the module. If this is "
#~ "not provided a temporary dir will "
#~ "be created."
#~ msgstr ""

#~ msgid "Additional arguments passed to fcompile"
#~ msgstr ""

#~ msgid ""
#~ "**result of fcompile()** -- If the "
#~ "compilation function returns an artifact "
#~ "it would be returned via export_library,"
#~ " if any."
#~ msgstr ""

#~ msgid "The name of the function"
#~ msgstr ""

#~ msgid "Whether also query modules imported by this module."
#~ msgstr ""

#~ msgid "**f** -- The result function."
#~ msgstr ""

#~ msgid "The specified format."
#~ msgstr ""

#~ msgid "**source** -- The result source code."
#~ msgstr ""

#~ msgid "The other module."
#~ msgstr ""

#~ msgid "**modules** -- The module"
#~ msgstr ""

#~ msgid "This do not save the dependent device modules. See also export_shared"
#~ msgstr ""

#~ msgid "The name of the file."
#~ msgstr ""

#~ msgid "The format of the file."
#~ msgstr ""

#~ msgid ":obj:`runtime.Module.export_library`"
#~ msgstr ""

#~ msgid "export the module to shared library."
#~ msgstr ""

#~ msgid "The name of the function in the module."
#~ msgstr ""

#~ msgid "The device we should run this function on."
#~ msgstr ""

#~ msgid ""
#~ "The number of times to run this"
#~ " function for taking average. We call"
#~ " these runs as one `repeat` of "
#~ "measurement."
#~ msgstr ""

#~ msgid ""
#~ "The number of times to repeat the"
#~ " measurement. In total, the function "
#~ "will be invoked (1 + number x "
#~ "repeat) times, where the first one "
#~ "is warm up and will be discarded."
#~ " The returned result contains `repeat` "
#~ "costs, each of which is an average"
#~ " of `number` costs."
#~ msgstr ""

#~ msgid ""
#~ "The minimum duration of one `repeat` "
#~ "in milliseconds. By default, one "
#~ "`repeat` contains `number` runs. If this"
#~ " parameter is set, the parameters "
#~ "`number` will be dynamically adjusted to"
#~ " meet the minimum duration requirement "
#~ "of one `repeat`. i.e., When the "
#~ "run time of one `repeat` falls "
#~ "below this time, the `number` parameter"
#~ " will be automatically increased."
#~ msgstr ""

#~ msgid ""
#~ "The preprocess function name we want "
#~ "to execute before executing the time "
#~ "evaluator."
#~ msgstr ""

#~ msgid ""
#~ "The function will be invoked  (1 +"
#~ " number x repeat) times, with the "
#~ "first call discarded in case there "
#~ "is lazy initialization."
#~ msgstr ""

#~ msgid ""
#~ "**ftimer** -- The function that takes"
#~ " same argument as func and returns"
#~ " a BenchmarkResult. The ProfileResult "
#~ "reports `repeat` time costs in seconds."
#~ msgstr ""

#~ msgid ":py:obj:`asobject <tvm.runtime.ObjectGeneric.asobject>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Convert value to object"
#~ msgstr ""

#~ msgid ""
#~ "Function plays an key role to "
#~ "bridge front and backend in TVM. "
#~ "Function provide a type-erased "
#~ "interface, you can call function with"
#~ " positional arguments."
#~ msgstr ""

#~ msgid ""
#~ "The compiled module returns Function. "
#~ "TVM backend also registers and exposes"
#~ " its API as Functions."
#~ msgstr ""

#~ msgid ""
#~ "The following are list of common "
#~ "usage scenario of tvm.runtime.PackedFunc."
#~ msgstr ""

#~ msgid "Automatic exposure of C++ API into python"
#~ msgstr ""

#~ msgid "To call PackedFunc from python side"
#~ msgstr ""

#~ msgid "To call python callbacks to inspect results in generated code"
#~ msgstr ""

#~ msgid "Bring python hook into C++ backend"
#~ msgstr ""

#~ msgid ":obj:`tvm.register_func`"
#~ msgstr ""

#~ msgid "How to register global function."
#~ msgstr ""

#~ msgid ":obj:`tvm.get_global_func`"
#~ msgstr ""

#~ msgid "How to get global function."
#~ msgstr ""

#~ msgid "Per-call profiling metrics (function name, runtime, device, ...)."
#~ msgstr ""

#~ msgid "type"
#~ msgstr ""

#~ msgid "Array[Dict[str, Object]]"
#~ msgstr ""

#~ msgid "Per-device metrics collected over the entire run."
#~ msgstr ""

#~ msgid "Dict[Device, Dict[str, Object]]"
#~ msgstr ""

#~ msgid ":py:obj:`csv <tvm.runtime.Report.csv>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Convert this profiling report into CSV format."
#~ msgstr ""

#~ msgid ":py:obj:`from_json <tvm.runtime.Report.from_json>`\\ \\(s\\)"
#~ msgstr ""

#~ msgid "Deserialize a report from JSON."
#~ msgstr ""

#~ msgid ":py:obj:`json <tvm.runtime.Report.json>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Convert this profiling report into JSON format."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`table <tvm.runtime.Report.table>`\\ \\(\\[sort\\,"
#~ " aggregate\\, col\\_sums\\]\\)"
#~ msgstr ""

#~ msgid "Generate a human-readable table"
#~ msgstr ""

#~ msgid "This only includes calls and not overall metrics."
#~ msgstr ""

#~ msgid "**csv** -- `calls` in CSV format."
#~ msgstr ""

#~ msgid "Report serialize via :py:meth:`json`."
#~ msgstr ""

#~ msgid "**report** -- The deserialized report."
#~ msgstr ""

#~ msgid "Example output:"
#~ msgstr ""

#~ msgid "**json** -- Formatted JSON"
#~ msgstr ""

#~ msgid ""
#~ "If aggregate is true, whether to "
#~ "sort call frames by descending duration."
#~ "  If aggregate is False, whether to"
#~ " sort frames by order of appearancei"
#~ " n the program."
#~ msgstr ""

#~ msgid "Whether to join multiple calls to the same op into a single line."
#~ msgstr ""

#~ msgid "Whether to include the sum of each column."
#~ msgstr ""

#~ msgid "**table** -- A human-readable table"
#~ msgstr ""

#~ msgid ""
#~ "TVM runtime ShapeTuple object. :param "
#~ "shape: The shape list used to "
#~ "construct the object. :type shape: "
#~ "list[int]"
#~ msgstr ""

#~ msgid "The content string used to construct the object."
#~ msgstr ""

#~ msgid "The integer device id"
#~ msgstr ""

#~ msgid "**dev** -- The created device"
#~ msgstr ""

#~ msgid "The content of the constant number."
#~ msgstr ""

#~ msgid "The data type."
#~ msgstr ""

#~ msgid "The location of the constant value in the source."
#~ msgstr ""

#~ msgid "**const_val** -- The result expression."
#~ msgstr ""

#~ msgid "The location of this statement in the source code."
#~ msgstr ""

#~ msgid "**tvm_val** -- Converted value in TVM"
#~ msgstr ""

#~ msgid "The value to be inspected."
#~ msgstr ""

#~ msgid "The location of this itervar in the source code."
#~ msgstr ""

#~ msgid "**obj** -- The corresponding object value."
#~ msgstr ""

#~ msgid "The device type mask or name of the device."
#~ msgstr ""

#~ msgid "**dev** -- The corresponding device."
#~ msgstr ""

#~ msgid "实际案例"
#~ msgstr ""

#~ msgid ""
#~ "Device can be used to create "
#~ "reflection of device by string "
#~ "representation of the device type."
#~ msgstr ""

#~ msgid "The target device type."
#~ msgstr ""

#~ msgid "**enabled** -- Whether runtime is enabled."
#~ msgstr ""

#~ msgid "The following code checks if gpu is enabled."
#~ msgstr ""

#~ msgid ""
#~ "This API is reserved for quick "
#~ "testing of new device by plugin "
#~ "device API as ext_dev."
#~ msgstr ""

#~ msgid "deprecated:: 0.9.0 Use :py:func:`tvm.cuda` instead."
#~ msgstr ""

#~ msgid "The path to the module file."
#~ msgstr ""

#~ msgid ""
#~ "The format of the file, if not "
#~ "specified it will be inferred from "
#~ "suffix of the file."
#~ msgstr ""

#~ msgid "**module** -- The loaded module"
#~ msgstr ""

#~ msgid ""
#~ "This function will automatically call "
#~ "cc.create_shared if the path is in "
#~ "format .o or .tar"
#~ msgstr ""

#~ msgid "Serialized parameters."
#~ msgstr ""

#~ msgid "**params** -- The parameter dictionary."
#~ msgstr ""

#~ msgid ""
#~ "The result binary bytes can be "
#~ "loaded by the GraphModule with API "
#~ "\"load_params\"."
#~ msgstr ""

#~ msgid "The parameter dictionary."
#~ msgstr ""

#~ msgid "**param_bytes** -- Serialized parameters."
#~ msgstr ""

#~ msgid ""
#~ "System lib is a global module that"
#~ " contains self register functions in "
#~ "startup. Unlike normal dso modules which"
#~ " need to be loaded explicitly. It "
#~ "is useful in environments where dynamic"
#~ " loading api like dlopen is banned."
#~ msgstr ""

#~ msgid ""
#~ "To build system lib function, simply "
#~ "specify target option ```llvm --system-"
#~ "lib``` The system lib will be "
#~ "available as long as the result "
#~ "code is linked by the program."
#~ msgstr ""

#~ msgid ""
#~ "The system lib is intended to be"
#~ " linked and loaded during the entire"
#~ " life-cyle of the program. If "
#~ "you want dynamic loading features, use"
#~ " dso modules instead."
#~ msgstr ""

#~ msgid "**module** -- The system-wide library module."
#~ msgstr ""

#~ msgid ":py:obj:`ObjectPath <tvm.runtime.ObjectPath>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Path to an object from some root object."
#~ msgstr ""

#~ msgid ":py:obj:`ObjectPathPair <tvm.runtime.ObjectPathPair>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ""
#~ "Pair of ObjectPaths, one for each "
#~ "object being tested for structural "
#~ "equality."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`Report <tvm.runtime.Report>`\\ \\(calls\\, "
#~ "device\\_metrics\\, configuration\\)"
#~ msgstr ""

#~ msgid ":py:obj:`Scriptable <tvm.runtime.Scriptable>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "A base class that enables the script() and show() method."
#~ msgstr ""

#~ msgid ""
#~ "TVM runtime ShapeTuple object. Parameters "
#~ "---------- shape : list[int]     The "
#~ "shape list used to construct the "
#~ "object."
#~ msgstr ""

#~ msgid "Load parameter dictionary from binary bytes."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`load_param_dict_from_file "
#~ "<tvm.runtime.load_param_dict_from_file>`\\ \\(path\\)"
#~ msgstr ""

#~ msgid "Load parameter dictionary from file."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`load_static_library "
#~ "<tvm.runtime.load_static_library>`\\ \\(path\\, "
#~ "func\\_names\\)"
#~ msgstr ""

#~ msgid "Load the .o library at path which implements functions with func_names."
#~ msgstr ""

#~ msgid ":py:obj:`num_threads <tvm.runtime.num_threads>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Get the number of threads in use by the TVM runtime."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`save_param_dict_to_file "
#~ "<tvm.runtime.save_param_dict_to_file>`\\ \\(params\\, "
#~ "path\\)"
#~ msgstr ""

#~ msgid "Save parameter dictionary to file."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`system_lib <tvm.runtime.system_lib>`\\ "
#~ "\\(\\[symbol\\_prefix\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ "NOTE!  The integer values in MASK2STR"
#~ " and STR2MASK *must* correspond to "
#~ "the values provided by the DLDeviceType"
#~ " and TVMDeviceExtType enums."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`_GetDeviceAttr <tvm.runtime.Device._GetDeviceAttr>`\\"
#~ " \\(device\\_type\\, device\\_id\\, attr\\_id\\)"
#~ msgstr ""

#~ msgid "Internal helper function to invoke runtime.GetDeviceAttr"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`texture_spatial_limit "
#~ "<tvm.runtime.Device.texture_spatial_limit>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Returns limits for textures by spatial dimensions"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`l2_cache_size_bytes "
#~ "<tvm.runtime.Device.l2_cache_size_bytes>`\\"
#~ msgstr ""

#~ msgid "Return the size of the device L2 cache in bytes"
#~ msgstr ""

#~ msgid "Returns"
#~ msgstr ""

#~ msgid "version"
#~ msgstr ""

#~ msgid "int or None"
#~ msgstr ""

#~ msgid "The version of the SDK"
#~ msgstr ""

#~ msgid "str or None"
#~ msgstr ""

#~ msgid "The version string in `major.minor` format."
#~ msgstr ""

#~ msgid "stream"
#~ msgstr ""

#~ msgid "TVMStreamHandle"
#~ msgstr ""

#~ msgid "The created runtime stream."
#~ msgstr ""

#~ msgid "device_name"
#~ msgstr ""

#~ msgid "The name of the device."
#~ msgstr ""

#~ msgid "The version string in `major.minor.patch` format."
#~ msgstr ""

#~ msgid "exist"
#~ msgstr ""

#~ msgid "bool"
#~ msgstr ""

#~ msgid "True if the device exists"
#~ msgstr ""

#~ msgid "Parameters"
#~ msgstr ""

#~ msgid "Supported devices include CUDA/ROCM/OpenCL."
#~ msgstr ""

#~ msgid "l2_cache_size_bytes"
#~ msgstr ""

#~ msgid ""
#~ "The size of the device L2 cache"
#~ " in bytes returned by device runtime"
#~ " API. Return None if the device "
#~ "does not support this feature."
#~ msgstr ""

#~ msgid "Note"
#~ msgstr ""

#~ msgid ""
#~ "The value returned by opencl's API "
#~ "is smaller than actual device L2 "
#~ "cache size."
#~ msgstr ""

#~ msgid "max_clock_rate"
#~ msgstr ""

#~ msgid "The maximum clock frequency of the device (kHz)"
#~ msgstr ""

#~ msgid "max_shared_memory_per_block"
#~ msgstr ""

#~ msgid "Total amount of shared memory per block in bytes"
#~ msgstr ""

#~ msgid "dims: List of int, or None"
#~ msgstr ""

#~ msgid "The maximum length of threadIdx.x, threadIdx.y, threadIdx.z"
#~ msgstr ""

#~ msgid "max_threads_per_block"
#~ msgstr ""

#~ msgid "The number of threads on each block"
#~ msgstr ""

#~ msgid "multi_processor_count"
#~ msgstr ""

#~ msgid "Thee number of compute units in the device"
#~ msgstr ""

#~ msgid "limit"
#~ msgstr ""

#~ msgid "Maximum size of the texture by spatial dimensions"
#~ msgstr ""

#~ msgid ""
#~ "Returns device value for cuda, rocm, "
#~ "and vulkan.  Returns 1 for metal "
#~ "and opencl devices, regardless of the"
#~ " physical device.  Returns remote device"
#~ " value for RPC devices.  Returns None"
#~ " for all other devices."
#~ msgstr ""

#~ msgid "warp_size"
#~ msgstr ""

#~ msgid "Number of threads that execute concurrently"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`_collect_from_import_tree "
#~ "<tvm.runtime.Module._collect_from_import_tree>`\\ "
#~ "\\(filter\\_func\\)"
#~ msgstr ""

#~ msgid ""
#~ "Helper function to collect modules from"
#~ " the tree matching a filter_func, "
#~ "then return it."
#~ msgstr ""

#~ msgid ":py:obj:`clear_imports <tvm.runtime.Module.clear_imports>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Remove all imports of the module."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`export_library <tvm.runtime.Module.export_library>`\\"
#~ " \\(file\\_name\\, \\*\\[\\, fcompile\\, "
#~ "...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`get_property_mask "
#~ "<tvm.runtime.Module.get_property_mask>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Get the runtime module property mask."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`implements_function "
#~ "<tvm.runtime.Module.implements_function>`\\ \\(name\\[\\, "
#~ "query\\_imports\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ "Returns True if the module has a"
#~ " definition for the global function "
#~ "with name."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`is_binary_serializable "
#~ "<tvm.runtime.Module.is_binary_serializable>`\\"
#~ msgstr ""

#~ msgid ""
#~ "Returns true if module is 'binary "
#~ "serializable', ie can be serialzed into"
#~ " binary"
#~ msgstr ""

#~ msgid ":py:obj:`is_dso_exportable <tvm.runtime.Module.is_dso_exportable>`\\"
#~ msgstr ""

#~ msgid ""
#~ "Returns true if module is 'DSO "
#~ "exportable', ie can be included in "
#~ "result of export_library by the external"
#~ " compiler directly."
#~ msgstr ""

#~ msgid ":py:obj:`is_runnable <tvm.runtime.Module.is_runnable>`\\"
#~ msgstr ""

#~ msgid "Returns true if module is 'runnable'."
#~ msgstr ""

#~ msgid "filter_func"
#~ msgstr ""

#~ msgid "Callable[[Module], bool]"
#~ msgstr ""

#~ msgid ""
#~ "A function which is invoked for "
#~ "each Module discovered in the import "
#~ "tree (including self)."
#~ msgstr ""

#~ msgid "list[Module] :"
#~ msgstr ""

#~ msgid "A list of matching Module."
#~ msgstr ""

#~ msgid "f"
#~ msgstr ""

#~ msgid "tvm.runtime.PackedFunc"
#~ msgstr ""

#~ msgid "The entry function if exist"
#~ msgstr ""

#~ msgid "file_name"
#~ msgstr ""

#~ msgid "str"
#~ msgstr ""

#~ msgid "fcompile"
#~ msgstr ""

#~ msgid "function(target, file_list, kwargs), optional"
#~ msgstr ""

#~ msgid ""
#~ "fpack_imports: function(mod: runtime.Module, "
#~ "is_system_lib: bool, symbol_prefix: str,"
#~ msgstr ""

#~ msgid "workspace_dir: str) -> str"
#~ msgstr ""

#~ msgid ""
#~ "Function used to pack imported modules"
#~ " from `mod` into a file suitable "
#~ "for passing to fcompile as an "
#~ "input file. The result can be a"
#~ " C source, or an .o object "
#~ "file, or any other file that the"
#~ " fcompile function can handle. The "
#~ "function returns the name of the "
#~ "created file."
#~ msgstr ""

#~ msgid ""
#~ "If not provided, the imported modules"
#~ " will be serialized either via "
#~ "packing to an LLVM module, or to"
#~ " a C source file."
#~ msgstr ""

#~ msgid "workspace_dir"
#~ msgstr ""

#~ msgid "str, optional"
#~ msgstr ""

#~ msgid "kwargs"
#~ msgstr ""

#~ msgid "dict, optional"
#~ msgstr ""

#~ msgid "result of fcompile()"
#~ msgstr ""

#~ msgid "unknown, optional"
#~ msgstr ""

#~ msgid ""
#~ "If the compilation function returns an"
#~ " artifact it would be returned via"
#~ " export_library, if any."
#~ msgstr ""

#~ msgid "name"
#~ msgstr ""

#~ msgid "query_imports"
#~ msgstr ""

#~ msgid "The result function."
#~ msgstr ""

#~ msgid ""
#~ "Get the runtime module property mask."
#~ " The mapping is stated in "
#~ "ModulePropertyMask."
#~ msgstr ""

#~ msgid "mask"
#~ msgstr ""

#~ msgid "int"
#~ msgstr ""

#~ msgid "Bitmask of runtime module property"
#~ msgstr ""

#~ msgid "fmt"
#~ msgstr ""

#~ msgid "source"
#~ msgstr ""

#~ msgid "The result source code."
#~ msgstr ""

#~ msgid ""
#~ "Returns True if the module has a"
#~ " definition for the global function "
#~ "with name. Note that has_function(name) "
#~ "does not imply get_function(name) is "
#~ "non-null since the module may be, "
#~ "eg, a CSourceModule which cannot supply"
#~ " a packed-func implementation of the"
#~ " function without further compilation. "
#~ "However, get_function(name) non null should"
#~ " always imply has_function(name)."
#~ msgstr ""

#~ msgid "Whether to also query modules imported by this module."
#~ msgstr ""

#~ msgid "b"
#~ msgstr ""

#~ msgid "Bool"
#~ msgstr ""

#~ msgid "True if module (or one of its imports) has a definition for name."
#~ msgstr ""

#~ msgid "module"
#~ msgstr ""

#~ msgid "tvm.runtime.Module"
#~ msgstr ""

#~ msgid "modules"
#~ msgstr ""

#~ msgid "list of Module"
#~ msgstr ""

#~ msgid "The module"
#~ msgstr ""

#~ msgid "stream and loaded back to the runtime module."
#~ msgstr ""

#~ msgid "True if the module is binary serializable."
#~ msgstr ""

#~ msgid "True if the module is DSO exportable."
#~ msgstr ""

#~ msgid ""
#~ "Returns true if module is 'runnable'."
#~ " ie can be executed without any "
#~ "extra compilation/linking steps."
#~ msgstr ""

#~ msgid "True if the module is runnable."
#~ msgstr ""

#~ msgid "See Also"
#~ msgstr ""

#~ msgid "runtime.Module.export_library : export the module to shared library."
#~ msgstr ""

#~ msgid "func_name: str"
#~ msgstr ""

#~ msgid "dev: Device"
#~ msgstr ""

#~ msgid "number: int"
#~ msgstr ""

#~ msgid "repeat: int, optional"
#~ msgstr ""

#~ msgid "min_repeat_ms: int, optional"
#~ msgstr ""

#~ msgid "limit_zero_time_iterations: int, optional"
#~ msgstr ""

#~ msgid ""
#~ "The maximum number of repeats when "
#~ "measured time is equal to 0. It"
#~ " helps to avoid hanging during "
#~ "measurements."
#~ msgstr ""

#~ msgid "cooldown_interval_ms: int, optional"
#~ msgstr ""

#~ msgid ""
#~ "The cooldown interval in milliseconds "
#~ "between the number of repeats defined"
#~ " by `repeats_to_cooldown`."
#~ msgstr ""

#~ msgid "repeats_to_cooldown: int, optional"
#~ msgstr ""

#~ msgid "The number of repeats before the cooldown is activated."
#~ msgstr ""

#~ msgid "cache_flush_bytes: int, optional"
#~ msgstr ""

#~ msgid "The number of bytes to flush from the cache before each repeat."
#~ msgstr ""

#~ msgid "f_preproc: str, optional"
#~ msgstr ""

#~ msgid "ftimer"
#~ msgstr ""

#~ msgid "function"
#~ msgstr ""

#~ msgid ""
#~ "The function that takes same argument"
#~ " as func and returns a "
#~ "BenchmarkResult. The ProfileResult reports "
#~ "`repeat` time costs in seconds."
#~ msgstr ""

#~ msgid ":py:obj:`_move <tvm.runtime.Object._move>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Create an RValue reference to the object and mark the object as moved."
#~ msgstr ""

#~ msgid ""
#~ "This is a advanced developer API "
#~ "that can be useful when passing an"
#~ " unique reference to an Object that"
#~ " you no longer needed to a "
#~ "function."
#~ msgstr ""

#~ msgid ""
#~ "A unique reference can trigger copy "
#~ "on write optimization that avoids copy"
#~ " when we transform an object."
#~ msgstr ""

#~ msgid ""
#~ "All the reference of the object "
#~ "becomes invalid after it is moved. "
#~ "Be very careful when using this "
#~ "feature."
#~ msgstr ""

#~ msgid "Examples"
#~ msgstr ""

#~ msgid "rvalue : The rvalue reference."
#~ msgstr ""

#~ msgid ""
#~ "tvm.register_func: How to register global "
#~ "function. tvm.get_global_func: How to get "
#~ "global function."
#~ msgstr ""

#~ msgid "Attributes"
#~ msgstr ""

#~ msgid "calls"
#~ msgstr ""

#~ msgid "device_metrics"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`__init__ <tvm.runtime.Report.__init__>`\\ "
#~ "\\(calls\\, device\\_metrics\\, configuration\\)"
#~ msgstr ""

#~ msgid ""
#~ "Construct a profiling report from a "
#~ "list of metrics and per-device "
#~ "metrics."
#~ msgstr ""

#~ msgid "Sequence[Dict[str, Object]]"
#~ msgstr ""

#~ msgid "Per function call metrics."
#~ msgstr ""

#~ msgid "Dict[str, Dict[str, Object]]"
#~ msgstr ""

#~ msgid "Per device metrics."
#~ msgstr ""

#~ msgid "configuration"
#~ msgstr ""

#~ msgid "Dict[str, Object]"
#~ msgstr ""

#~ msgid ""
#~ "Configuration of TVM for this profiling"
#~ " run. Includes number of threads, "
#~ "executor."
#~ msgstr ""

#~ msgid "csv"
#~ msgstr ""

#~ msgid "`calls` in CSV format."
#~ msgstr ""

#~ msgid "s"
#~ msgstr ""

#~ msgid "report"
#~ msgstr ""

#~ msgid "Report"
#~ msgstr ""

#~ msgid "The deserialized report."
#~ msgstr ""

#~ msgid "json"
#~ msgstr ""

#~ msgid "Formatted JSON"
#~ msgstr ""

#~ msgid "sort : bool"
#~ msgstr ""

#~ msgid "aggregate : bool"
#~ msgstr ""

#~ msgid "col_sums : bool"
#~ msgstr ""

#~ msgid "table : str"
#~ msgstr ""

#~ msgid "A human-readable table"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`script <tvm.runtime.Scriptable.script>`\\ "
#~ "\\(\\*\\[\\, name\\, show\\_meta\\, ir\\_prefix\\,"
#~ " ...\\]\\)"
#~ msgstr ""

#~ msgid "Print TVM IR into TVMScript text format"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`show <tvm.runtime.Scriptable.show>`\\ "
#~ "\\(\\[style\\, black\\_format\\, name\\, "
#~ "show\\_meta\\, ...\\]\\)"
#~ msgstr ""

#~ msgid "A sugar for print highlighted TVM script."
#~ msgstr ""

#~ msgid "Optional[str] = None"
#~ msgstr ""

#~ msgid "The name of the object"
#~ msgstr ""

#~ msgid "show_meta"
#~ msgstr ""

#~ msgid "bool = False"
#~ msgstr ""

#~ msgid "Whether to print the meta data of the object"
#~ msgstr ""

#~ msgid "ir_prefix"
#~ msgstr ""

#~ msgid "str = \"I\""
#~ msgstr ""

#~ msgid "The prefix of AST nodes from tvm.ir"
#~ msgstr ""

#~ msgid "tir_prefix"
#~ msgstr ""

#~ msgid "str = \"T\""
#~ msgstr ""

#~ msgid "The prefix of AST nodes from tvm.tir"
#~ msgstr ""

#~ msgid "relax_prefix"
#~ msgstr ""

#~ msgid "str = \"R\""
#~ msgstr ""

#~ msgid "The prefix of AST nodes from tvm.relax"
#~ msgstr ""

#~ msgid "module_alias"
#~ msgstr ""

#~ msgid "str = \"cls\""
#~ msgstr ""

#~ msgid ""
#~ "The alias of the current module at"
#~ " cross-function call, Directly use "
#~ "module name if it's empty."
#~ msgstr ""

#~ msgid "buffer_dtype"
#~ msgstr ""

#~ msgid "str = \"float32\""
#~ msgstr ""

#~ msgid "The default data type of buffer"
#~ msgstr ""

#~ msgid "int_dtype"
#~ msgstr ""

#~ msgid "str = \"int32\""
#~ msgstr ""

#~ msgid "The default data type of integer"
#~ msgstr ""

#~ msgid "float_dtype"
#~ msgstr ""

#~ msgid "str = \"void\""
#~ msgstr ""

#~ msgid "The default data type of float"
#~ msgstr ""

#~ msgid "verbose_expr"
#~ msgstr ""

#~ msgid ""
#~ "Whether to print the detailed definition"
#~ " of each variable in the expression"
#~ msgstr ""

#~ msgid "indent_spaces"
#~ msgstr ""

#~ msgid "int = 4"
#~ msgstr ""

#~ msgid "The number of spaces for indentation"
#~ msgstr ""

#~ msgid "print_line_numbers"
#~ msgstr ""

#~ msgid "Whether to print line numbers"
#~ msgstr ""

#~ msgid "num_context_lines"
#~ msgstr ""

#~ msgid "int = -1"
#~ msgstr ""

#~ msgid ""
#~ "The number of lines of context to"
#~ " print before and after the line "
#~ "to underline."
#~ msgstr ""

#~ msgid "syntax_sugar: bool = True"
#~ msgstr ""

#~ msgid "Whether to output with syntax sugar, set false for complete printing."
#~ msgstr ""

#~ msgid "show_object_address: bool = False"
#~ msgstr ""

#~ msgid "Whether to include the object's address as part of the TVMScript name"
#~ msgstr ""

#~ msgid "path_to_underline"
#~ msgstr ""

#~ msgid "Optional[List[ObjectPath]] = None"
#~ msgstr ""

#~ msgid "Object path to be underlined"
#~ msgstr ""

#~ msgid "path_to_annotate"
#~ msgstr ""

#~ msgid "Optional[Dict[ObjectPath, str]] = None"
#~ msgstr ""

#~ msgid "Object path to be annotated"
#~ msgstr ""

#~ msgid "obj_to_underline"
#~ msgstr ""

#~ msgid "Optional[List[Object]] = None"
#~ msgstr ""

#~ msgid "Object to be underlined"
#~ msgstr ""

#~ msgid "obj_to_annotate"
#~ msgstr ""

#~ msgid "Optional[Dict[Object, str]] = None"
#~ msgstr ""

#~ msgid "Object to be annotated"
#~ msgstr ""

#~ msgid "script"
#~ msgstr ""

#~ msgid "The TVM Script of the given TVM IR"
#~ msgstr ""

#~ msgid "style"
#~ msgstr ""

#~ msgid ""
#~ "Pygmentize printing style, auto-detected "
#~ "if None.  See `tvm.script.highlight.cprint` "
#~ "for more details."
#~ msgstr ""

#~ msgid "black_format: Optional[bool]"
#~ msgstr ""

#~ msgid ""
#~ "If true, use the formatter Black "
#~ "to format the TVMScript. If false, "
#~ "do not apply the auto-formatter."
#~ msgstr ""

#~ msgid ""
#~ "If None (default), determine the "
#~ "behavior based on the environment "
#~ "variable \"TVM_BLACK_FORMAT\".  If this "
#~ "environment variable is unset, set to"
#~ " the empty string, or set to "
#~ "the integer zero, black auto-formatting"
#~ " will be disabled.  If the "
#~ "environment variable is set to a "
#~ "non-zero integer, black auto-formatting "
#~ "will be enabled."
#~ msgstr ""

#~ msgid ""
#~ "Note that the \"TVM_BLACK_FORMAT\" environment"
#~ " variable only applies to the "
#~ "`.show()` method, and not the underlying"
#~ " `.script()` method.  The `.show()` method"
#~ " is intended for human-readable "
#~ "output based on individual user "
#~ "preferences, while the `.script()` method "
#~ "is intended to provided a consistent "
#~ "output regardless of environment."
#~ msgstr ""

#~ msgid "TVM runtime ShapeTuple object. Parameters ---------- shape : list[int]"
#~ msgstr ""

#~ msgid "The shape list used to construct the object."
#~ msgstr ""

#~ msgid "content"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`__from_tvm_object__ "
#~ "<tvm.runtime.String.__from_tvm_object__>`\\ \\(obj\\)"
#~ msgstr ""

#~ msgid "Construct from a given tvm object."
#~ msgstr ""

#~ msgid ":py:obj:`__new__ <tvm.runtime.String.__new__>`\\ \\(cls\\, content\\)"
#~ msgstr ""

#~ msgid "Construct from string content."
#~ msgstr ""

#~ msgid "dev_id"
#~ msgstr ""

#~ msgid "int, optional"
#~ msgstr ""

#~ msgid "dev"
#~ msgstr ""

#~ msgid "Device"
#~ msgstr ""

#~ msgid "The created device"
#~ msgstr ""

#~ msgid "value"
#~ msgstr ""

#~ msgid "number"
#~ msgstr ""

#~ msgid "dtype"
#~ msgstr ""

#~ msgid "str or None, optional"
#~ msgstr ""

#~ msgid "span"
#~ msgstr ""

#~ msgid "Optional[Span]"
#~ msgstr ""

#~ msgid "const_val: tvm.Expr"
#~ msgstr ""

#~ msgid "The result expression."
#~ msgstr ""

#~ msgid "value : python value"
#~ msgstr ""

#~ msgid "tvm_val"
#~ msgstr ""

#~ msgid "Object or Function"
#~ msgstr ""

#~ msgid "Converted value in TVM"
#~ msgstr ""

#~ msgid ""
#~ "This function is redirected to "
#~ "`convert_to_object` as it is widely used"
#~ " in the codebase. We can choose "
#~ "one to keep and discard the other"
#~ " one later."
#~ msgstr ""

#~ msgid "obj"
#~ msgstr ""

#~ msgid "Object"
#~ msgstr ""

#~ msgid "The corresponding object value."
#~ msgstr ""

#~ msgid "dev_type: int or str"
#~ msgstr ""

#~ msgid "dev: tvm.runtime.Device"
#~ msgstr ""

#~ msgid "The corresponding device."
#~ msgstr ""

#~ msgid "target"
#~ msgstr ""

#~ msgid "enabled"
#~ msgstr ""

#~ msgid "Whether runtime is enabled."
#~ msgstr ""

#~ msgid "path"
#~ msgstr ""

#~ msgid "runtime.Module"
#~ msgstr ""

#~ msgid "The loaded module"
#~ msgstr ""

#~ msgid "param_bytes: bytearray"
#~ msgstr ""

#~ msgid "params"
#~ msgstr ""

#~ msgid "dict of str to NDArray"
#~ msgstr ""

#~ msgid "path: str"
#~ msgstr ""

#~ msgid "The path to the parameter file to load from."
#~ msgstr ""

#~ msgid ""
#~ "Load the .o library at path which"
#~ " implements functions with func_names. "
#~ "Unlike the generic load_module the "
#~ "result will remain as a static_library"
#~ " and will not be relinked on-"
#~ "the-fly into a .so library."
#~ msgstr ""

#~ msgid "Number of threads in use."
#~ msgstr ""

#~ msgid "The path to the parameter file."
#~ msgstr ""

#~ msgid "symbol_prefix: Optional[str]"
#~ msgstr ""

#~ msgid ""
#~ "Optional symbol prefix that can be "
#~ "used for search. When we lookup a"
#~ " symbol symbol_prefix + name will "
#~ "first be searched, then the name "
#~ "without symbol_prefix."
#~ msgstr ""

#~ msgid "The system-wide library module."
#~ msgstr ""

