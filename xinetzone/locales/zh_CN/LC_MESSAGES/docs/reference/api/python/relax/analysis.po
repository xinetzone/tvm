# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, xinetzone
# This file is distributed under the same license as the tvm package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tvm \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-05 11:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../doc/docs/reference/api/python/relax/analysis.rst:19
msgid "tvm.relax.analysis"
msgstr ""

#~ msgid "Relax IR analysis."
#~ msgstr ""

#~ msgid "Return result of fine-grained base check."
#~ msgstr ""

#~ msgid "Base check comes with fine-grained fail levels."
#~ msgstr ""

#~ msgid "FAIL_L0: The lhs and rhs have no intersection at all."
#~ msgstr ""

#~ msgid "FAIL_L1: We get the failure by looking at static information."
#~ msgstr ""

#~ msgid "FAIL_L2: We get the failure due to unknown symbolic variable relations."
#~ msgstr ""

#~ msgid ""
#~ "Return all global variables from "
#~ "expression expr. :param expr: The "
#~ "expression. :type expr: Expr"
#~ msgstr ""

#~ msgid "返回"
#~ msgstr ""

#~ msgid "**ret** -- List of global vars in expr, in post-DFS order"
#~ msgstr ""

#~ msgid "返回类型"
#~ msgstr ""

#~ msgid ""
#~ "Return all (local) variables from "
#~ "expression expr. :param expr: The "
#~ "expression. :type expr: Expr"
#~ msgstr ""

#~ msgid "**ret** -- List of vars in expr, in post-DFS order"
#~ msgstr ""

#~ msgid ""
#~ "Return all bound variables from "
#~ "expression expr. Bound variables are all"
#~ " variables that are declared in the"
#~ " expr. They only have meaning inside"
#~ " that expr, and can only be "
#~ "used in it. :param expr: The "
#~ "expression. :type expr: Expr"
#~ msgstr ""

#~ msgid "**ret** -- List of bound vars in expr, in post-DFS order"
#~ msgstr ""

#~ msgid "Collect TIR expressions used in non-negative contexts"
#~ msgstr ""

#~ msgid ""
#~ "Get TIR variables that are non-"
#~ "negative within the context where the"
#~ " struct info is used.  For example,"
#~ " any expression used as a tensor "
#~ "shape."
#~ msgstr ""

#~ msgid ""
#~ "The returned list is deduplicated - "
#~ "each TIR expression will appear at "
#~ "most once.  The order of the list"
#~ " is in the order of occurrence "
#~ "within the struct info."
#~ msgstr ""

#~ msgid "参数"
#~ msgstr ""

#~ msgid "The struct info object to be analyzed."
#~ msgstr ""

#~ msgid ""
#~ "**ret** -- The list of TIR "
#~ "variables that can be defined from "
#~ "the StructInfo"
#~ msgstr ""

#~ msgid "Collect variables whose value can be computed at compile-time"
#~ msgstr ""

#~ msgid ""
#~ "If a function has the `kNumInput` "
#~ "attribute, then the first `kNumInput` "
#~ "parameters are provided at run-time, "
#~ "while all remaining parameters may be"
#~ " known at compile-time.  This utility"
#~ " collects all variable bindings that "
#~ "only depend, directly or indirectly, on"
#~ " the parameters known at compile-"
#~ "time."
#~ msgstr ""

#~ msgid "The `relax.Function` to analyze"
#~ msgstr ""

#~ msgid ""
#~ "**ret** -- The set of variables "
#~ "that can be computed at compile-"
#~ "time, in order of their occurrence "
#~ "within the function."
#~ msgstr ""

#~ msgid ""
#~ "Check if the given expression (likely"
#~ " a function body) contains any impure"
#~ " calls."
#~ msgstr ""

#~ msgid ""
#~ "The expression to be examined. If "
#~ "expr is a function, we check the"
#~ " body."
#~ msgstr ""

#~ msgid ""
#~ "For a recursive function, the analysis"
#~ " can ignore the self-calls for "
#~ "checking purity."
#~ msgstr ""

#~ msgid ""
#~ "**ret** -- True if there is an "
#~ "impure call (call to a function "
#~ "that may have visible side effects)."
#~ msgstr ""

#~ msgid "备注"
#~ msgstr ""

#~ msgid ""
#~ "Relies on StructInfo annotations, so "
#~ "ensure that the module has been "
#~ "normalized first. Also, an impure call"
#~ " in a *nested* function does *not*"
#~ " mean that the outer expression "
#~ "contains an impure call--it only "
#~ "does if the nested function is "
#~ "*later called*."
#~ msgstr ""

#~ msgid ""
#~ "Get the TIR variables that may be"
#~ " defined from input struct info. The"
#~ " returned list is deduplicated - each"
#~ " TIR variable will appear at most "
#~ "once."
#~ msgstr ""

#~ msgid ""
#~ "Get the TIR variables that defined "
#~ "in the input function. The returned "
#~ "list is deduplicated - each TIR "
#~ "variable will appear at most once."
#~ msgstr ""

#~ msgid "The function object to be analyzed."
#~ msgstr ""

#~ msgid ""
#~ "**ret** -- The list of symbolic "
#~ "variables that are defined in the "
#~ "input function."
#~ msgstr ""

#~ msgid "Derive the call's ret value struct info from inputs."
#~ msgstr ""

#~ msgid "The call's function signature."
#~ msgstr ""

#~ msgid "The call expression"
#~ msgstr ""

#~ msgid "The context block builder."
#~ msgstr ""

#~ msgid "**ret** -- The derived return value struct info."
#~ msgstr ""

#~ msgid ""
#~ "This is an internal derivation function,"
#~ " call.op field is ignored in this "
#~ "case and the derivation only depends "
#~ "on func_sinfo."
#~ msgstr ""

#~ msgid ""
#~ "Find all sets of recursive or "
#~ "mutually recursive functions in the "
#~ "module."
#~ msgstr ""

#~ msgid ""
#~ "Two or more functions are mutually "
#~ "recursive if there is some cycle "
#~ "of references among them. For example,"
#~ " if there are two functions A "
#~ "and B, they are mutually recursive "
#~ "if A calls B and B calls A."
#~ " Another case would be with three "
#~ "functions A, B, and C, where A "
#~ "calls B, B calls C, and C "
#~ "calls A."
#~ msgstr ""

#~ msgid ""
#~ "(Note that functions do not have "
#~ "to call each other to reference "
#~ "each other. For example, if a "
#~ "function returns another function, that "
#~ "is still a reference that could "
#~ "potentially be recursive, even without a"
#~ " call.)"
#~ msgstr ""

#~ msgid ""
#~ "If a function is simply recursive "
#~ "and not mutually recursive with any "
#~ "other, it will be reported as a"
#~ " group by itself."
#~ msgstr ""

#~ msgid ""
#~ "**ret** -- Each member of the list"
#~ " is a list of global functions "
#~ "that references each other mutually "
#~ "recursively. If a function is simply "
#~ "recursive and not mutually recursive "
#~ "with any other, it will be a "
#~ "singleton in this list."
#~ msgstr ""

#~ msgid "Erase sinfo into a well defined form."
#~ msgstr ""

#~ msgid ""
#~ "This function removes the StructInfo's "
#~ "dependencies on shape and vars that "
#~ "are not defined in given maps."
#~ msgstr ""

#~ msgid "The input struct info."
#~ msgstr ""

#~ msgid "Specifies the defined shape vars and the values they should map to."
#~ msgstr ""

#~ msgid "Specifies the defined vars and the values they should map to."
#~ msgstr ""

#~ msgid "**ret** -- The corresponding erased struct info."
#~ msgstr ""

#~ msgid ""
#~ "Analysis function that estimates the "
#~ "memory usage of Relax functions in "
#~ "an IRModule. The estimation includes the"
#~ " total memory size needed to be "
#~ "allocated before and after memory "
#~ "planning."
#~ msgstr ""

#~ msgid ""
#~ "The result might be over-estimated, "
#~ "as the estimation is static, which "
#~ "does not consider control flows (such"
#~ " as \"if\" and cross-function calls)."
#~ " It simply accumulates the size of"
#~ " every alloc_tensor and alloc_storage."
#~ msgstr ""

#~ msgid ""
#~ "This analysis function is used to "
#~ "demonstrate the effect of memory "
#~ "planning."
#~ msgstr ""

#~ msgid ""
#~ "The input IRModule whose functions "
#~ "inside are to be analyzed. If the"
#~ " input is a Function, we will "
#~ "wrap it with a IRModule, with the"
#~ " function named \"main\"."
#~ msgstr ""

#~ msgid "**est** -- The estimation information, in the form of a string."
#~ msgstr ""

#~ msgid ""
#~ "We regards \"relax.memory.alloc_tensor/storage\" as"
#~ " the results produced by memory "
#~ "planning."
#~ msgstr ""

#~ msgid ""
#~ "Get the TIR variables that are "
#~ "used but not defined in the input"
#~ " function. The returned list is "
#~ "deduplicated - each TIR variable will"
#~ " appear at most once."
#~ msgstr ""

#~ msgid ""
#~ "**ret** -- The list of symbolic "
#~ "variables that are used but not "
#~ "defined in the input function."
#~ msgstr ""

#~ msgid ""
#~ "Return all free variables from "
#~ "expression expr. Free variables are "
#~ "variables that are not bound by a"
#~ " VarBinding or a function parameter "
#~ "in the expression. :param expr: The "
#~ "expression. :type expr: Expr"
#~ msgstr ""

#~ msgid "**ret** -- List of free vars in expr, in post-DFS order"
#~ msgstr ""

#~ msgid "Get the corresponding static type from a StructInfo."
#~ msgstr ""

#~ msgid "**ret** -- The corresponding static type."
#~ msgstr ""

#~ msgid "Get a mapping from Var to Expr for each variable in the function."
#~ msgstr ""

#~ msgid "The input function to be analyzed."
#~ msgstr ""

#~ msgid "A mapping from Var to Expr."
#~ msgstr ""

#~ msgid ""
#~ "Check if the given PrimFunc is "
#~ "essentially doing a reshape operation. "
#~ "The reshape operation also includes "
#~ "expand_dims, squeeze, flatten, etc."
#~ msgstr ""

#~ msgid ""
#~ "Here the allowed reshape pattern is: "
#~ "for example, assume the operation is "
#~ "`B[l_0, l_1, ..., l_b] = A[r_0, "
#~ "r_1, ..., r_a]`, we check if we"
#~ " can prove that the flattened index"
#~ " of l_0, ..., l_b under buffer "
#~ "B equals to the flattened index of"
#~ " r_0, ..., r_a under buffer A."
#~ msgstr ""

#~ msgid "The function to be examined."
#~ msgstr ""

#~ msgid ""
#~ "**ret** -- A boolean indicating if "
#~ "the given PrimFunc is doing a "
#~ "reshape."
#~ msgstr ""

#~ msgid ""
#~ "According to the description above, the"
#~ " returned result can only be "
#~ "false-negative and cannot be false-"
#~ "positive, since whenever we cannot prove"
#~ " the equality, we return false. This"
#~ " property guarantees the safety of "
#~ "this function."
#~ msgstr ""

#~ msgid "Return a map from variable name to its bindings."
#~ msgstr ""

#~ msgid ""
#~ "Recursively visit the ir in post "
#~ "DFS order node, apply fvisit. Each "
#~ "node is guaranteed to be visited "
#~ "only once."
#~ msgstr ""

#~ msgid "The input expression."
#~ msgstr ""

#~ msgid "The visitor function to be applied."
#~ msgstr ""

#~ msgid ""
#~ "It removes: 1. Unused local VarBindings"
#~ " in a DataflowBlock. 2. Unused "
#~ "DataflowBlocks in a function."
#~ msgstr ""

#~ msgid ""
#~ "For IRModule-wise DCE, use "
#~ "py:func:`tvm.relax.transform.DeadCodeElimination`."
#~ msgstr ""

#~ msgid "The function with unused variables removed."
#~ msgstr ""

#~ msgid "Run a base check to see if base subsumes derived."
#~ msgstr ""

#~ msgid "The base struct info."
#~ msgstr ""

#~ msgid "The derived struct info."
#~ msgstr ""

#~ msgid "Unify the two struct info to their least common ancestor."
#~ msgstr ""

#~ msgid "The left operand."
#~ msgstr ""

#~ msgid "The right operand."
#~ msgstr ""

#~ msgid "**ret** -- The corresponding lca result."
#~ msgstr ""

#~ msgid "Suggest Layout transformations of blocks and buffers in a PrimFunc."
#~ msgstr ""

#~ msgid ""
#~ "PrimFunc on which analysis will be "
#~ "performed and transformations suggested."
#~ msgstr ""

#~ msgid ""
#~ "List of layout transformations on the"
#~ " output buffers. The number of layout"
#~ " transformations must match the number "
#~ "of outputs of the PrimFunc."
#~ msgstr ""

#~ msgid ""
#~ "**ret** -- Suggested transforms per "
#~ "block in `func`. For each block "
#~ "the returned value is a map from"
#~ " the object (block or buffer) to "
#~ "it's index map transformation."
#~ msgstr ""

#~ msgid ""
#~ "Get the TIR variables that appear "
#~ "in the input struct info. The "
#~ "returned list is deduplicated - each "
#~ "TIR variable will appear at most "
#~ "once."
#~ msgstr ""

#~ msgid ""
#~ "**ret** -- The list of TIR "
#~ "variables that appear in the input "
#~ "struct info."
#~ msgstr ""

#~ msgid "Analyze the variable use-def chain in a dataflow block."
#~ msgstr ""

#~ msgid "The dataflow block to analyze"
#~ msgstr ""

#~ msgid "A mapping from variable definition to its uses."
#~ msgstr ""

#~ msgid "Check if the IRModule is well formed."
#~ msgstr ""

#~ msgid "The input IRModule or relax.Function."
#~ msgstr ""

#~ msgid ""
#~ "A boolean flag indicating if the "
#~ "property \"every Expr must have defined"
#~ " structure info\" will be checked."
#~ msgstr ""

#~ msgid "**ret** -- True if the IRModule is well formed, False if not."
#~ msgstr ""

#~ msgid ""
#~ "By default the structure info is "
#~ "always checked. It is only in test"
#~ " cases where `check_struct_info` might be"
#~ " false, so that other well-formed "
#~ "requirements will be well tested and "
#~ "will not be blocked by not having"
#~ " structure info."
#~ msgstr ""

