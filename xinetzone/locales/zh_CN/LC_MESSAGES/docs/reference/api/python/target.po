# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, xinetzone
# This file is distributed under the same license as the TVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: TVM \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-11-17 09:59+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../notebook/docs/reference/api/python/target.rst:19
msgid "tvm.target"
msgstr ""

#~ msgid ":py:obj:`GenericFunc <tvm.target.GenericFunc>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ":py:obj:`TargetKind <tvm.target.TargetKind>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ":py:obj:`GenericFunc <tvm.target.GenericFunc>`\\"
#~ msgstr ""

#~ msgid ":py:obj:`TargetKind <tvm.target.TargetKind>`\\"
#~ msgstr ""

#~ msgid "Target description and codgen module."
#~ msgstr ""

#~ msgid "TVM's target string is in format ``<target_kind> [-option=value]...``."
#~ msgstr ""

#~ msgid "The list of options include:"
#~ msgstr ""

#~ msgid "**-device=<device name>**"
#~ msgstr ""

#~ msgid "The device name."
#~ msgstr ""

#~ msgid "**-mtriple=<target triple>**"
#~ msgstr ""

#~ msgid "Specify the target triple, which is useful for cross compilation."
#~ msgstr ""

#~ msgid "**-mcpu=<cpuname>**"
#~ msgstr ""

#~ msgid ""
#~ "Specify a specific chip in the "
#~ "current architecture to generate code "
#~ "for. By default this is infered "
#~ "from the target triple and autodetected"
#~ " to the current architecture."
#~ msgstr ""

#~ msgid "**-mattr=a1,+a2,-a3,...**"
#~ msgstr ""

#~ msgid ""
#~ "Override or control specific attributes "
#~ "of the target, such as whether "
#~ "SIMD operations are enabled or not. "
#~ "The default set of attributes is "
#~ "set by the current CPU."
#~ msgstr ""

#~ msgid "**-mabi=<abi>**"
#~ msgstr ""

#~ msgid "Generate code for the specified ABI, for example \"lp64d\"."
#~ msgstr ""

#~ msgid "**-system-lib**"
#~ msgstr ""

#~ msgid ""
#~ "Build TVM system library module. System"
#~ " lib is a global module that "
#~ "contains self registered functions in "
#~ "program startup. User can get the "
#~ "module using :any:`tvm.runtime.system_lib`. It "
#~ "is useful in environments where dynamic"
#~ " loading api like dlopen is banned."
#~ " The system lib will be available "
#~ "as long as the result code is "
#~ "linked by the program."
#~ msgstr ""

#~ msgid ""
#~ "We can use :py:func:`tvm.target.Target` to "
#~ "create a tvm.target.Target from the "
#~ "target string. We can also use "
#~ "other specific function in this module"
#~ " to create specific targets."
#~ msgstr ""

#~ msgid "**Classes:**"
#~ msgstr ""

#~ msgid "GenericFunc node reference."
#~ msgstr ""

#~ msgid ":py:obj:`Target <tvm.target.Target>`\\ \\(target\\[\\, host\\]\\)"
#~ msgstr ""

#~ msgid "Target device information, use through TVM API."
#~ msgstr ""

#~ msgid "Kind of a compilation target"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`VirtualDevice <tvm.target.VirtualDevice>`\\ "
#~ "\\(device\\[\\, target\\, memory\\_scope\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ "A compile time representation for where"
#~ " data is to be stored at "
#~ "runtime, and how to compile code "
#~ "to compute it."
#~ msgstr ""

#~ msgid "**Functions:**"
#~ msgstr ""

#~ msgid ":py:obj:`arm_cpu <tvm.target.arm_cpu>`\\ \\(\\[model\\, options\\]\\)"
#~ msgstr ""

#~ msgid "Returns a ARM CPU target."
#~ msgstr ""

#~ msgid ":py:obj:`bifrost <tvm.target.bifrost>`\\ \\(\\[model\\, options\\]\\)"
#~ msgstr ""

#~ msgid "Return an ARM Mali GPU target (Bifrost architecture)."
#~ msgstr ""

#~ msgid ":py:obj:`create <tvm.target.create>`\\ \\(target\\)"
#~ msgstr ""

#~ msgid "Deprecated."
#~ msgstr ""

#~ msgid ":py:obj:`cuda <tvm.target.cuda>`\\ \\(\\[model\\, arch\\, options\\]\\)"
#~ msgstr ""

#~ msgid "Returns a cuda target."
#~ msgstr ""

#~ msgid ":py:obj:`generic_func <tvm.target.generic_func>`\\ \\(fdefault\\)"
#~ msgstr ""

#~ msgid "Wrap a target generic function."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`get_native_generic_func "
#~ "<tvm.target.get_native_generic_func>`\\ \\(name\\)"
#~ msgstr ""

#~ msgid "Get a generic function from the global registry."
#~ msgstr ""

#~ msgid ":py:obj:`hexagon <tvm.target.hexagon>`\\ \\(\\[cpu\\_ver\\]\\)"
#~ msgstr ""

#~ msgid "Returns a Hexagon target."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`intel_graphics <tvm.target.intel_graphics>`\\ "
#~ "\\(\\[model\\, options\\]\\)"
#~ msgstr ""

#~ msgid "Returns an Intel Graphics target."
#~ msgstr ""

#~ msgid ":py:obj:`list_tags <tvm.target.list_tags>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ""
#~ "Returns a dict of tags, which maps"
#~ " each tag name to its corresponding"
#~ " target."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`make_compilation_config "
#~ "<tvm.target.make_compilation_config>`\\ \\(ctxt\\, "
#~ "targets\\[\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ "Returns a CompilationConfig appropriate for"
#~ " targets and an optional host_target."
#~ msgstr ""

#~ msgid ":py:obj:`mali <tvm.target.mali>`\\ \\(\\[model\\, options\\]\\)"
#~ msgstr ""

#~ msgid "Returns a ARM Mali GPU target."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`override_native_generic_func "
#~ "<tvm.target.override_native_generic_func>`\\ \\(func\\_name\\)"
#~ msgstr ""

#~ msgid "Override a generic function defined in C++"
#~ msgstr ""

#~ msgid ":py:obj:`rasp <tvm.target.rasp>`\\ \\(\\[options\\]\\)"
#~ msgstr ""

#~ msgid "Return a Raspberry 3b target."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`riscv_cpu <tvm.target.riscv_cpu>`\\ "
#~ "\\(\\[model\\, options\\]\\)"
#~ msgstr ""

#~ msgid "Returns a RISC-V CPU target."
#~ msgstr ""

#~ msgid ":py:obj:`rocm <tvm.target.rocm>`\\ \\(\\[model\\, options\\]\\)"
#~ msgstr ""

#~ msgid "Returns a ROCM target."
#~ msgstr ""

#~ msgid ""
#~ "GenericFunc node reference. This represents"
#~ " a generic function that may be "
#~ "specialized for different targets. When "
#~ "this object is called, a specialization"
#~ " is chosen based on the current "
#~ "target."
#~ msgstr ""

#~ msgid ""
#~ "Do not construct an instance of "
#~ "this object, it should only ever "
#~ "be used as a return value from "
#~ "calling into C++."
#~ msgstr ""

#~ msgid "**Methods:**"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`get_packed_func "
#~ "<tvm.target.GenericFunc.get_packed_func>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Get the packed function specified for the current target."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`register <tvm.target.GenericFunc.register>`\\ "
#~ "\\(func\\, key\\_list\\[\\, allow\\_override\\]\\)"
#~ msgstr ""

#~ msgid "Register a specialization for this GenericFunc."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`set_default <tvm.target.GenericFunc.set_default>`\\ "
#~ "\\(func\\[\\, allow\\_override\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ "Set the default function to be "
#~ "used if no specializations match the "
#~ "current target."
#~ msgstr ""

#~ msgid "返回"
#~ msgstr ""

#~ msgid ""
#~ "**func** -- The function specified for"
#~ " the current target. Return the "
#~ "default function if no specializations "
#~ "match the current target."
#~ msgstr ""

#~ msgid "返回类型"
#~ msgstr ""

#~ msgid "参数"
#~ msgstr ""

#~ msgid "The function to be registered."
#~ msgstr ""

#~ msgid "The key to be registered."
#~ msgstr ""

#~ msgid "Whether to allow existing keys to be overridden."
#~ msgstr ""

#~ msgid "The default function"
#~ msgstr ""

#~ msgid "Whether to allow the current default to be overridden"
#~ msgstr ""

#~ msgid "You can create target using the constructor or the following functions"
#~ msgstr ""

#~ msgid ":py:func:`tvm.target.arm_cpu` create arm_cpu target"
#~ msgstr ""

#~ msgid ":py:func:`tvm.target.cuda` create CUDA target"
#~ msgstr ""

#~ msgid ":py:func:`tvm.target.rocm` create ROCM target"
#~ msgstr ""

#~ msgid ":py:func:`tvm.target.mali` create Mali target"
#~ msgstr ""

#~ msgid ":py:func:`tvm.target.intel_graphics` create Intel Graphics target"
#~ msgstr ""

#~ msgid "**Attributes:**"
#~ msgstr ""

#~ msgid ":py:obj:`arch <tvm.target.Target.arch>`\\"
#~ msgstr ""

#~ msgid "Returns the cuda arch from the target if it exists."
#~ msgstr ""

#~ msgid ":py:obj:`mattr <tvm.target.Target.mattr>`\\"
#~ msgstr ""

#~ msgid "Returns the mattr from the target if it exists."
#~ msgstr ""

#~ msgid ":py:obj:`max_num_threads <tvm.target.Target.max_num_threads>`\\"
#~ msgstr ""

#~ msgid "Returns the max_num_threads from the target if it exists."
#~ msgstr ""

#~ msgid ":py:obj:`mcpu <tvm.target.Target.mcpu>`\\"
#~ msgstr ""

#~ msgid "Returns the mcpu from the target if it exists."
#~ msgstr ""

#~ msgid ":py:obj:`model <tvm.target.Target.model>`\\"
#~ msgstr ""

#~ msgid "Returns model from the target if it exists."
#~ msgstr ""

#~ msgid ":py:obj:`thread_warp_size <tvm.target.Target.thread_warp_size>`\\"
#~ msgstr ""

#~ msgid "Returns the thread_warp_size from the target if it exists."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`check_and_update_host_consist "
#~ "<tvm.target.Target.check_and_update_host_consist>`\\ "
#~ "\\(target\\[\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ "A helper function that merges a "
#~ "legacy \"target, target_host\" pair, then "
#~ "returns the merged target and its "
#~ "host field."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`current <tvm.target.Target.current>`\\ "
#~ "\\(\\[allow\\_none\\]\\)"
#~ msgstr ""

#~ msgid "Returns the current target."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`get_kind_attr <tvm.target.Target.get_kind_attr>`\\ "
#~ "\\(attr\\_name\\)"
#~ msgstr ""

#~ msgid "Get additional attribute about the target kind."
#~ msgstr ""

#~ msgid ":py:obj:`list_kinds <tvm.target.Target.list_kinds>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Returns the list of available target names."
#~ msgstr ""

#~ msgid ""
#~ "A helper function that merges a "
#~ "legacy \"target, target_host\" pair, then "
#~ "returns the merged target and its "
#~ "host field. The function is for "
#~ "legacy target and target host pair "
#~ "only, and should not be used in"
#~ " the new target system."
#~ msgstr ""

#~ msgid "The target or heterogeneous target"
#~ msgstr ""

#~ msgid "The target host"
#~ msgstr ""

#~ msgid ""
#~ "When the type of target is dict,"
#~ " whether Target is the key (Otherwise"
#~ " the value)"
#~ msgstr ""

#~ msgid "Whether allow the current target to be none"
#~ msgstr ""

#~ msgid "引发"
#~ msgstr ""

#~ msgid "The attribute name."
#~ msgstr ""

#~ msgid "**value** -- The attribute value"
#~ msgstr ""

#~ msgid ":py:obj:`options <tvm.target.TargetKind.options>`\\"
#~ msgstr ""

#~ msgid "Returns the dict of available option names and types"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`options_from_name "
#~ "<tvm.target.TargetKind.options_from_name>`\\ \\(kind\\_name\\)"
#~ msgstr ""

#~ msgid ""
#~ "Returns the dict of available option "
#~ "names and types from a name of "
#~ "TargetKind"
#~ msgstr ""

#~ msgid ""
#~ "Returns a ARM CPU target. This "
#~ "function will also download pre-tuned"
#~ " op parameters when there is none."
#~ msgstr ""

#~ msgid "SoC name or phone name of the arm board."
#~ msgstr ""

#~ msgid "Additional options"
#~ msgstr ""

#~ msgid ""
#~ "Deprecated. Use the constructor of "
#~ ":py:mod:`tvm.target.Target` directly."
#~ msgstr ""

#~ msgid "The model of cuda device (e.g. 1080ti)"
#~ msgstr ""

#~ msgid "The cuda architecture (e.g. sm_61)"
#~ msgstr ""

#~ msgid ""
#~ "Generic function allows registration of "
#~ "further functions that can be dispatched"
#~ " on current target context. If no "
#~ "registered dispatch is matched, the "
#~ "fdefault will be called."
#~ msgstr ""

#~ msgid "The default function."
#~ msgstr ""

#~ msgid "**fgeneric** -- A wrapped generic function."
#~ msgstr ""

#~ msgid "示例"
#~ msgstr ""

#~ msgid ""
#~ "Get a generic function from the "
#~ "global registry. If no function is "
#~ "registered under the given name, a "
#~ "new generic function is created."
#~ msgstr ""

#~ msgid "The name of the generic function to get"
#~ msgstr ""

#~ msgid "**func** -- The generic function for the given name"
#~ msgstr ""

#~ msgid ""
#~ "CPU version used for code generation."
#~ " Not all allowed cpu str will "
#~ "be valid, LLVM will throw an "
#~ "error."
#~ msgstr ""

#~ msgid "Size of HVX vector in bytes. Value of 0 disables HVX codegen."
#~ msgstr ""

#~ msgid ""
#~ "User defined sim arguments. CPU version"
#~ " defaults to cpu_ver. Otherwise, separate"
#~ " versions are used for codegen and"
#~ " sim. Not all allowed cpu strings "
#~ "will be valid, simulator will throw "
#~ "an error if invalid. Does not "
#~ "affect codegen."
#~ msgstr ""

#~ msgid "User defined compiler arguments."
#~ msgstr ""

#~ msgid "Whether to link graph parameters into the LLVM module."
#~ msgstr ""

#~ msgid "The model of this device"
#~ msgstr ""

#~ msgid ""
#~ "**tag_dict** -- The dict of tags "
#~ "mapping each tag name to to its"
#~ " corresponding target. None if TVM is"
#~ " built in runtime-only mode."
#~ msgstr ""

#~ msgid ""
#~ "Returns a CompilationConfig appropriate for"
#~ " targets and an optional host_target. "
#~ "Currently intended just for unit tests"
#~ " and will be replaced by a "
#~ "Python CompilationConfig class in the "
#~ "future. Note that targets must be "
#~ "a dictionary from IntImm objects to "
#~ "Targets and we do not support any"
#~ " of the lighter-weight conventions "
#~ "used by the various build(...) APIs."
#~ msgstr ""

#~ msgid "The name of the generic func to be overridden"
#~ msgstr ""

#~ msgid "Returns a RISC-V CPU target. Default: sifive-u54 rv64gc"
#~ msgstr ""

#~ msgid "CPU name."
#~ msgstr ""

#~ msgid "Note"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`VirtualDevice <tvm.target.VirtualDevice>`\\ "
#~ "\\(\\[device\\, target\\, memory\\_scope\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`make_compilation_config "
#~ "<tvm.target.make_compilation_config>`\\ \\(ctxt\\, "
#~ "target\\[\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ "Returns a CompilationConfig appropriate for"
#~ " target and target_host, using the "
#~ "same representation conventions as for "
#~ "the standard build interfaces."
#~ msgstr ""

#~ msgid ":py:obj:`stm32 <tvm.target.stm32>`\\ \\(\\[series\\, options\\]\\)"
#~ msgstr ""

#~ msgid "Returns a STM32 target."
#~ msgstr ""

#~ msgid "Returns"
#~ msgstr ""

#~ msgid "func"
#~ msgstr ""

#~ msgid "PackedFunc"
#~ msgstr ""

#~ msgid ""
#~ "The function specified for the current"
#~ " target. Return the default function "
#~ "if no specializations match the current"
#~ " target."
#~ msgstr ""

#~ msgid "Parameters"
#~ msgstr ""

#~ msgid "function"
#~ msgstr ""

#~ msgid "key"
#~ msgstr ""

#~ msgid "str or list of str"
#~ msgstr ""

#~ msgid "allow_override"
#~ msgstr ""

#~ msgid "bool, optional"
#~ msgstr ""

#~ msgid "bool"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`__init__ <tvm.target.Target.__init__>`\\ "
#~ "\\(target\\[\\, host\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ "Construct a TVM target object from "
#~ "1) Raw target string 2) Target "
#~ "config dict 3) Target tag"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`canon_multi_target "
#~ "<tvm.target.Target.canon_multi_target>`\\ \\(multi\\_targets\\)"
#~ msgstr ""

#~ msgid ""
#~ "Given a single target-like object, "
#~ "or a collection-like object of "
#~ "target-like objects, returns a TVM "
#~ "Array of TVM Target objects representing"
#~ " then."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`canon_multi_target_and_host "
#~ "<tvm.target.Target.canon_multi_target_and_host>`\\ "
#~ "\\(target\\[\\, ...\\]\\)"
#~ msgstr ""

#~ msgid "Returns a TVM Array<Target> capturing target and target_host."
#~ msgstr ""

#~ msgid ":py:obj:`canon_target <tvm.target.Target.canon_target>`\\ \\(target\\)"
#~ msgstr ""

#~ msgid ""
#~ "Given a single target-like object, "
#~ "returns the TVM Target object "
#~ "representing it."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`canon_target_and_host "
#~ "<tvm.target.Target.canon_target_and_host>`\\ \\(target\\[\\, "
#~ "target\\_host\\]\\)"
#~ msgstr ""

#~ msgid "Returns a TVM Target capturing target and target_host."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`canon_target_map_and_host "
#~ "<tvm.target.Target.canon_target_map_and_host>`\\ "
#~ "\\(target\\_map\\[\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ "Returns target_map as a map from "
#~ "TVM Target's in canonical form to "
#~ "IRModules."
#~ msgstr ""

#~ msgid ":py:obj:`from_device <tvm.target.Target.from_device>`\\ \\(device\\)"
#~ msgstr ""

#~ msgid "Detects Target associated with the given device."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`get_target_device_type "
#~ "<tvm.target.Target.get_target_device_type>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Returns the device_type for this target."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`target_or_current "
#~ "<tvm.target.Target.target_or_current>`\\ \\(target\\)"
#~ msgstr ""

#~ msgid ""
#~ "Returns target, or the current target"
#~ " in the environment if target is "
#~ "None"
#~ msgstr ""

#~ msgid ":py:obj:`max_block_size_x <tvm.target.Target.max_block_size_x>`\\"
#~ msgstr ""

#~ msgid "Returns the max block size in x-dimension from the target if it exists."
#~ msgstr ""

#~ msgid ":py:obj:`max_block_size_y <tvm.target.Target.max_block_size_y>`\\"
#~ msgstr ""

#~ msgid "Returns the max block size in y-dimension from the target if it exists."
#~ msgstr ""

#~ msgid "target"
#~ msgstr ""

#~ msgid "Union[str, Dict[str, Any]]"
#~ msgstr ""

#~ msgid ""
#~ "Can be one of a literal target "
#~ "string, a json string describing a "
#~ "configuration, or a dictionary of "
#~ "configuration options. When using a "
#~ "dictionary or json string to configure"
#~ " target, the possible values are:"
#~ msgstr ""

#~ msgid "kind"
#~ msgstr ""

#~ msgid "str (required)"
#~ msgstr ""

#~ msgid "Which codegen path to use, for example 'llvm' or 'cuda'."
#~ msgstr ""

#~ msgid "keys"
#~ msgstr ""

#~ msgid "List of str (optional)"
#~ msgstr ""

#~ msgid ""
#~ "A set of strategies that can be"
#~ " dispatched to. When using \"kind=opencl\""
#~ " for example, one could set keys "
#~ "to [\"mali\", \"opencl\", \"gpu\"]."
#~ msgstr ""

#~ msgid "device"
#~ msgstr ""

#~ msgid "str (optional)"
#~ msgstr ""

#~ msgid ""
#~ "A single key that corresponds to "
#~ "the actual device being run on. "
#~ "This will be effectively appended to "
#~ "the keys."
#~ msgstr ""

#~ msgid "libs"
#~ msgstr ""

#~ msgid "The set of external libraries to use. For example ['cblas', 'mkl']."
#~ msgstr ""

#~ msgid "system-lib"
#~ msgstr ""

#~ msgid "bool (optional)"
#~ msgstr ""

#~ msgid ""
#~ "If True, build a module that "
#~ "contains self registered functions. Useful "
#~ "for environments where dynamic loading "
#~ "like dlopen is banned."
#~ msgstr ""

#~ msgid "mcpu"
#~ msgstr ""

#~ msgid "The specific cpu being run on. Serves only as an annotation."
#~ msgstr ""

#~ msgid "model"
#~ msgstr ""

#~ msgid "An annotation indicating what model a workload came from."
#~ msgstr ""

#~ msgid "runtime"
#~ msgstr ""

#~ msgid "An annotation indicating which runtime to use with a workload."
#~ msgstr ""

#~ msgid "mtriple"
#~ msgstr ""

#~ msgid ""
#~ "The llvm triplet describing the target,"
#~ " for example \"arm64-linux-android\"."
#~ msgstr ""

#~ msgid "mattr"
#~ msgstr ""

#~ msgid ""
#~ "The llvm features to compile with, "
#~ "for example [\"+avx512f\", \"+mmx\"]."
#~ msgstr ""

#~ msgid "mfloat-abi"
#~ msgstr ""

#~ msgid ""
#~ "An llvm setting that is one of "
#~ "'hard' or 'soft' indicating whether to"
#~ " use hardware or software floating-"
#~ "point operations."
#~ msgstr ""

#~ msgid "mabi"
#~ msgstr ""

#~ msgid ""
#~ "An llvm setting. Generate code for "
#~ "the specified ABI, for example "
#~ "\"lp64d\"."
#~ msgstr ""

#~ msgid "host"
#~ msgstr ""

#~ msgid "Union[str, Dict[str, Any]] (optional)"
#~ msgstr ""

#~ msgid "Description for target host. Can be recursive. Similar to target."
#~ msgstr ""

#~ msgid "Optional[Union[str, Dict[str, Any]]]"
#~ msgstr ""

#~ msgid ""
#~ "Similar to target but for target "
#~ "host. Can be one of a literal "
#~ "target host string, a json string "
#~ "describing a configuration, or a "
#~ "dictionary of configuration options. When "
#~ "using a dictionary or json string "
#~ "to configure target, the possible values"
#~ " are same as target."
#~ msgstr ""

#~ msgid ""
#~ "Given a single target-like object, "
#~ "or a collection-like object of "
#~ "target-like objects, returns a TVM "
#~ "Array of TVM Target objects representing"
#~ " then. Can convert from: - None "
#~ "(to None). - A single target-like"
#~ " object in a form recognized by "
#~ "canon_target. - A Python list or "
#~ "TVM Array of target-like objects "
#~ "in a form recognized by canon_target."
#~ " - A Python dict or TVM Map "
#~ "from TVM IntImm objects representing "
#~ "device types to a target-like "
#~ "object in a form recognized by "
#~ "canon_target. (This is a legacy method"
#~ " to represent heterogeneous targets. The"
#~ " keys are ignored.)"
#~ msgstr ""

#~ msgid ""
#~ "Returns a TVM Array<Target> capturing "
#~ "target and target_host. The given target"
#~ " can be in any form recognized "
#~ "by Target.canon_multi_target. If given, "
#~ "target_host can be in any form "
#~ "recognized by Target.canon_target. If "
#~ "target_host is given it will be "
#~ "set as the 'host' in each result"
#~ " Target object (and a warning given)."
#~ msgstr ""

#~ msgid ""
#~ "Given a single target-like object, "
#~ "returns the TVM Target object "
#~ "representing it. Can convert from: - "
#~ "None (to None). - An existing TVM"
#~ " Target object. - A string, eg "
#~ "\"cuda\" or \"cuda -arch=sm_80\" - A "
#~ "Python dictionary, eg {\"kind\": \"cuda\", "
#~ "\"arch\": \"sm_80\" }"
#~ msgstr ""

#~ msgid ""
#~ "Returns a TVM Target capturing target"
#~ " and target_host. Also returns the "
#~ "host in canonical form. The given "
#~ "target can be in any form "
#~ "recognized by Target.canon_target. If given,"
#~ " target_host can be in any form "
#~ "recognized by Target.canon_target. If "
#~ "target_host is given it will be "
#~ "set as the 'host' in the result"
#~ " Target object (and a warning given)."
#~ msgstr ""

#~ msgid ""
#~ "Note that this method does not "
#~ "support heterogeneous compilation targets."
#~ msgstr ""

#~ msgid ""
#~ "Returns target_map as a map from "
#~ "TVM Target's in canonical form to "
#~ "IRModules. The keys of the input "
#~ "target_map can be in any form "
#~ "recognized by Target.canon_target. Similarly, "
#~ "if given, target_host can be in "
#~ "any form recognized by Target.canon_target."
#~ " The final target_map keys will "
#~ "capture the target_host in canonical "
#~ "form. Also returns the target_host in"
#~ " canonical form."
#~ msgstr ""

#~ msgid "allow_none"
#~ msgstr ""

#~ msgid "Raises"
#~ msgstr ""

#~ msgid "ValueError if current target is not set."
#~ msgstr ""

#~ msgid ""
#~ "Detects Target associated with the given"
#~ " device. If the device does not "
#~ "exist, there will be an Error."
#~ msgstr ""

#~ msgid "dev"
#~ msgstr ""

#~ msgid "Union[str, Device]"
#~ msgstr ""

#~ msgid ""
#~ "The device to detect the target "
#~ "for. Supported device types: [\"cuda\", "
#~ "\"metal\", \"rocm\", \"vulkan\", \"opencl\", "
#~ "\"cpu\"]"
#~ msgstr ""

#~ msgid "Target"
#~ msgstr ""

#~ msgid "The detected target."
#~ msgstr ""

#~ msgid "attr_name"
#~ msgstr ""

#~ msgid "str"
#~ msgstr ""

#~ msgid "value"
#~ msgstr ""

#~ msgid "object"
#~ msgstr ""

#~ msgid "The attribute value"
#~ msgstr ""

#~ msgid "model: str"
#~ msgstr ""

#~ msgid "options"
#~ msgstr ""

#~ msgid "arch: str"
#~ msgstr ""

#~ msgid "fdefault"
#~ msgstr ""

#~ msgid "fgeneric"
#~ msgstr ""

#~ msgid "A wrapped generic function."
#~ msgstr ""

#~ msgid "Example"
#~ msgstr ""

#~ msgid "name"
#~ msgstr ""

#~ msgid "string"
#~ msgstr ""

#~ msgid "GenericFunc"
#~ msgstr ""

#~ msgid "The generic function for the given name"
#~ msgstr ""

#~ msgid "cpu_ver"
#~ msgstr ""

#~ msgid "str (default: \"v68\")"
#~ msgstr ""

#~ msgid "Recognized keyword parameters"
#~ msgstr ""

#~ msgid "hvx"
#~ msgstr ""

#~ msgid "int (default: 128)"
#~ msgstr ""

#~ msgid "llvm_options"
#~ msgstr ""

#~ msgid "str or list of str (default: None)"
#~ msgstr ""

#~ msgid "use_qfloat"
#~ msgstr ""

#~ msgid "bool (default: True for cpu_ver >= v68, False otherwise)"
#~ msgstr ""

#~ msgid "Whether to use QFloat HVX instructions."
#~ msgstr ""

#~ msgid "use_ieee_fp"
#~ msgstr ""

#~ msgid "bool (default: False)"
#~ msgstr ""

#~ msgid "Whether to use IEEE HVX instructions"
#~ msgstr ""

#~ msgid "num_cores"
#~ msgstr ""

#~ msgid "int (default: 4)"
#~ msgstr ""

#~ msgid ""
#~ "The number of HVX threads. This "
#~ "attribute is required by meta scheduler."
#~ msgstr ""

#~ msgid "vtcm_capacity: int (default: 0)"
#~ msgstr ""

#~ msgid ""
#~ "Hexagon VTCM capacity limitation. If the"
#~ " value is 0, the capacity is "
#~ "treated as unbounded."
#~ msgstr ""

#~ msgid "Note: Floating point support in HVX requires LLVM 14+."
#~ msgstr ""

#~ msgid "tag_dict"
#~ msgstr ""

#~ msgid "Optional[Dict[str, Target]]"
#~ msgstr ""

#~ msgid ""
#~ "The dict of tags mapping each tag"
#~ " name to its corresponding target. "
#~ "None if TVM is built in "
#~ "runtime-only mode."
#~ msgstr ""

#~ msgid ""
#~ "Returns a CompilationConfig appropriate for"
#~ " target and target_host, using the "
#~ "same representation conventions as for "
#~ "the standard build interfaces. Intended "
#~ "only for unit testing."
#~ msgstr ""

#~ msgid "func_name"
#~ msgstr ""

#~ msgid "series: str"
#~ msgstr ""

#~ msgid "Series name of a STM32 board series, eg. stm32H7xx or stm32F4xx"
#~ msgstr ""

