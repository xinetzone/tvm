# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, xinetzone
# This file is distributed under the same license as the tvm package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tvm \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-05 11:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../doc/docs/reference/api/python/tir/analysis.rst:19
msgid "tvm.tir.analysis"
msgstr ""

#~ msgid ""
#~ "Returns func written to capture the "
#~ "memory (aka storage) scope constraints "
#~ "for each of the func's parameters "
#~ "given by arg_and_result_memory_scopes. However, "
#~ "arg_and_result_memory_scopes should be w.r.t. "
#~ "the func's representation as a Relay "
#~ "Function of relay_func_type before lowering"
#~ " and conversion to DPS."
#~ msgstr ""

#~ msgid "Visible for testing."
#~ msgstr ""

#~ msgid ""
#~ "CAUTION: This is experimental. The "
#~ "resulting PrimFunc may not have fully"
#~ " accounted for all new memory scopes."
#~ msgstr ""

#~ msgid "The function to retrieve constraints from."
#~ msgstr ""

#~ msgid "The type of the Relay Function from which the func was derived."
#~ msgstr ""

#~ msgid ""
#~ "Memory constraints for funcs args and"
#~ " result in Relay form. The empty "
#~ "string denotes 'no constraint'."
#~ msgstr ""

#~ msgid "**result** -- The rewritten func."
#~ msgstr ""

#~ msgid ""
#~ "Calculate the constant size in bytes "
#~ "needed by the TIR allocates inside "
#~ "the TIR PrimFunc."
#~ msgstr ""

#~ msgid "The byte alignment required for each tensor"
#~ msgstr ""

#~ msgid "**result** -- Workspace size in bytes."
#~ msgstr ""

#~ msgid ""
#~ "Calculate the workspace size in bytes"
#~ " needed by the TIR allocates inside"
#~ " the TIR PrimFunc."
#~ msgstr ""

#~ msgid ""
#~ "Returns the memory (aka storage) scope"
#~ " constraints for all the arguments "
#~ "and result of func. However the "
#~ "result will be w.r.t. the func's "
#~ "representation as a Relay Function of"
#~ " relay_func_type before lowering and "
#~ "conversion to DPS."
#~ msgstr ""

#~ msgid ""
#~ "**result** -- Memory scope constraints "
#~ "for funcs args and result in Relay"
#~ " form. The empty string denotes 'no"
#~ " constraint'."
#~ msgstr ""

#~ msgid "Wrapping existing analysis utils."
#~ msgstr ""

#~ msgid "Detect out of bounds memory access in arrays."
#~ msgstr ""

#~ msgid "返回"
#~ msgstr ""

#~ msgid "**fpass** -- The result pass"
#~ msgstr ""

#~ msgid "返回类型"
#~ msgstr ""

#~ msgid "Asserts that the function is a pure function"
#~ msgstr ""

#~ msgid "Calculate allocated memory per memory scope required by TIR PrimFuncs."
#~ msgstr ""

#~ msgid "参数"
#~ msgstr ""

#~ msgid ""
#~ "The function or module to be "
#~ "detected. If a module is passed, "
#~ "allocated memory is calculated for all"
#~ " PrimFuncs inside the module"
#~ msgstr ""

#~ msgid ""
#~ "**result** -- Allocated memory size per"
#~ " scope in bytes for each function "
#~ "in the IRModule returned as a dict"
#~ " with function names as keys and "
#~ "a dict of allocated sizes as "
#~ "values. If a single PrimFunc is "
#~ "passed, the function name is returned"
#~ " as \"main\""
#~ msgstr ""

#~ msgid ""
#~ "Detect the lowest common ancestor(LCA) "
#~ "of buffer access, including both "
#~ "high-level access (BufferLoad, BufferStore) "
#~ "and low-level access (BufferLoad, "
#~ "BufferStore and opaque access). The LCA"
#~ " may be a For loop or a "
#~ "Block."
#~ msgstr ""

#~ msgid "The function to be detected."
#~ msgstr ""

#~ msgid "**result** -- Map from buffer to the LCA of all access to it."
#~ msgstr ""

#~ msgid "Estimate the FLOPs of a TIR fragment."
#~ msgstr ""

#~ msgid "The TIR fragment or IRModule to be estimated."
#~ msgstr ""

#~ msgid "**flops** -- The estimated FLOPs."
#~ msgstr ""

#~ msgid "Deeply compare two nested expressions."
#~ msgstr ""

#~ msgid "The left operand."
#~ msgstr ""

#~ msgid "The right operand."
#~ msgstr ""

#~ msgid "**result** -- The comparison result"
#~ msgstr ""

#~ msgid ""
#~ "This function does not remap variable"
#~ " bindings, it will not return true"
#~ " for (let x = 1 in x +"
#~ " 1) vs (let y = 1 in y"
#~ " + 1), unless x.same_as(y). Use "
#~ "py:func:`tvm.ir.structural_equal` to handle "
#~ "structural variable remapping."
#~ msgstr ""

#~ msgid ""
#~ "Due to the restriction of not "
#~ "remapping variables, this function can "
#~ "run faster than StructuralEqual and can"
#~ " be used as a utility function "
#~ "during arithmetic simplifications."
#~ msgstr ""

#~ msgid ""
#~ "Always consider py:func:`tvm.ir.structural_equal` "
#~ "first, which handles the structural "
#~ "remapping."
#~ msgstr ""

#~ msgid ":obj:`tvm.ir.structural_equal`"
#~ msgstr ""

#~ msgid "Find the \"anchor block\" of the given module."
#~ msgstr ""

#~ msgid ""
#~ "We define the anchor block to be"
#~ " the block with (1) an init "
#~ "statement and (2) having the biggest "
#~ "flops count. The latter condition is "
#~ "only used when there are multiple "
#~ "blocks with an init statement."
#~ msgstr ""

#~ msgid ""
#~ "For example, if the input module "
#~ "is conv2d + fused spatial blocks, "
#~ "conv2d is the anchor block. The "
#~ "input module may not contain more "
#~ "than one such block. For example, "
#~ "a module having two conv2d is not"
#~ " allowed as an input."
#~ msgstr ""

#~ msgid ""
#~ "However, a module created from winograd"
#~ " convolution has multiple blocks with "
#~ "an init statement (input transform, "
#~ "batched GEMM, and output transform). We"
#~ " use the second condition, the flops"
#~ " count, to determine that the batched"
#~ " GEMM block is the anchor block."
#~ msgstr ""

#~ msgid "The input TIR module."
#~ msgstr ""

#~ msgid "**anchor_block** -- The anchor block if found, None otherwise."
#~ msgstr ""

#~ msgid "Detect which regions of tensors in this block are read or written to."
#~ msgstr ""

#~ msgid "Regions are sorted by order of appearance in the AST."
#~ msgstr ""

#~ msgid "The block in which we are detecting read/write regions."
#~ msgstr ""

#~ msgid ""
#~ "The outside buffers which may access "
#~ "the block. Mapping from buffer var "
#~ "to the buffer"
#~ msgstr ""

#~ msgid ""
#~ "**result** --  Array of access regions."
#~ " There are three arrays of "
#~ "BufferRegion:     - first: read regions"
#~ "     - second: write regions     - "
#~ "third: opaque regions"
#~ msgstr ""

#~ msgid "**result** --"
#~ msgstr ""

#~ msgid "Array of access regions. There are three arrays of BufferRegion:"
#~ msgstr ""

#~ msgid "first: read regions"
#~ msgstr ""

#~ msgid "second: write regions"
#~ msgstr ""

#~ msgid "third: opaque regions"
#~ msgstr ""

#~ msgid "Auto detect the block read/write region according to its body stmt."
#~ msgstr ""

#~ msgid "An opaque access will be counted as both a read and a write access"
#~ msgstr ""

#~ msgid ""
#~ "**result** -- An array only consisting"
#~ " of the read regions and write "
#~ "regions of the input block"
#~ msgstr ""

#~ msgid ""
#~ "Utility function to get the list "
#~ "of lowering passes to be applied "
#~ "to calculate the compacted VTCM "
#~ "allocation size"
#~ msgstr ""

#~ msgid "**result** -- returns list of passes"
#~ msgstr ""

#~ msgid "Checks if the function is a pure function"
#~ msgstr ""

#~ msgid "Find undefined vars in a TIR statement or expression."
#~ msgstr ""

#~ msgid "The TIR statement or expression to be checked."
#~ msgstr ""

#~ msgid "The vars that is defined"
#~ msgstr ""

#~ msgid "**result** -- The undefined vars."
#~ msgstr ""

#~ msgid "Verify if module contains illegal host side direct memory access."
#~ msgstr ""

#~ msgid "The module to be verified."
#~ msgstr ""

#~ msgid "The attribute constraints."
#~ msgstr ""

#~ msgid "**result** -- The result of verification."
#~ msgstr ""

#~ msgid "Verify if func contains illegal host side direct memory access."
#~ msgstr ""

#~ msgid "Verify if the func is in SSA form."
#~ msgstr ""

#~ msgid "Verify if the given TIR is well-formed. The verification includes:"
#~ msgstr ""

#~ msgid ""
#~ "Check if expressions not contain vars"
#~ " that is defined outside the block."
#~ msgstr ""

#~ msgid "The function or module to be verified."
#~ msgstr ""

#~ msgid ""
#~ "The indicator if it raises an "
#~ "error when the function is not "
#~ "well-formed."
#~ msgstr ""

#~ msgid "**result** -- Whether it is a well-formed TIR function."
#~ msgstr ""

