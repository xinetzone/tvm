# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, xinetzone
# This file is distributed under the same license as the tvm package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tvm \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-05 11:22+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../doc/docs/reference/api/python/ir.rst:19
msgid "tvm.ir"
msgstr ""

#~ msgid ":py:obj:`Array <tvm.ir.Array>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ":py:obj:`Attrs <tvm.ir.Attrs>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ""
#~ "Attribute node, which is mainly use "
#~ "for defining attributes of relay "
#~ "operators."
#~ msgstr ""

#~ msgid ":py:obj:`BaseExpr <tvm.ir.BaseExpr>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ":py:obj:`BaseFunc <tvm.ir.BaseFunc>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`ConstantMemoryPools <tvm.ir.ConstantMemoryPools>`\\ "
#~ "\\(pools\\)"
#~ msgstr ""

#~ msgid ""
#~ "This object contains a list of "
#~ "ConstantPoolInfo objects to be used as"
#~ " read-only memory in the compilation"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`ConstantPoolInfo <tvm.ir.ConstantPoolInfo>`\\ "
#~ "\\(pool\\_name\\, targets\\[\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ "ConstantPoolInfo object holds information "
#~ "related to RO memory pools where "
#~ "the statically sized allocate nodes are"
#~ " pooled into."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`Constructor <tvm.ir.Constructor>`\\ "
#~ "\\(name\\_hint\\, inputs\\, belong\\_to\\)"
#~ msgstr ""

#~ msgid "Relay ADT constructor."
#~ msgstr ""

#~ msgid ":py:obj:`DictAttrs <tvm.ir.DictAttrs>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ":py:obj:`EnvFunc <tvm.ir.EnvFunc>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`FuncType <tvm.ir.FuncType>`\\ \\(arg\\_types\\,"
#~ " ret\\_type\\[\\, type\\_params\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ":py:obj:`GlobalInfo <tvm.ir.GlobalInfo>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`GlobalTypeVar <tvm.ir.GlobalTypeVar>`\\ "
#~ "\\(name\\_hint\\[\\, kind\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ "A global type variable that is "
#~ "used for defining new types or "
#~ "type aliases."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`IRModule <tvm.ir.IRModule>`\\ \\(\\[functions\\,"
#~ " type\\_definitions\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ":py:obj:`IncompleteType <tvm.ir.IncompleteType>`\\ \\(\\[kind\\]\\)"
#~ msgstr ""

#~ msgid "Incomplete type during type inference."
#~ msgstr ""

#~ msgid ":py:obj:`Map <tvm.ir.Map>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ":py:obj:`Node <tvm.ir.Node>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ":py:obj:`PoolInfo <tvm.ir.PoolInfo>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ""
#~ "PoolInfo object holds information related "
#~ "to memory pools where the statically "
#~ "sized allocate nodes will pooled into."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`PoolInfoProperties <tvm.ir.PoolInfoProperties>`\\ "
#~ "\\(\\[size\\_hint\\_bytes\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ":py:obj:`PrimExpr <tvm.ir.PrimExpr>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ":py:obj:`RelayExpr <tvm.ir.RelayExpr>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ":py:obj:`RelayRefType <tvm.ir.RelayRefType>`\\ \\(value\\)"
#~ msgstr ""

#~ msgid "Reference Type in relay."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`TensorAffineType <tvm.ir.TensorAffineType>`\\ "
#~ "\\(scale\\, zero\\_point\\, dtype\\[\\, ...\\]\\)"
#~ msgstr ""

#~ msgid "The quantized type of a tensor, with scale, zero point, and datatype"
#~ msgstr ""

#~ msgid ":py:obj:`TensorType <tvm.ir.TensorType>`\\ \\(shape\\[\\, dtype\\]\\)"
#~ msgstr ""

#~ msgid "A concrete TensorType in Relay."
#~ msgstr ""

#~ msgid ":py:obj:`TupleAffineType <tvm.ir.TupleAffineType>`\\ \\(types\\)"
#~ msgstr ""

#~ msgid "Affine types of a node with multiple outputs"
#~ msgstr ""

#~ msgid ":py:obj:`Type <tvm.ir.Type>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ":py:obj:`TypeCall <tvm.ir.TypeCall>`\\ \\(func\\, args\\)"
#~ msgstr ""

#~ msgid "Type function application."
#~ msgstr ""

#~ msgid ":py:obj:`TypeConstraint <tvm.ir.TypeConstraint>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Abstract class representing a type constraint."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`TypeData <tvm.ir.TypeData>`\\ \\(header\\, "
#~ "type\\_vars\\, constructors\\)"
#~ msgstr ""

#~ msgid "Stores the definition for an Algebraic Data Type (ADT) in Relay."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`TypeKind <tvm.ir.TypeKind>`\\ \\(value\\[\\, "
#~ "names\\, module\\, qualname\\, ...\\]\\)"
#~ msgstr ""

#~ msgid "Possible kinds of TypeVars."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`TypeRelation <tvm.ir.TypeRelation>`\\ \\(func\\,"
#~ " args\\, num\\_inputs\\, attrs\\)"
#~ msgstr ""

#~ msgid "User defined type relation, it is an input-output relation on types."
#~ msgstr ""

#~ msgid ":py:obj:`TypeVar <tvm.ir.TypeVar>`\\ \\(name\\_hint\\[\\, kind\\]\\)"
#~ msgstr ""

#~ msgid "Type parameter in functions."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`WorkspaceMemoryPools <tvm.ir.WorkspaceMemoryPools>`\\"
#~ " \\(pools\\)"
#~ msgstr ""

#~ msgid ""
#~ "This object contains a list of "
#~ "WorkspacePoolInfo objects to be used as"
#~ " workspace memory in the compilation"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`WorkspacePoolInfo <tvm.ir.WorkspacePoolInfo>`\\ "
#~ "\\(pool\\_name\\, targets\\[\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ "WorkspacePoolInfo object holds information "
#~ "related to RW memory pools where "
#~ "the statically sized allocate nodes will"
#~ " pooled into."
#~ msgstr ""

#~ msgid "The list of ConstantPoolInfo objects to be used with the compilation"
#~ msgstr ""

#~ msgid "The name of the memory pool"
#~ msgstr ""

#~ msgid "describes which targets could access the pool"
#~ msgstr ""

#~ msgid "The properties of the pool."
#~ msgstr ""

#~ msgid "Name of constructor (only a hint)."
#~ msgstr ""

#~ msgid "Input types."
#~ msgstr ""

#~ msgid "Denotes which ADT the constructor belongs to."
#~ msgstr ""

#~ msgid ""
#~ "We can informally write them as: "
#~ "`forall (type_params), (arg_types) -> ret_type"
#~ " where type_constraints`"
#~ msgstr ""

#~ msgid "The type parameters"
#~ msgstr ""

#~ msgid "The type constraints."
#~ msgstr ""

#~ msgid ""
#~ "The name of the type variable. "
#~ "This name only acts as a hint, "
#~ "and is not used for equality."
#~ msgstr ""

#~ msgid "The kind of the type parameter."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`astext <tvm.ir.GlobalVar.astext>`\\ "
#~ "\\(\\[show\\_meta\\_data\\, annotate\\]\\)"
#~ msgstr ""

#~ msgid "Get the text format of the expression."
#~ msgstr ""

#~ msgid "Whether to include meta data section in the text if there is meta data."
#~ msgstr ""

#~ msgid ""
#~ "Optionally annotate function to provide "
#~ "additional information in the comment "
#~ "block."
#~ msgstr ""

#~ msgid "**text** -- The text format of the expression."
#~ msgstr ""

#~ msgid "备注"
#~ msgstr ""

#~ msgid ""
#~ "The meta data section is necessary "
#~ "to fully parse the text format. "
#~ "However, it can contain dumps that "
#~ "are big (e.g constant weights), so "
#~ "it can be helpful to skip printing"
#~ " the meta data section."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`astext <tvm.ir.IRModule.astext>`\\ "
#~ "\\(\\[show\\_meta\\_data\\, annotate\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`from_expr <tvm.ir.IRModule.from_expr>`\\ "
#~ "\\(expr\\[\\, functions\\, type\\_defs\\]\\)"
#~ msgstr ""

#~ msgid ":py:obj:`get_constructor <tvm.ir.IRModule.get_constructor>`\\ \\(tag\\)"
#~ msgstr ""

#~ msgid "Look up an ADT constructor by tag."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`get_global_type_var "
#~ "<tvm.ir.IRModule.get_global_type_var>`\\ \\(name\\)"
#~ msgstr ""

#~ msgid "Get a global type variable in the function by name."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`get_global_type_vars "
#~ "<tvm.ir.IRModule.get_global_type_vars>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Collect all global type vars defined in this module."
#~ msgstr ""

#~ msgid "Map of global type vars to type definitions"
#~ msgstr ""

#~ msgid "The tag for a constructor."
#~ msgstr ""

#~ msgid "**constructor** -- The constructor associated with the given tag,"
#~ msgstr ""

#~ msgid "The name of the global type variable."
#~ msgstr ""

#~ msgid "**global_type_var** -- The global variable mapped to :code:`name`."
#~ msgstr ""

#~ msgid "**global_type_vars** -- An array of global type vars."
#~ msgstr ""

#~ msgid "kind"
#~ msgstr ""

#~ msgid "Optional[TypeKind]"
#~ msgstr ""

#~ msgid "The kind of the incomplete type."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`add_type_rel <tvm.ir.Op.add_type_rel>`\\ "
#~ "\\(rel\\_name\\[\\, type\\_rel\\_func\\]\\)"
#~ msgstr ""

#~ msgid "Attach the type function corresponding to the return type."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`astext <tvm.ir.Op.astext>`\\ "
#~ "\\(\\[show\\_meta\\_data\\, annotate\\]\\)"
#~ msgstr ""

#~ msgid "The type relation name to register."
#~ msgstr ""

#~ msgid ""
#~ "The backing relation function which can"
#~ " solve an arbitrary relation on "
#~ "variables. Differences with type_rel_func in"
#~ " C++:  1) When type_rel_func is not"
#~ " None     a) OpAddTypeRel on C++ side"
#~ " will adjust type_rel_func with "
#~ "TypeReporter to       calling convention of"
#~ " relay type system.     b) type_rel_func"
#~ " returns output argument's type, return "
#~ "None means can't       infer output's "
#~ "type.     c) only support single output"
#~ " operators for now, the last argument"
#~ " is output tensor.  2) when "
#~ "type_rel_func is None, will call "
#~ "predefined type_rel_funcs in relay        "
#~ "according to ``tvm.relay.type_relation.`` + "
#~ "rel_name."
#~ msgstr ""

#~ msgid ""
#~ "The backing relation function which can"
#~ " solve an arbitrary relation on "
#~ "variables. Differences with type_rel_func in"
#~ " C++:"
#~ msgstr ""

#~ msgid "When type_rel_func is not None"
#~ msgstr ""

#~ msgid ""
#~ "OpAddTypeRel on C++ side will adjust "
#~ "type_rel_func with TypeReporter to calling "
#~ "convention of relay type system."
#~ msgstr ""

#~ msgid ""
#~ "type_rel_func returns output argument's type,"
#~ " return None means can't infer "
#~ "output's type."
#~ msgstr ""

#~ msgid ""
#~ "only support single output operators for"
#~ " now, the last argument is output "
#~ "tensor."
#~ msgstr ""

#~ msgid ""
#~ "when type_rel_func is None, will call"
#~ " predefined type_rel_funcs in relay"
#~ msgstr ""

#~ msgid "according to ``tvm.relay.type_relation.`` + rel_name."
#~ msgstr ""

#~ msgid ""
#~ "PoolInfo object holds information related "
#~ "to memory pools where the statically "
#~ "sized allocate nodes will pooled into."
#~ " This is a base class for "
#~ "WorkspacePoolInfo and ConstantPoolInfo."
#~ msgstr ""

#~ msgid ""
#~ "The expected size hint to be used"
#~ " by the allocator. The default value"
#~ " would be -1 which means the "
#~ "pool is not size restricted."
#~ msgstr ""

#~ msgid ""
#~ "The clock frequency that the memory "
#~ "pool runs at in Hz. If not "
#~ "specified/known, this will default to -1"
#~ " indicating it hasn't been defined."
#~ msgstr ""

#~ msgid ""
#~ "The read bandwidth of the memory "
#~ "pool in bytes/cycle. If not "
#~ "specified/known, this will default to -1"
#~ " indicating it hasn't been defined."
#~ msgstr ""

#~ msgid ""
#~ "The write bandwidth of the memory "
#~ "pool in bytes/cycle. If not "
#~ "specified/known, this will default to -1"
#~ " indicating it hasn't been defined."
#~ msgstr ""

#~ msgid ""
#~ "The read latency of the memory "
#~ "pool in cycles. If not specified/known,"
#~ " this will default to 0."
#~ msgstr ""

#~ msgid ""
#~ "The write latency of the memory "
#~ "pool in cycles. If not specified/known,"
#~ " this will default to 0."
#~ msgstr ""

#~ msgid ""
#~ "The burst length of the memory "
#~ "pool in bytes per target. If not"
#~ " specified/known for a given target, "
#~ "a burst length of 1 byte will "
#~ "be assumed."
#~ msgstr ""

#~ msgid ":py:obj:`checked_type <tvm.ir.RelayExpr.checked_type>`\\"
#~ msgstr ""

#~ msgid "Get the checked type of tvm.relay.Expr."
#~ msgstr ""

#~ msgid ":py:obj:`struct_info <tvm.ir.RelayExpr.struct_info>`\\"
#~ msgstr ""

#~ msgid "The value type."
#~ msgstr ""

#~ msgid "The real space value is calculated as x = x_q * scale + zero_point"
#~ msgstr ""

#~ msgid "The scale"
#~ msgstr ""

#~ msgid "The zero_point"
#~ msgstr ""

#~ msgid "The content data type."
#~ msgstr ""

#~ msgid "The axis for per-channel quantization."
#~ msgstr ""

#~ msgid ""
#~ "This is the type assigned to "
#~ "tensors with a known dtype and "
#~ "shape. For example, a tensor of "
#~ "`float32` and `(5, 5)`."
#~ msgstr ""

#~ msgid "The shape of the Tensor"
#~ msgstr ""

#~ msgid ":py:obj:`concrete_shape <tvm.ir.TensorType.concrete_shape>`\\"
#~ msgstr ""

#~ msgid "Get shape of the type as concrete tuple of int."
#~ msgstr ""

#~ msgid "**shape** -- The concrete shape of the Type."
#~ msgstr ""

#~ msgid ":raises TypeError : If the shape is symbolic:"
#~ msgstr ""

#~ msgid "Compares two Relay types by referential equality."
#~ msgstr ""

#~ msgid "The function."
#~ msgstr ""

#~ msgid "The arguments."
#~ msgstr ""

#~ msgid "**type_call** -- The type function application."
#~ msgstr ""

#~ msgid ""
#~ "Note that ADT definitions are treated"
#~ " as type-level functions because the"
#~ " type parameters need to be given "
#~ "for an instance of the ADT. Thus,"
#~ " any global type var that is an"
#~ " ADT header needs to be wrapped "
#~ "in a type call that passes in "
#~ "the type params."
#~ msgstr ""

#~ msgid ""
#~ "The name of the ADT. ADTs with "
#~ "the same constructors but different "
#~ "names are treated as different types."
#~ msgstr ""

#~ msgid "Type variables that appear in constructors."
#~ msgstr ""

#~ msgid "The constructors for the ADT."
#~ msgstr ""

#~ msgid "TypeRelation is more generalized than TypeCall as it allows inference"
#~ msgstr ""

#~ msgid "of both inputs and outputs."
#~ msgstr ""

#~ msgid "User defined relation function."
#~ msgstr ""

#~ msgid "List of types to the func."
#~ msgstr ""

#~ msgid ""
#~ "Number of input arguments in args, "
#~ "this act as a hint for type "
#~ "inference."
#~ msgstr ""

#~ msgid "The attribute attached to the relation information"
#~ msgstr ""

#~ msgid "**type_relation** -- The type relation."
#~ msgstr ""

#~ msgid ""
#~ "A type variable represents a type "
#~ "placeholder which will be filled in "
#~ "later on. This allows the user to"
#~ " write functions which are generic "
#~ "over types."
#~ msgstr ""

#~ msgid "A list of targets which could access the pool"
#~ msgstr ""

#~ msgid ""
#~ "Vars(tir::Var, TypeVar) and non-constant "
#~ "relay expression nodes are graph nodes."
#~ " For example, it means that `%1 "
#~ "= %x + %y; %1 + %1` is "
#~ "not structurally equal to `%1 = %x"
#~ " + %y; %2 = %x + %y; %1"
#~ " + %2` in relay."
#~ msgstr ""

#~ msgid ""
#~ "A var-type node(e.g. tir::Var, TypeVar)"
#~ " can be mapped as equal to "
#~ "another var with the same type if"
#~ " one of the following condition "
#~ "holds:"
#~ msgstr ""

#~ msgid "Common data structures across all IR variants."
#~ msgstr ""

#~ msgid "**Classes:**"
#~ msgstr ""

#~ msgid ":py:obj:`Array <tvm.ir.Array>`\\"
#~ msgstr ""

#~ msgid "Array container of TVM."
#~ msgstr ""

#~ msgid ":py:obj:`Attrs <tvm.ir.Attrs>`\\"
#~ msgstr ""

#~ msgid ""
#~ "Attribute node, which is mainly use "
#~ "for defining attributes of operators."
#~ msgstr ""

#~ msgid ":py:obj:`BaseExpr <tvm.ir.BaseExpr>`\\"
#~ msgstr ""

#~ msgid "Base class of all the expressions."
#~ msgstr ""

#~ msgid ":py:obj:`BaseFunc <tvm.ir.BaseFunc>`\\"
#~ msgstr ""

#~ msgid "Base class of all functions."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`CallingConv <tvm.ir.CallingConv>`\\ "
#~ "\\(value\\[\\, names\\, module\\, ...\\]\\)"
#~ msgstr ""

#~ msgid "Possible kinds of calling conventions."
#~ msgstr ""

#~ msgid ":py:obj:`DictAttrs <tvm.ir.DictAttrs>`\\"
#~ msgstr ""

#~ msgid "Dictionary attributes."
#~ msgstr ""

#~ msgid ":py:obj:`DummyGlobalInfo <tvm.ir.DummyGlobalInfo>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ":py:obj:`EnvFunc <tvm.ir.EnvFunc>`\\"
#~ msgstr ""

#~ msgid "Environment function."
#~ msgstr ""

#~ msgid ":py:obj:`FuncType <tvm.ir.FuncType>`\\ \\(arg\\_types\\, ret\\_type\\)"
#~ msgstr ""

#~ msgid "Function type."
#~ msgstr ""

#~ msgid ":py:obj:`GlobalInfo <tvm.ir.GlobalInfo>`\\"
#~ msgstr ""

#~ msgid "Base node for all global info that can appear in the IR"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`GlobalVar <tvm.ir.GlobalVar>`\\ "
#~ "\\(name\\_hint\\[\\, type\\_annot\\]\\)"
#~ msgstr ""

#~ msgid "A global variable in the IR."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`IRModule <tvm.ir.IRModule>`\\ \\(\\[functions\\,"
#~ " attrs\\, global\\_infos\\]\\)"
#~ msgstr ""

#~ msgid "IRModule that holds functions and type definitions."
#~ msgstr ""

#~ msgid ":py:obj:`Map <tvm.ir.Map>`\\"
#~ msgstr ""

#~ msgid "Map container of TVM."
#~ msgstr ""

#~ msgid ":py:obj:`Node <tvm.ir.Node>`\\"
#~ msgstr ""

#~ msgid "Base class of all IR Nodes."
#~ msgstr ""

#~ msgid ":py:obj:`Op <tvm.ir.Op>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Primitive operator in the IR."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`PointerType <tvm.ir.PointerType>`\\ "
#~ "\\(element\\_type\\[\\, storage\\_scope\\]\\)"
#~ msgstr ""

#~ msgid "PointerType used in the low-level TIR."
#~ msgstr ""

#~ msgid ":py:obj:`PrimExpr <tvm.ir.PrimExpr>`\\"
#~ msgstr ""

#~ msgid "Base class of all primitive expressions."
#~ msgstr ""

#~ msgid ":py:obj:`PrimType <tvm.ir.PrimType>`\\ \\(dtype\\)"
#~ msgstr ""

#~ msgid "Primitive data type in the low level IR"
#~ msgstr ""

#~ msgid ":py:obj:`Range <tvm.ir.Range>`\\ \\(begin\\[\\, end\\, span\\]\\)"
#~ msgstr ""

#~ msgid "Represent a range in TVM."
#~ msgstr ""

#~ msgid ":py:obj:`RelaxExpr <tvm.ir.RelaxExpr>`\\"
#~ msgstr ""

#~ msgid "Base class of all non-primitive expressions."
#~ msgstr ""

#~ msgid ":py:obj:`SequentialSpan <tvm.ir.SequentialSpan>`\\ \\(spans\\)"
#~ msgstr ""

#~ msgid "A sequence of source spans"
#~ msgstr ""

#~ msgid ":py:obj:`SourceName <tvm.ir.SourceName>`\\ \\(name\\)"
#~ msgstr ""

#~ msgid "A identifier for a source location."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`Span <tvm.ir.Span>`\\ \\(source\\_name\\, "
#~ "line\\, end\\_line\\, column\\, ...\\)"
#~ msgstr ""

#~ msgid "Specifies a location in a source program."
#~ msgstr ""

#~ msgid ":py:obj:`TupleType <tvm.ir.TupleType>`\\ \\(fields\\)"
#~ msgstr ""

#~ msgid "The type of tuple values."
#~ msgstr ""

#~ msgid ":py:obj:`Type <tvm.ir.Type>`\\"
#~ msgstr ""

#~ msgid "The base class of all types."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`VDevice <tvm.ir.VDevice>`\\ \\(\\[target\\, "
#~ "vdevice\\_id\\, memory\\_scope\\]\\)"
#~ msgstr ""

#~ msgid "**Functions:**"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`assert_structural_equal "
#~ "<tvm.ir.assert_structural_equal>`\\ \\(lhs\\, rhs\\[\\,"
#~ " ...\\]\\)"
#~ msgstr ""

#~ msgid "Assert lhs and rhs are structurally equal to each other."
#~ msgstr ""

#~ msgid ":py:obj:`load_json <tvm.ir.load_json>`\\ \\(json\\_str\\)"
#~ msgstr ""

#~ msgid "Load tvm object from json_str."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`make_node <tvm.ir.make_node>`\\ \\(type\\_key\\,"
#~ " \\*\\*kwargs\\)"
#~ msgstr ""

#~ msgid "Make a new IR node by its type key and fields"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`register_intrin_lowering "
#~ "<tvm.ir.register_intrin_lowering>`\\ \\(op\\_name\\, "
#~ "target\\, \\*\\)"
#~ msgstr ""

#~ msgid "Register Op lowering function"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`register_op_attr <tvm.ir.register_op_attr>`\\ "
#~ "\\(op\\_name\\, attr\\_key\\[\\, value\\, ...\\]\\)"
#~ msgstr ""

#~ msgid "Register an operator property of an operator by name."
#~ msgstr ""

#~ msgid ":py:obj:`save_json <tvm.ir.save_json>`\\ \\(node\\)"
#~ msgstr ""

#~ msgid "Save tvm object as json string."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`structural_equal <tvm.ir.structural_equal>`\\ "
#~ "\\(lhs\\, rhs\\[\\, map\\_free\\_vars\\]\\)"
#~ msgstr ""

#~ msgid "Check structural equality of lhs and rhs."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`structural_hash <tvm.ir.structural_hash>`\\ "
#~ "\\(node\\[\\, map\\_free\\_vars\\]\\)"
#~ msgstr ""

#~ msgid "Compute structural hash of node"
#~ msgstr ""

#~ msgid ""
#~ "You do not need to create Array"
#~ " explicitly. Normally python list and "
#~ "tuple will be converted automatically to"
#~ " Array during tvm function call. You"
#~ " may get Array in return values "
#~ "of TVM function call."
#~ msgstr ""

#~ msgid ""
#~ "Used by function registered in python"
#~ " side, such as compute, schedule and"
#~ " alter_layout. Attrs is passed as the"
#~ " first argument to these functions."
#~ msgstr ""

#~ msgid "**Methods:**"
#~ msgstr ""

#~ msgid ":py:obj:`get_int <tvm.ir.Attrs.get_int>`\\ \\(key\\)"
#~ msgstr ""

#~ msgid "Get a python int value of a key"
#~ msgstr ""

#~ msgid ":py:obj:`get_int_tuple <tvm.ir.Attrs.get_int_tuple>`\\ \\(key\\)"
#~ msgstr ""

#~ msgid "Get a python int tuple of a key"
#~ msgstr ""

#~ msgid ":py:obj:`get_str <tvm.ir.Attrs.get_str>`\\ \\(key\\)"
#~ msgstr ""

#~ msgid ":py:obj:`keys <tvm.ir.Attrs.keys>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Get list of names in the attribute."
#~ msgstr ""

#~ msgid ":py:obj:`list_field_info <tvm.ir.Attrs.list_field_info>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Get fields information"
#~ msgstr ""

#~ msgid "参数"
#~ msgstr ""

#~ msgid "返回"
#~ msgstr ""

#~ msgid "**value**"
#~ msgstr ""

#~ msgid "返回类型"
#~ msgstr ""

#~ msgid "**keys** -- List of keys"
#~ msgstr ""

#~ msgid "**infos** -- List of field information"
#~ msgstr ""

#~ msgid "**Attributes:**"
#~ msgstr ""

#~ msgid ":py:obj:`attrs <tvm.ir.BaseFunc.attrs>`\\"
#~ msgstr ""

#~ msgid "Return the attrs member of the function."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`with_attr <tvm.ir.BaseFunc.with_attr>`\\ "
#~ "\\(attr\\_key\\_or\\_dict\\[\\, attr\\_value\\]\\)"
#~ msgstr ""

#~ msgid "Create a new copy of the function and update the attribute."
#~ msgstr ""

#~ msgid ":py:obj:`with_attrs <tvm.ir.BaseFunc.with_attrs>`\\ \\(attr\\_map\\)"
#~ msgstr ""

#~ msgid "Copy the IRModule and add the given attribute map to it."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`without_attr <tvm.ir.BaseFunc.without_attr>`\\ "
#~ "\\(attr\\_key\\)"
#~ msgstr ""

#~ msgid ""
#~ "Create a new copy of the function"
#~ " with an attribute without provided "
#~ "key."
#~ msgstr ""

#~ msgid "The attribute key to use or a dict containing multiple key value pairs."
#~ msgstr ""

#~ msgid "The new attribute value."
#~ msgstr ""

#~ msgid "**func** -- A new copy of the function"
#~ msgstr ""

#~ msgid ""
#~ "Copy the IRModule and add the "
#~ "given attribute map to it. :param "
#~ "attr_map: The attribute map :type "
#~ "attr_map: Union[DictAttrs, Dict[str, Object]]"
#~ msgstr ""

#~ msgid "The attribute key to delete from the attrubte pairs."
#~ msgstr ""

#~ msgid ":py:obj:`get <tvm.ir.DictAttrs.get>`\\ \\(key\\[\\, default\\]\\)"
#~ msgstr ""

#~ msgid "Get an element with a default value."
#~ msgstr ""

#~ msgid ":py:obj:`items <tvm.ir.DictAttrs.items>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Get items from the map."
#~ msgstr ""

#~ msgid ":py:obj:`keys <tvm.ir.DictAttrs.keys>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "This is a global function object that can be serialized by its name."
#~ msgstr ""

#~ msgid ":py:obj:`get <tvm.ir.EnvFunc.get>`\\ \\(name\\)"
#~ msgstr ""

#~ msgid "Get a static env function"
#~ msgstr ""

#~ msgid "The name of the function."
#~ msgstr ""

#~ msgid ""
#~ "A function type consists of a list"
#~ " of type parameters to enable the "
#~ "definition of generic functions, a set"
#~ " of type constraints which we omit"
#~ " for the time being, a sequence "
#~ "of argument types, and a return "
#~ "type."
#~ msgstr ""

#~ msgid "The argument types"
#~ msgstr ""

#~ msgid "The return type."
#~ msgstr ""

#~ msgid ":py:obj:`same_as <tvm.ir.GlobalInfo.same_as>`\\ \\(other\\)"
#~ msgstr ""

#~ msgid "Overload with structural equality."
#~ msgstr ""

#~ msgid ""
#~ "GlobalVar is used to refer to the"
#~ " global functions stored in the "
#~ "IRModule."
#~ msgstr ""

#~ msgid "The name of the variable."
#~ msgstr ""

#~ msgid "IRModule is the basic unit for all IR transformations across the stack."
#~ msgstr ""

#~ msgid "Map of global var to BaseFunc"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`from_expr <tvm.ir.IRModule.from_expr>`\\ "
#~ "\\(expr\\[\\, functions\\]\\)"
#~ msgstr ""

#~ msgid "Construct a module from a standalone expression."
#~ msgstr ""

#~ msgid ":py:obj:`functions_items <tvm.ir.IRModule.functions_items>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Get items in self.functions.items() in alphabetical order."
#~ msgstr ""

#~ msgid ":py:obj:`get_attr <tvm.ir.IRModule.get_attr>`\\ \\(attr\\_key\\)"
#~ msgstr ""

#~ msgid "Get the IRModule attribute."
#~ msgstr ""

#~ msgid ":py:obj:`get_global_var <tvm.ir.IRModule.get_global_var>`\\ \\(name\\)"
#~ msgstr ""

#~ msgid "Get a global variable in the function by name."
#~ msgstr ""

#~ msgid ":py:obj:`get_global_vars <tvm.ir.IRModule.get_global_vars>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Collect all global vars defined in this module."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`replace_global_vars "
#~ "<tvm.ir.IRModule.replace_global_vars>`\\ \\(replacements\\)"
#~ msgstr ""

#~ msgid "Replace GlobalVar instances within the module"
#~ msgstr ""

#~ msgid ":py:obj:`update <tvm.ir.IRModule.update>`\\ \\(other\\)"
#~ msgstr ""

#~ msgid "Insert functions in another Module to current one."
#~ msgstr ""

#~ msgid ":py:obj:`update_func <tvm.ir.IRModule.update_func>`\\ \\(var\\, func\\)"
#~ msgstr ""

#~ msgid "Update the function corresponding to a global variable in the module."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`update_global_info "
#~ "<tvm.ir.IRModule.update_global_info>`\\ \\(name\\, "
#~ "global\\_info\\)"
#~ msgstr ""

#~ msgid "Update global info in the module"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`with_attr <tvm.ir.IRModule.with_attr>`\\ "
#~ "\\(attr\\_key\\, attr\\_value\\)"
#~ msgstr ""

#~ msgid "Copy the IRModule and add an attribute to it."
#~ msgstr ""

#~ msgid ":py:obj:`with_attrs <tvm.ir.IRModule.with_attrs>`\\ \\(attr\\_map\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`without_attr <tvm.ir.IRModule.without_attr>`\\ "
#~ "\\(attr\\_key\\)"
#~ msgstr ""

#~ msgid "Copy the IRModule and remove an attribute key and its associated value."
#~ msgstr ""

#~ msgid "The starting expression"
#~ msgstr ""

#~ msgid "Map of global vars to function definitions"
#~ msgstr ""

#~ msgid ""
#~ "**mod** -- A module containing the "
#~ "passed definitions, where expr is set"
#~ " as the entry point (wrapped in "
#~ "a function if necessary)"
#~ msgstr ""

#~ msgid "**items** -- The functions items."
#~ msgstr ""

#~ msgid "The attribute key."
#~ msgstr ""

#~ msgid "**attr_value** -- Attribute value"
#~ msgstr ""

#~ msgid "The name of the global variable."
#~ msgstr ""

#~ msgid "**global_var** -- The global variable mapped to :code:`name`."
#~ msgstr ""

#~ msgid "抛出"
#~ msgstr ""

#~ msgid "**global_vars** -- An array of global vars."
#~ msgstr ""

#~ msgid ""
#~ "Replace GlobalVars within the IRModule.  "
#~ "Since the IRModule may contain internal"
#~ " references to a GlobalVar, either in"
#~ " TIR or in Relax, this method "
#~ "should be used whenever replacing or "
#~ "renaming a GlobalVar."
#~ msgstr ""

#~ msgid ""
#~ "A dictionary where each key is a"
#~ " GlobalVar to be replaced, and the"
#~ " corresponding value is the GlobalVar "
#~ "with which to replace it."
#~ msgstr ""

#~ msgid "The updated module"
#~ msgstr ""

#~ msgid "The module to merge into the current Module."
#~ msgstr ""

#~ msgid "The global variable."
#~ msgstr ""

#~ msgid "The function to be inserted."
#~ msgstr ""

#~ msgid "The name for the global info."
#~ msgstr ""

#~ msgid "The global info to be updated."
#~ msgstr ""

#~ msgid "**mod** -- A new copy of the IRModule with the attribute"
#~ msgstr ""

#~ msgid ""
#~ "Copy the IRModule and remove an "
#~ "attribute key and its associated value."
#~ " :param attr_key: The attribute key. "
#~ ":type attr_key: str"
#~ msgstr ""

#~ msgid "**mod** -- A new copy of the IRModule without the attribute"
#~ msgstr ""

#~ msgid ""
#~ "You do not need to create Map "
#~ "explicitly. Normally python dict will be"
#~ " converted automatically to Map during "
#~ "tvm function call. You can use "
#~ "convert to create a dict[Object-> "
#~ "Object] into a Map"
#~ msgstr ""

#~ msgid ":py:obj:`get <tvm.ir.Map.get>`\\ \\(key\\[\\, default\\]\\)"
#~ msgstr ""

#~ msgid ":py:obj:`items <tvm.ir.Map.items>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Get the items from the map"
#~ msgstr ""

#~ msgid "The default object."
#~ msgstr ""

#~ msgid "**value** -- The result value."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`add_argument <tvm.ir.Op.add_argument>`\\ "
#~ "\\(name\\, type\\, description\\)"
#~ msgstr ""

#~ msgid "Add arguments information to the function."
#~ msgstr ""

#~ msgid ":py:obj:`get <tvm.ir.Op.get>`\\ \\(op\\_name\\)"
#~ msgstr ""

#~ msgid "Get the Op for a given name"
#~ msgstr ""

#~ msgid ":py:obj:`get_attr <tvm.ir.Op.get_attr>`\\ \\(attr\\_name\\)"
#~ msgstr ""

#~ msgid "Get additional attribute about the operator."
#~ msgstr ""

#~ msgid ":py:obj:`has_attr <tvm.ir.Op.has_attr>`\\ \\(attr\\_name\\)"
#~ msgstr ""

#~ msgid "Check whether the operator has additional attribute."
#~ msgstr ""

#~ msgid ":py:obj:`list_op_names <tvm.ir.Op.list_op_names>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "List all the op names in the op registry."
#~ msgstr ""

#~ msgid ":py:obj:`reset_attr <tvm.ir.Op.reset_attr>`\\ \\(attr\\_name\\)"
#~ msgstr ""

#~ msgid "Reset attribute about the operator."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`set_attr <tvm.ir.Op.set_attr>`\\ "
#~ "\\(attr\\_name\\, value\\[\\, plevel\\]\\)"
#~ msgstr ""

#~ msgid "Set attribute about the operator."
#~ msgstr ""

#~ msgid ":py:obj:`set_attrs_type_key <tvm.ir.Op.set_attrs_type_key>`\\ \\(key\\)"
#~ msgstr ""

#~ msgid "Set the attribute type key of op."
#~ msgstr ""

#~ msgid ":py:obj:`set_num_inputs <tvm.ir.Op.set_num_inputs>`\\ \\(n\\)"
#~ msgstr ""

#~ msgid "Set the support level of op."
#~ msgstr ""

#~ msgid ":py:obj:`set_support_level <tvm.ir.Op.set_support_level>`\\ \\(level\\)"
#~ msgstr ""

#~ msgid "The argument name."
#~ msgstr ""

#~ msgid "The argument type."
#~ msgstr ""

#~ msgid "The argument description."
#~ msgstr ""

#~ msgid "The operator name"
#~ msgstr ""

#~ msgid "**op** -- The op of the corresponding name"
#~ msgstr ""

#~ msgid "The attribute name."
#~ msgstr ""

#~ msgid "**value** -- The attribute value"
#~ msgstr ""

#~ msgid "**value** -- Whether the operator has additional attribute"
#~ msgstr ""

#~ msgid "**value** -- The registered op names"
#~ msgstr ""

#~ msgid "The attribute name"
#~ msgstr ""

#~ msgid "The attribute value"
#~ msgstr ""

#~ msgid "The priority level"
#~ msgstr ""

#~ msgid "The type key."
#~ msgstr ""

#~ msgid "The input number."
#~ msgstr ""

#~ msgid "The support level."
#~ msgstr ""

#~ msgid "The type of pointer's element."
#~ msgstr ""

#~ msgid "The storage scope into which the pointer addresses."
#~ msgstr ""

#~ msgid ""
#~ "PrimExpr is used in the low-level"
#~ " code optimizations and integer analysis."
#~ msgstr ""

#~ msgid "The runtime data type relates to the primtype."
#~ msgstr ""

#~ msgid ""
#~ "You do not need to create a "
#~ "Range explicitly. Python lists and "
#~ "tuples will be converted automatically "
#~ "to a Range in API functions."
#~ msgstr ""

#~ msgid ""
#~ "The begin value of the range when"
#~ " end is None. Otherwise it is "
#~ "the length of the range."
#~ msgstr ""

#~ msgid "The end value of the range."
#~ msgstr ""

#~ msgid "The location of this node in the source code."
#~ msgstr ""

#~ msgid ""
#~ "The constructor creates the range "
#~ "`[begin, end)` if the end argument "
#~ "is not None. Otherwise, it creates "
#~ "`[0, begin)`."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`from_min_extent <tvm.ir.Range.from_min_extent>`\\ "
#~ "\\(min\\_value\\, extent\\[\\, span\\]\\)"
#~ msgstr ""

#~ msgid "Construct a Range by min and extent."
#~ msgstr ""

#~ msgid "This constructs a range in [min_value, min_value + extent)"
#~ msgstr ""

#~ msgid "The minimum value of the range."
#~ msgstr ""

#~ msgid "The extent of the range."
#~ msgstr ""

#~ msgid "**rng** -- The constructed range."
#~ msgstr ""

#~ msgid ":py:obj:`checked_type <tvm.ir.RelaxExpr.checked_type>`\\"
#~ msgstr ""

#~ msgid "Get the checked type of tvm.relax.Expr."
#~ msgstr ""

#~ msgid ":py:obj:`struct_info <tvm.ir.RelaxExpr.struct_info>`\\"
#~ msgstr ""

#~ msgid "Get the struct info field"
#~ msgstr ""

#~ msgid "**checked_type** -- The checked type."
#~ msgstr ""

#~ msgid "**struct_info** -- The struct info if available."
#~ msgstr ""

#~ msgid ""
#~ "This span is specific for an "
#~ "expression, which is from multiple "
#~ "expressions after an IR transform."
#~ msgstr ""

#~ msgid "The array of spans."
#~ msgstr ""

#~ msgid "The name of the source."
#~ msgstr ""

#~ msgid "The source name."
#~ msgstr ""

#~ msgid "The line number."
#~ msgstr ""

#~ msgid "The column offset of the location."
#~ msgstr ""

#~ msgid "The fields in the tuple"
#~ msgstr ""

#~ msgid ":py:obj:`same_as <tvm.ir.Type.same_as>`\\ \\(other\\)"
#~ msgstr ""

#~ msgid "Compares two TVM types by referential equality."
#~ msgstr ""

#~ msgid "The left operand."
#~ msgstr ""

#~ msgid ""
#~ "Whether or not shall we map free"
#~ " vars that does not bound to "
#~ "any definitions as equal to each "
#~ "other."
#~ msgstr ""

#~ msgid ":raises ValueError : if assertion does not hold.:"
#~ msgstr ""

#~ msgid ":obj:`structural_equal`"
#~ msgstr ""

#~ msgid "The json string"
#~ msgstr ""

#~ msgid "**node** -- The loaded tvm node."
#~ msgstr ""

#~ msgid "The type key of the node."
#~ msgstr ""

#~ msgid "The fields of the node."
#~ msgstr ""

#~ msgid "**node** -- The corresponding IR Node"
#~ msgstr ""

#~ msgid ""
#~ "If the created node is instance of"
#~ " AttrsNode, then the creator function "
#~ "will also run bound checks and "
#~ "default value setup as supported by "
#~ "Attrs."
#~ msgstr ""

#~ msgid "示例"
#~ msgstr ""

#~ msgid "The following code constructs a IntImm object"
#~ msgstr ""

#~ msgid "The op name"
#~ msgstr ""

#~ msgid "The target string for given intrinsic lowering function"
#~ msgstr ""

#~ msgid "The function to be registered."
#~ msgstr ""

#~ msgid "**fregister** -- Register op lowering function if f is not specified."
#~ msgstr ""

#~ msgid "The name of operator"
#~ msgstr ""

#~ msgid "The value to set"
#~ msgstr ""

#~ msgid "**fregister** -- Register function if value is not specified."
#~ msgstr ""

#~ msgid "A TVM object to be saved."
#~ msgstr ""

#~ msgid "**json_str** -- Saved json string."
#~ msgstr ""

#~ msgid ""
#~ "The structural equality is recursively "
#~ "defined in the DAG of IRNodes. "
#~ "There are two kinds of nodes:"
#~ msgstr ""

#~ msgid ""
#~ "Graph node: a graph node in lhs"
#~ " can only be mapped as equal to"
#~ " one and only one graph node in"
#~ " rhs."
#~ msgstr ""

#~ msgid ""
#~ "Normal node: equality is recursively "
#~ "defined without the restriction of graph"
#~ " nodes."
#~ msgstr ""

#~ msgid "Vars(tir::Var, relax::Var) are graph nodes."
#~ msgstr ""

#~ msgid ""
#~ "A var-type node(e.g. tir::Var) can "
#~ "be mapped as equal to another var"
#~ " with the same type if one of"
#~ " the following condition holds:"
#~ msgstr ""

#~ msgid "They appear in a same definition point(e.g. function argument)."
#~ msgstr ""

#~ msgid "They points to the same VarNode via the same_as relation."
#~ msgstr ""

#~ msgid "They appear in a same usage point, and map_free_vars is set to be True."
#~ msgstr ""

#~ msgid ""
#~ "The rules for var are used to "
#~ "remap variables occurs in function "
#~ "arguments and let-bindings."
#~ msgstr ""

#~ msgid ""
#~ "Whether free variables (i.e. variables "
#~ "without a definition site) should be "
#~ "mapped as equal to each other."
#~ msgstr ""

#~ msgid "**result** -- The comparison result."
#~ msgstr ""

#~ msgid ":obj:`structural_hash`, :obj:`assert_strucural_equal`"
#~ msgstr ""

#~ msgid ""
#~ "The structural hash value is recursively"
#~ " defined in the DAG of IRNodes. "
#~ "There are two kinds of nodes:"
#~ msgstr ""

#~ msgid "Normal node: the hash value is defined by its content and type only."
#~ msgstr ""

#~ msgid ""
#~ "Graph node: each graph node will "
#~ "be assigned a unique index ordered "
#~ "by the first occurence during the "
#~ "visit. The hash value of a graph"
#~ " node is combined from the hash "
#~ "values of its contents and the "
#~ "index."
#~ msgstr ""

#~ msgid ""
#~ "structural_hash is made to be concistent"
#~ " with structural_equal. If two nodes "
#~ "are structurally equal to each other,"
#~ " then their structural hash (with the"
#~ " same map_free_vars option) should be "
#~ "equal to each other as well."
#~ msgstr ""

#~ msgid ""
#~ "If the structural hash of two "
#~ "nodes equals to each other, then "
#~ "it is highly likely(except for rare "
#~ "hash value collison cases) that the "
#~ "two nodes are structurally equal to "
#~ "each other."
#~ msgstr ""

#~ msgid "The input to be hashed."
#~ msgstr ""

#~ msgid ""
#~ "If map_free_vars is set to true, "
#~ "we will hash free variables by the"
#~ " order of their occurrences. Otherwise, "
#~ "we will hash by their in-memory"
#~ " pointer address."
#~ msgstr ""

#~ msgid "**result** -- The hash result"
#~ msgstr ""

#~ msgid ":obj:`structrual_equal`"
#~ msgstr ""

