# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, xinetzone
# This file is distributed under the same license as the tvm package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tvm doc\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-09 21:52+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../../doc/docs/reference/langref/relay_expr.rst:20
msgid "Expressions in Relay"
msgstr "Relay 表达式"

#: ../../doc/docs/reference/langref/relay_expr.rst:22
msgid ""
"The Relay IR is a pure, expression-oriented language. The below sections "
"describe the different expressions in Relay and give details of their "
"semantics."
msgstr ""
"Relay IR 是一种纯粹的、面向表达式的语言。以下部分描述了 Relay 中的不同表达式，并详细说明了它们的语义。"

#: ../../doc/docs/reference/langref/relay_expr.rst:26
msgid "Dataflow and Control Fragments"
msgstr "数据流和控制片段"

#: ../../doc/docs/reference/langref/relay_expr.rst:28
msgid ""
"For the purposes of comparing Relay to traditional computational graph-"
"based IRs, it can be useful to consider Relay expressions in terms of "
"dataflow and control fragments. Each portion of a Relay program "
"containing expressions that only affect the dataflow can be viewed as a "
"traditional computation graph when writing and expressing "
"transformations."
msgstr ""
"为了将 Relay 与传统基于计算图的中间表示（IRs）进行比较，从数据流和控制片段的角度来考虑 Relay 表达式是有益的。"
"当编写和表达变换时，Relay 程序中仅影响数据流的每个部分都可以被视为传统的计算图。"

#: ../../doc/docs/reference/langref/relay_expr.rst:33
msgid ""
"The dataflow fragment covers the set of Relay expressions that do not "
"involve control flow. That is, any portion of a program containing only "
"the following constructs corresponds to a pure computation graph:"
msgstr ""
"数据流片段涵盖了不涉及控制流的 Relay 表达式集合。也就是说，程序中仅包含以下结构的任何部分都对应于纯计算图："

#: ../../doc/docs/reference/langref/relay_expr.rst:37
msgid "`Variables`_"
msgstr "`变量`_"

#: ../../doc/docs/reference/langref/relay_expr.rst:38
msgid "Tuple `Construction`_ and `Projection`_"
msgstr "Tuple `Construction`_ 和 `Projection`_"

#: ../../doc/docs/reference/langref/relay_expr.rst:39
msgid "`Let Bindings`_"
msgstr ""

#: ../../doc/docs/reference/langref/relay_expr.rst:40
msgid "`Graph Bindings`_"
msgstr ""

#: ../../doc/docs/reference/langref/relay_expr.rst:41
msgid "Calls to `Operators`_ and `ADT Constructors`_"
msgstr "调用 `Operators`_ 和 `ADT Constructors`_"

#: ../../doc/docs/reference/langref/relay_expr.rst:43
msgid ""
"Control flow expressions allow the graph topology to change based on the "
"value of previously executed expressions. The control fragment in Relay "
"includes the following constructs:"
msgstr ""
"控制流表达式允许图拓扑根据先前执行的表达式的值进行更改。Relay 中的控制片段包括以下结构："

#: ../../doc/docs/reference/langref/relay_expr.rst:47
msgid "`If-Then-Else`_ Expressions"
msgstr "`If-Then-Else`_ 表达式"

#: ../../doc/docs/reference/langref/relay_expr.rst:48
msgid "`ADT Matching`_ Expressions"
msgstr "`ADT Matching`_ 表达式"

#: ../../doc/docs/reference/langref/relay_expr.rst:49
msgid "Recursive Calls in Functions"
msgstr "函数中的递归调用"

#: ../../doc/docs/reference/langref/relay_expr.rst:51
msgid ""
"From the point of view of a computation graph, a function is a subgraph "
"and a function call inlines the subgraph, substituting its arguments for "
"the free variables in the subgraph with corresponding names. Thus, if a "
"function's body uses only dataflow constructs, a call to that function is"
" in the dataflow fragment; conversely, if the function's body contains "
"control flow, a call to that function is not part of the dataflow "
"fragment."
msgstr ""
"从计算图的角度来看，函数是一个子图，而函数调用则内联该子图，将其参数替换为子图中具有相应名称的自由变量。"
"因此，如果函数体仅使用数据流结构，则对该函数的调用属于数据流片段；相反，如果函数体包含控制流，则对该函数的调用不属于数据流片段。"

#: ../../doc/docs/reference/langref/relay_expr.rst:57
msgid "Variables"
msgstr "变量"

#: ../../doc/docs/reference/langref/relay_expr.rst:59
msgid ""
"Inspired by LLVM, Relay explicitly distinguishes between local and global"
" variables both in the AST and in the text format. In the text format, "
"global and local variables are distinguished by prefixes, or *sigils*. "
"Global variables are prefixed with :code:`@` and local variables with "
":code:`%`."
msgstr ""
"受 LLVM 启发，Relay 在 AST 和文本格式中明确区分了局部变量和全局变量。"
"在文本格式中，全局变量和局部变量通过前缀或 *符号* 来区分。全局变量以 :code:`@` 为前缀，局部变量以 :code:`%` 为前缀。"

#: ../../doc/docs/reference/langref/relay_expr.rst:64
msgid ""
"This explicit distinction makes certain optimizations easier to "
"implement. For example, inlining a global definition requires no "
"analysis: simply substituting the definition suffices."
msgstr ""
"这种明确的区分使得某些优化更容易实现。例如，内联全局定义不需要进行分析：简单地替换定义就足够了。"

#: ../../doc/docs/reference/langref/relay_expr.rst:69
msgid "Global Variable"
msgstr "全局变量"

#: ../../doc/docs/reference/langref/relay_expr.rst:71
msgid ""
"Global identifiers are prefixed by the :code:`@` sigil, such as "
"\":code:`@global`\". A global identifier always references a globally "
"visible definition contained in the globally visible environment, known "
"as the `module <Module and Global Functions_>`__. Global identifiers must"
" be unique."
msgstr ""
"全局标识符以 :code:`@` 符号为前缀，例如 \":code:`@global`\"。"
"全局标识符始终引用包含在全局可见环境中的全局可见定义，称为 `模块 <Module and Global Functions_>`__。全局标识符必须是唯一的。"

#: ../../doc/docs/reference/langref/relay_expr.rst:76
msgid ""
"See :py:class:`~tvm.relay.expr.GlobalVar` for its implementation and "
"documentation."
msgstr ""
"请参阅 :py:class:`~tvm.relay.expr.GlobalVar` 了解其实现和文档。"

#: ../../doc/docs/reference/langref/relay_expr.rst:80
msgid "Local Variable"
msgstr "局部变量"

#: ../../doc/docs/reference/langref/relay_expr.rst:82
#, python-format
msgid ""
"Local identifiers are prefixed by the :code:`%` sigil, such as "
"\":code:`%local`\". A local identifier always references a function "
"argument or a variable bound in a :code:`let` expression, and will be "
"scoped to the function where it appears or the :code:`let` expression "
"where it is bound, respectively."
msgstr ""
"局部标识符以 :code:`%` 符号为前缀，例如 \":code:`%local`\"。局部标识符始终引用函数参数或在 :code:`let` 表达式中绑定的变量，并且分别限定在它出现的函数或绑定的 :code:`let` 表达式的作用域内。"

#: ../../doc/docs/reference/langref/relay_expr.rst:88
msgid ""
"In the below code segment, notice that :code:`%a` is defined twice. This "
"is permitted, as in most functional languages; in the scope of the second"
" :code:`let` expression, the name :code:`%a` is \"shadowed,\" meaning all"
" references to :code:`%a` in the inner scope refer to the later "
"definition, while references to :code:`%a` in the outer scope continue to"
" refer to the first one."
msgstr ""
"在下面的代码段中，请注意 :code:`%a` 被定义了两次。"
"这是允许的，就像在大多数函数式语言中一样；在第二个 :code:`let` 表达式的作用域内，名称 :code:`%a` 被“遮蔽”了，"
"这意味着内部作用域中对 :code:`%a` 的所有引用都指向后面的定义，而外部作用域中对 :code:`%a` 的引用仍然指向第一个定义。"

#: ../../doc/docs/reference/langref/relay_expr.rst:102
msgid ""
"(Note that in Relay's implementation, each definition of a local variable"
" creates a new :py:class:`~tvm.relay.expr.Var`, so a shadowed local "
"variable, despite having the same name as one in an outer scope, will be "
"a different object. This allows for comparing local variables by pointer "
"identity with the knowledge that the same local variable object "
"corresponds to a different binding site.)"
msgstr ""
"（请注意，在 Relay 的实现中，每个局部变量的定义都会创建新的 :py:class:`~tvm.relay.expr.Var`，因此尽管被遮蔽的局部变量与外部作用域中的变量同名，但它将是不同的对象。"
"这使得可以通过指针标识来比较局部变量，并确保相同的局部变量对象对应于不同的绑定位置。）"

#: ../../doc/docs/reference/langref/relay_expr.rst:108
msgid ""
"See :py:class:`~tvm.relay.expr.Var` for its implementation and "
"documentation."
msgstr ""
"请参阅 :py:class:`~tvm.relay.expr.Var` 了解其实现和文档。"

#: ../../doc/docs/reference/langref/relay_expr.rst:112
msgid "Functions"
msgstr "函数"

#: ../../doc/docs/reference/langref/relay_expr.rst:114
msgid ""
"Functions in Relay act similarly to procedures or functions in other "
"programming languages and serve to generalize the concept of a named "
"subgraph."
msgstr ""
"Relay 中的函数与其他编程语言中的过程或函数类似，用于泛化命名子图的概念。"

#: ../../doc/docs/reference/langref/relay_expr.rst:118
msgid ""
"Functions are first class in Relay, which means they are expressions just"
" like variables, constants, and tuples. Additionally, functions in Relay "
"are higher-order, which means that a function can be passed as an "
"argument to a function or returned by a function, as function expressions"
" evaluate to closures (see the `Closures`_ subsection), which are values "
"like tensors and tuples."
msgstr ""
"函数在 Relay 中是一等公民，这意味着它们像变量、常量和元组一样是表达式。"
"此外，Relay 中的函数是高阶的，这意味着函数可以作为参数传递给另一个函数，或者由函数返回，因为函数表达式会求值为闭包（参见 `Closures`_ 小节），闭包就像张量和元组一样是值。"

#: ../../doc/docs/reference/langref/relay_expr.rst:123
msgid ""
"See :py:class:`~tvm.relay.function.Function` for the definition and "
"documentation of function nodes."
msgstr ""
"请参阅 :py:class:`~tvm.relay.function.Function` 了解函数节点的定义和文档。"

#: ../../doc/docs/reference/langref/relay_expr.rst:126
msgid "Syntax"
msgstr "语法"

#: ../../doc/docs/reference/langref/relay_expr.rst:128
msgid ""
"A definition minimally consists of the keyword :code:`fn`, an empty set "
"of parameters, and a body expression (:py:class:`~tvm.relay.expr.Expr`) "
"contained by curly braces."
msgstr ""
"定义至少包含关键字 :code:`fn`、空的参数集以及由花括号括起来的体表达式（:py:class:`~tvm.relay.expr.Expr`）。"

#: ../../doc/docs/reference/langref/relay_expr.rst:136
msgid ""
"A definition may contain any number of parameters. For example, a simple "
"function that invokes the :code:`add` operator:"
msgstr ""
"定义可以包含任意数量的参数。例如，调用 :code:`add` 算子的简单函数："

#: ../../doc/docs/reference/langref/relay_expr.rst:143
msgid ""
"Notice that within the function's body, the parameters are local "
"variables, just like those bound in a :code:`let` expression."
msgstr ""
"请注意，在函数体内，参数是局部变量，就像在 :code:`let` 表达式中绑定的变量一样。"

#: ../../doc/docs/reference/langref/relay_expr.rst:146
msgid ""
"One may also annotate explicit types on functions. For example, we can "
"restrict the above function to only work on certain types:"
msgstr ""
"还可以为函数添加显式类型注解。例如，可以将上述函数限制为仅适用于某些类型："

#: ../../doc/docs/reference/langref/relay_expr.rst:157
#, python-format
msgid ""
"The above function only takes arguments of type :code:`Tensor[(10, 10), "
"float32]` and returns a value of type :code:`Tensor[(10, 10), float32]`. "
"A function parameter is just a local variable "
"(:py:class:`~tvm.relay.expr.LocalVar`) optionally annotated with a type, "
"written as :code:`%x : T`."
msgstr ""
"上述函数仅接受类型为 :code:`Tensor[(10, 10), float32]` 的参数，并返回类型为 :code:`Tensor[(10, 10), float32]` 的值。"
"函数参数只是可选地带有类型注解的局部变量（:py:class:`~tvm.relay.expr.LocalVar`），写作 :code:`%x : T`。"

#: ../../doc/docs/reference/langref/relay_expr.rst:161
msgid ""
"When the type information is omitted, Relay attempts to infer the most "
"general type for the users. This property is known as generalization: for"
" a definition without explicit annotations, Relay attempts to assign the "
"most general type to the parameters and return type based on the function"
" body and call sites."
msgstr ""
"当省略类型信息时，Relay 会尝试为用户推断最通用的类型。这一特性被称为泛化：对于没有显式注解的定义，Relay 会尝试根据函数体和调用位置为参数和返回类型分配最通用的类型。"

#: ../../doc/docs/reference/langref/relay_expr.rst:166
msgid ""
"A recursive function expression can be defined using a :code:`let` "
"binding, as here:"
msgstr ""
"可以使用 :code:`let` 绑定来定义递归函数表达式，如下所示："

#: ../../doc/docs/reference/langref/relay_expr.rst:181
msgid "Closures"
msgstr "闭包"

#: ../../doc/docs/reference/langref/relay_expr.rst:183
msgid ""
"A function expression evaluates to a closure. Closures are values that "
"are represented as a pair of a local environment (storing the values for "
"all variables defined outside the scope of the function's body) and the "
"function itself."
msgstr ""
"函数表达式求值为闭包。闭包是表示为局部环境（存储函数体外部定义的所有变量的值）和函数本身这对组合的值。"

#: ../../doc/docs/reference/langref/relay_expr.rst:188
#, python-format
msgid ""
"For example, in the below example, the final result will be a tensor of "
"zero values because the closure for :code:`%f` stores the value of "
":code:`%x` at the pointer where :code:`%f` was defined."
msgstr ""
"例如，在下面的示例中，最终结果将是零值张量，因为 :code:`%f` 的闭包存储了 :code:`%x` 在定义 :code:`%f` 时的指针处的值。"

#: ../../doc/docs/reference/langref/relay_expr.rst:206
msgid "Polymorphism and Type Relations"
msgstr "多态性与类型关系"

#: ../../doc/docs/reference/langref/relay_expr.rst:208
msgid "*Note: type parameter syntax is not yet supported in the text format.*"
msgstr "*注意：文本格式中尚不支持类型参数语法。*"

#: ../../doc/docs/reference/langref/relay_expr.rst:210
msgid ""
"A function may also be given a set of type parameters, which can be "
"substituted for specific types at call sites. Functions with type "
"parameters are *type polymorphic*; their return type or the types of "
"arguments they will accept can vary based on the type arguments given at "
"call sites."
msgstr ""
"函数还可以被赋予一组类型参数，这些参数可以在调用位置替换为特定类型。具有类型参数的函数是 *类型多态* 的；它们的返回类型或接受的参数类型可以根据调用位置提供的类型参数而变化。"

#: ../../doc/docs/reference/langref/relay_expr.rst:216
msgid ""
"Type parameters are classified by *kind* and can only appear in parts of "
"the type signature where their kind is appropriate (e.g., type parameters"
" of kind :code:`Shape` can only appear where a shape would be expected in"
" a tensor type); for a full discussion, see :ref:`the documentation on "
"type parameters <type-parameter>`."
msgstr ""
"类型参数按 *种类* 分类，并且只能出现在类型签名中其种类适用的部分（例如，种类为 :code:`Shape` 的类型参数只能出现在张量类型中期望形状的位置）；完整讨论请参见 :ref:`关于类型参数的文档 <type-parameter>`。"

#: ../../doc/docs/reference/langref/relay_expr.rst:222
msgid ""
"For example, one can define a polymorphic identity function for any Relay"
" type as follows:"
msgstr ""
"例如，可以为任何 Relay 类型定义多态恒等函数，如下所示："

#: ../../doc/docs/reference/langref/relay_expr.rst:231
msgid ""
"The below definition is also polymorphic, but restricts its arguments to "
"tensor types:"
msgstr ""
"以下定义也是多态的，但将其参数限制为张量类型："

#: ../../doc/docs/reference/langref/relay_expr.rst:240
msgid "Notice that the return type is omitted and will be inferred."
msgstr "请注意，返回类型被省略了，将会被推断出来。"

#: ../../doc/docs/reference/langref/relay_expr.rst:242
msgid "*Note: \"where\" syntax is not yet supported in the text format.*"
msgstr "*注意：文本格式中尚不支持 \"where\" 语法。*"

#: ../../doc/docs/reference/langref/relay_expr.rst:244
msgid ""
"A function may also be subject to one or more type relations, such as in "
"the following:"
msgstr ""
"函数还可能受到一个或多个类型关系的约束，例如以下情况："

#: ../../doc/docs/reference/langref/relay_expr.rst:251
#, python-format
msgid ""
"In the above definition, the types of :code:`%x` and :code:`%y` and the "
"return type are subject to the :code:`Broadcast` relation, meaning all "
"three must be tensors and their shapes follow the elementwise broadcast "
"relation. As with operators, the definitions of relations are not "
"transparent to Relay and they are instead implemented externally in "
"either C++ or Python."
msgstr ""
"在上述定义中，:code:`%x` 和 :code:`%y` 的类型以及返回类型受到 :code:`Broadcast` 关系的约束，这意味着三者都必须是张量，并且它们的形状遵循逐元素广播关系。"
"与算子一样，关系的定义对 Relay 是不透明的，它们是在外部用 C++ 或 Python 实现的。"

#: ../../doc/docs/reference/langref/relay_expr.rst:257
msgid ""
"As in the case of :code:`Broadcast`, relations are used to express "
"complicated constraints on types (especially tensor shapes). All function"
" relations must hold at all call sites; type checking is thus treated as "
"a constraint-solving problem. For more detail on type relations and their"
" implementations, please see :ref:`their section in the documentation on "
"Relay's type system <type-relation>`."
msgstr ""
"与 :code:`Broadcast` 的情况一样，关系用于表达对类型（尤其是张量形状）的复杂约束。"
"所有函数关系必须在所有调用位置都成立；因此，类型检查被视为一个约束求解问题。"
"有关类型关系及其实现的更多详细信息，请参阅 :ref:`Relay 类型系统文档中的相关部分 <type-relation>`。"

#: ../../doc/docs/reference/langref/relay_expr.rst:265
msgid "Operators"
msgstr "算子"

#: ../../doc/docs/reference/langref/relay_expr.rst:267
msgid ""
"An operator is a primitive operation, such as :code:`add` or "
":code:`conv2d`, not defined in the Relay language. Operators are declared"
" in the global operator registry in C++. Many common operators are backed"
" by TVM's Tensor Operator Inventory."
msgstr ""
"算子是一种元运算（primitive operation），例如 :code:`add` 或 :code:`conv2d`，它们不是在 Relay 语言中定义的。"
"算子在 C++ 的全局算子注册表中声明。许多常见的算子由 TVM 的张量算子库支持。"

#: ../../doc/docs/reference/langref/relay_expr.rst:272
msgid ""
"To register an operator a user must provide an implementation of the "
"operator, its type, and any other desired metadata. The operator registry"
" is a column-based store where operators are keys, so any metadata (which"
" might be referenced by optimization passes) may be registered as a new "
"column."
msgstr ""
"要注册算子，用户必须提供该算子的实现、其类型以及任何其他所需的元数据。算子注册表是基于列的存储，其中算子是键，因此任何元数据（可能被优化过程引用）都可以注册为新列。"

#: ../../doc/docs/reference/langref/relay_expr.rst:278
msgid ""
"From the perspective of Relay's type system, an operator is a function, "
"so operators may be called like any other function and have function "
"types. In particular, operator types are registered using a single type "
"relation (see :ref:`the documentation on type relations <type-"
"relation>`), typically a relation specialized to that operator. For "
"example, the :code:`add` operator is registered with the "
":code:`Broadcast` relation, indicating that the arguments of :code:`add` "
"must be tensors and that the return type is a tensor whose shape depends "
"on those of its arguments."
msgstr ""
"从 Relay 类型系统的角度来看，算子是函数，因此算子可以像任何其他函数一样被调用，并且具有函数类型。特别是，算子类型使用单一类型关系注册（参见 :ref:`关于类型关系的文档 <type-relation>`），通常是专门为该算子定制的关系。"
"例如，:code:`add` 算子使用 :code:`Broadcast` 关系注册，表明 :code:`add` 的参数必须是张量，并且返回类型的形状取决于其参数的张量。"

#: ../../doc/docs/reference/langref/relay_expr.rst:287
msgid ""
"Operators are rendered without a sigil (e.g :code:`conv2d`, "
":code:`flatten`) when pretty-printing Relay programs. Operators are "
"explicitly contained in the program and are uniquely identifiable by "
"pointer."
msgstr ""
"在漂亮打印 Relay 程序时，算子没有符号前缀（例如 :code:`conv2d`，:code:`flatten`）。算子显式地包含在程序中，并且可以通过指针唯一标识。"

#: ../../doc/docs/reference/langref/relay_expr.rst:292
msgid ""
"Note that common arithmetic operators such as :code:`add` and "
":code:`multiply` may be written using the corresponding arithmetic "
"operators in the text format (e.g., :code:`+` or :code:`*`) as syntactic "
"sugar."
msgstr ""
"请注意，常见的算术算子（如 :code:`add` 和 :code:`multiply`）可以使用文本格式中相应的算术算子（例如 :code:`+` 或 :code:`*`）作为语法糖来编写。"

#: ../../doc/docs/reference/langref/relay_expr.rst:296
msgid ""
"See :py:class:`~tvm.relay.op.Op` for the definition and documentation of "
"operator nodes, demonstrating the infrastructure for registering operator"
" metadata. The other files in :py:class:`~tvm.relay.op` give handles for "
"generating a call to various pre-registered operators. The :ref:`tutorial"
" on adding operators to Relay <relay-add-op>` shows how to add further "
"operators into the language."
msgstr ""
"请参阅 :py:class:`~tvm.relay.op.Op` 了解算子节点的定义和文档，展示了注册算子元数据的基础设施。"
":py:class:`~tvm.relay.op` 中的其他文件提供了生成对各种预注册算子调用的句柄。:ref:`关于向 Relay 添加算子的教程 <relay-add-op>` 展示了如何向语言中添加更多算子。"

#: ../../doc/docs/reference/langref/relay_expr.rst:304
msgid "ADT Constructors"
msgstr "ADT 构造器"

#: ../../doc/docs/reference/langref/relay_expr.rst:306
msgid ""
"Algebraic data types (ADTs) in Relay are described in detail in a "
":ref:`separate overview<adt-overview>` and their integration into the "
"type system is described :ref:`here<adt-typing>`."
msgstr ""
"Relay 中的代数数据类型（Algebraic data types，简称 ADTs）在 :ref:`单独的概述 <adt-overview>` 中有详细描述，并且它们如何集成到类型系统中的内容在 :ref:`这里 <adt-typing>` 进行了说明。"

#: ../../doc/docs/reference/langref/relay_expr.rst:310
msgid ""
"In this section, we will simply note that ADT constructors are given a "
"function type and should be used inside call nodes like a function or "
"operator. An ADT constructor is defined by giving the name of the ADT it "
"constructs (a global type variable) and the types of the expected "
"arguments for the constructor."
msgstr ""
"在本节中，将简要说明，ADT 构造器被赋予了函数类型，并且应该像函数或算子一样在调用节点中使用。ADT 构造器的定义包括指定它所要构造的 ADT 的名称（全局类型变量）以及构造器期望的参数类型。"

#: ../../doc/docs/reference/langref/relay_expr.rst:316
msgid ""
"If the ADT definition includes type variables, those type variables may "
"appear in the constructor. Constructors cannot include any other type "
"variables."
msgstr ""
"如果 ADT 定义中包含类型变量，这些类型变量可能会出现在构造函数中。构造函数不能包含任何其他类型变量。"

#: ../../doc/docs/reference/langref/relay_expr.rst:320
msgid ""
"Let us suppose that :code:`D` is an ADT that takes type parameters "
":code:`a` and :code:`b`. If :code:`C1` is a constructor for :code:`D` and"
" expects two arguments, one of type :code:`a` and one of type :code:`b`, "
"then :code:`C1` has the following type signature: :code:`fun<a, b>(a, b) "
"-> D[a, b]`. (See either the ADT overview or the discussion of ADT typing"
" for an explanation of the type call in the return type.) If another "
"constructor for :code:`D`, :code:`C2`, takes no arguments, then it has "
"the following type signature: :code:`fun<a, b>() -> D[a, b]`; the type "
"parameters will always appear in the return type."
msgstr ""
"假设 :code:`D` 是接受类型参数 :code:`a` 和 :code:`b` 的 ADT（代数数据类型）。"
"如果 :code:`C1` 是 :code:`D` 的构造函数，并且期望接收两个参数，一个类型为 :code:`a`，另一个类型为 :code:`b`，那么 :code:`C1` 将具有以下类型签名：:code:`fun<a, b>(a, b) -> D[a, b]`。"
"（关于返回类型中的类型调用的解释，请参见 ADT 概述或ADT类型讨论部分。）如果 :code:`D` 的另一个构造函数 :code:`C2` 不接收任何参数，那么它将具有以下类型签名：:code:`fun<a, b>() -> D[a, b]`；类型参数将始终出现在返回类型中。"

#: ../../doc/docs/reference/langref/relay_expr.rst:331
msgid ""
"Once called, a constructor produces an ADT instance, which is a container"
" that stores the values of the arguments to the constructor as well as "
"the name (\"tag\") of the constructor. The tag will be used for "
"deconstructing the instances and retrieving the values when `ADT "
"Matching`_."
msgstr ""
"一旦被调用，构造函数就会生成 ADT 实例，这是容器，它不仅存储了传递给构造函数的参数值，还存储了构造函数的名称（\"tag\"）。该标签将用于在 `ADT Matching`_ 时解构实例并检索其中的值。"

#: ../../doc/docs/reference/langref/relay_expr.rst:337
msgid ""
"See :py:class:`~tvm.relay.adt.Constructor` for the definition and "
"documentation."
msgstr ""
"请参阅 :py:class:`~tvm.relay.adt.Constructor` 以获取定义和相关文档。"

#: ../../doc/docs/reference/langref/relay_expr.rst:340
msgid "Call"
msgstr "调用"

#: ../../doc/docs/reference/langref/relay_expr.rst:342
msgid ""
"Expressions with function types in Relay are \"callable,\" meaning that "
"they can be invoked via a function call. These consist of any expression "
"that evaluates to a closure (i.e., function expressions or global "
"functions) and Relay operators."
msgstr ""
"在 Relay 中，具有函数类型的表达式是“可调用的”，这意味着它们可以通过函数调用来执行。这些表达式包括任何可以求值为闭包的表达式（例如函数表达式或全局函数）以及 Relay 算子。"

#: ../../doc/docs/reference/langref/relay_expr.rst:347
msgid ""
"The syntax of calls follows that used in C-like languages, demonstrated "
"in the example below:"
msgstr ""
"调用的语法遵循类 C 语言中使用的语法，如下例所示："

#: ../../doc/docs/reference/langref/relay_expr.rst:356
msgid ""
"When a closure is called (see `Closures`_), the closure's body is "
"evaluated in the stored environment (i.e., using the stored values for "
"free variables) with local variable bindings added for each argument; the"
" final value obtained by evaluating the body is the call's return value. "
"Thus, in the above example, the call evaluates to 22. In the case of "
"operators, the implementation is opaque to Relay, so the result is left "
"up to the registered TVM implementation."
msgstr ""
"当闭包被调用时（参见 `Closures`_），闭包的主体会在存储的环境中（即使用自由变量的存储值）进行评估，并为每个参数添加局部变量绑定；通过评估主体获得的最终值即为调用的返回值。"
"因此，在上面的例子中，调用评估的结果是 22。对于算子的情况，其实现对 Relay 是不透明的，因此结果由注册的 TVM 实现决定。"

#: ../../doc/docs/reference/langref/relay_expr.rst:365
msgid "*Note: type parameters are not yet supported in the text format.*"
msgstr "*注意：文本格式目前尚不支持类型参数。*"

#: ../../doc/docs/reference/langref/relay_expr.rst:367
msgid ""
"A type-polymorphic function can also include type arguments at a call "
"site. The type arguments are substituted for type parameters when type "
"checking. If a function is type-polymorphic and type arguments are not "
"given, type inference will attempt to infer type arguments if possible. "
"The following code gives examples of explicit and inferred type "
"arguments:"
msgstr ""
"类型多态函数在调用时也可以包含类型参数。在类型检查时，类型参数会被替换为类型变量。如果函数是类型多态的且未提供类型参数，类型推断将尝试在可能的情况下推断出类型参数。以下代码展示了显式和推断类型参数的示例："

#: ../../doc/docs/reference/langref/relay_expr.rst:381
msgid ""
"Note that all type relations in the function type must hold at each call "
"site. Specifically, this means that the relation will be checked against "
"the specific types of the arguments at a given call site. This is also a "
"form of polymorphism, since there may be multiple valid assignments of "
"argument types and a return type so long as the relation is satisfied."
msgstr ""
"需要注意的是，函数类型中的所有类型关系在每个调用点都必须成立。具体来说，这意味着关系将根据给定调用点的参数具体类型进行检查。这也是一种多态形式，因为只要满足关系，可能存在多种参数类型和返回类型的有效组合。"

#: ../../doc/docs/reference/langref/relay_expr.rst:388
#, python-format
msgid ""
"For example, if we have a function :code:`%f` that takes tensor arguments"
" and has the :code:`Broadcast` relation, then there are many different "
"shapes that the arguments in the below call could have that would satisfy"
" the type annotation:"
msgstr ""
"例如，如果有函数 :code:`%f`，它接受张量参数并具有 :code:`Broadcast` 关系，那么在下面的调用中，参数可以有许多不同的形状来满足类型注解："

#: ../../doc/docs/reference/langref/relay_expr.rst:398
msgid "See :py:class:`~tvm.relay.expr.Call` for its definition and documentation."
msgstr "请参阅 :py:class:`~tvm.relay.expr.Call` 以获取其定义和文档。"

#: ../../doc/docs/reference/langref/relay_expr.rst:403
msgid "Module and Global Functions"
msgstr "模块与全局函数"

#: ../../doc/docs/reference/langref/relay_expr.rst:405
msgid ""
"Relay keeps a global data structure known as a \"module\" (often called "
"an \"environment\" in other functional programming languages) to keep "
"track of the definitions of global functions. In particular, the module "
"keeps a globally accessible mapping of global variables to the function "
"expressions they denote. The utility of the module is that it allows "
"global functions to recursively refer to themselves or any other global "
"function (e.g., as in mutual recursion)."
msgstr ""
"Relay 维护了称为“模块”(module)的全局数据结构（在其他函数式编程语言中通常称为“环境”），用于跟踪全局函数的定义。"
"具体来说，模块维护了全局可访问的映射，将全局变量与其所表示的函数表达式关联起来。模块的实用性在于它允许全局函数递归地引用自身或任何其他全局函数（例如，在相互递归的情况下）。"

#: ../../doc/docs/reference/langref/relay_expr.rst:411
msgid ""
"Note Relay's module is analogous to data structures for keeping track of "
"subgraphs in computation graph-based IRs."
msgstr ""
"需要注意的是，Relay 的模块类似于在基于计算图的中间表示（IR）中用于跟踪子图的数据结构。"

#: ../../doc/docs/reference/langref/relay_expr.rst:414
msgid ""
"Global functions in Relay behave identically to the function expressions "
"defined in `Functions`_, but have syntactic sugar in the text format to "
"enter their definitions into the module. Namely, a global function "
"definition includes a global identifier and is allowed to recursively "
"refer to that identifier in the body, as in the following example:"
msgstr ""
"Relay 中的全局函数与 `Functions`_ 部分定义的函数表达式行为完全相同，但在文本格式中提供了语法糖，以便将其定义录入模块中。"
"具体来说，全局函数定义包括全局标识符，并且允许在函数体中递归地引用该标识符，如下例所示："

#: ../../doc/docs/reference/langref/relay_expr.rst:431
msgid ""
"This definition would result in a module entry mapping the identifier "
":code:`@ackermann` to a function expression with the parameters, return "
"type, and body above. Any reference to the identifier :code:`@ackermann` "
"elsewhere in the code could then look up the identifier in the module and"
" replace the function definition as needed."
msgstr ""
"这个定义将导致模块中创建条目，将标识符 :code:`@ackermann` 映射到具有上述参数、返回类型和主体的函数表达式。"
"代码中其他任何对标识符 :code:`@ackermann` 的引用都可以在模块中查找该标识符，并根据需要替换函数定义。"

#: ../../doc/docs/reference/langref/relay_expr.rst:435
msgid ""
"See :py:class:`~tvm.IRModule` for the definition and documentation of a "
"module."
msgstr ""
"请参阅 :py:class:`~tvm.IRModule` 以获取模块的定义和文档。"

#: ../../doc/docs/reference/langref/relay_expr.rst:438
msgid "Constant"
msgstr "常量"

#: ../../doc/docs/reference/langref/relay_expr.rst:440
msgid ""
"This node represents a constant tensor value (see "
":py:mod:`~tvm.relay.Value` for more details). A constant is represented "
"as a :py:class:`~tvm.NDArray`, allowing Relay to utilize TVM operators "
"for constant evaluation."
msgstr ""
"该节点表示常量张量值（更多详情请参阅 :py:mod:`~tvm.relay.Value`）。常量以 :py:class:`~tvm.NDArray` 的形式表示，这使得 Relay 能够利用 TVM 算子进行常量求值。"

#: ../../doc/docs/reference/langref/relay_expr.rst:445
msgid ""
"This node can also represent scalar constants, since scalars are tensors "
"with a shape of :code:`()`. In the text format, numerical and boolean "
"literals are thus syntactic sugar for constants encoding a tensor type "
"with a rank-zero shape."
msgstr ""
"该节点也可以表示标量常量，因为标量是形状为 :code:`()` 的张量。在文本格式中，数值和布尔字面量因此是编码为秩为零形状的张量类型的常量的语法糖。"

#: ../../doc/docs/reference/langref/relay_expr.rst:450
msgid ""
"See :py:class:`~tvm.relay.expr.Constant` for its definition and "
"documentation."
msgstr ""
"请参阅 :py:class:`~tvm.relay.expr.Constant` 以获取其定义和文档。"

#: ../../doc/docs/reference/langref/relay_expr.rst:453
msgid "Tuples"
msgstr "元组"

#: ../../doc/docs/reference/langref/relay_expr.rst:456
msgid "Construction"
msgstr ""

#: ../../doc/docs/reference/langref/relay_expr.rst:458
msgid ""
"The tuple node builds a finite (that is, of statically known size) "
"sequence of heterogeneous data. These tuples match Python's closely, and "
"their fixed length allows for efficient projection of their members."
msgstr ""
"元组节点构建了有限（即静态已知大小）的异构数据序列。这些元组与 Python 中的元组非常相似，其固定长度使得对其成员的高效投影成为可能。"

#: ../../doc/docs/reference/langref/relay_expr.rst:469
msgid ""
"See :py:class:`~tvm.relay.expr.Tuple` for its definition and "
"documentation."
msgstr ""
"请参阅 :py:class:`~tvm.relay.expr.Tuple` 以获取其定义和文档。"

#: ../../doc/docs/reference/langref/relay_expr.rst:472
msgid "Projection"
msgstr "投影"

#: ../../doc/docs/reference/langref/relay_expr.rst:474
msgid ""
"A tuple must be indexed by an integer constant in order to extract a "
"particular member of the tuple. Projections are 0-indexed."
msgstr ""
"元组必须通过整数常量进行索引，以提取元组中的特定成员。投影是从 0 开始索引的。"

#: ../../doc/docs/reference/langref/relay_expr.rst:477
msgid "For example, the below projection evaluates to :code:`%b`:"
msgstr "例如，下面的投影评估结果为 :code:`%b`："

#: ../../doc/docs/reference/langref/relay_expr.rst:483
msgid ""
"See :py:class:`~tvm.relay.expr.TupleGetItem` for its definition and "
"documentation."
msgstr ""
"请参阅 :py:class:`~tvm.relay.expr.TupleGetItem` 以获取其定义和文档。"

#: ../../doc/docs/reference/langref/relay_expr.rst:486
msgid "Let Bindings"
msgstr "Let 绑定"

#: ../../doc/docs/reference/langref/relay_expr.rst:488
msgid ""
"A :code:`let` binding is an immutable local variable binding, allowing "
"the user to bind an expression to a name."
msgstr ""
":code:`let` 绑定是一种不可变的局部变量绑定，允许用户将表达式绑定到名称上。"

#: ../../doc/docs/reference/langref/relay_expr.rst:491
msgid ""
"A :code:`let` binding contains a local variable, an optional type "
"annotation, a value, and a body expression that may reference the bound "
"identifier. If a type annotation on the bound variable is omitted, Relay "
"attempts to infer the most general type permitted for the variable."
msgstr ""
":code:`let` 绑定包含局部变量、可选的类型注解、值以及可以引用绑定标识符的主体表达式。如果省略了绑定变量的类型注解，Relay 会尝试推断该变量允许的最通用类型。"

#: ../../doc/docs/reference/langref/relay_expr.rst:497
msgid ""
"The bound variable in a :code:`let` expression is only in scope in its "
"body, except when the variable defines a function expression. When a "
":code:`let` expression creates a function, the variable is also in scope "
"in its value to allow for recursively defined functions (see the previous"
" subsection)."
msgstr ""
"在 :code:`let` 表达式中，绑定的变量仅在其主体范围内有效，除非该变量定义了函数表达式。当 :code:`let` 表达式创建函数时，该变量在其值范围内也有效，以允许递归定义的函数（参见上一小节）。"

#: ../../doc/docs/reference/langref/relay_expr.rst:503
msgid ""
"The value of a :code:`let` binding is the value of the final expression "
"after evaluating the bindings it depends on. For example, in the "
"following example the entire expression evaluates to a tensor of shape "
":code:`(10, 10)` where all elements are 1:"
msgstr ""
":code:`let` 绑定的值是在评估其所依赖的绑定后最终表达式的值。例如，在以下示例中，整个表达式评估为形状为 :code:`(10, 10)` 且所有元素均为 1 的张量："

#: ../../doc/docs/reference/langref/relay_expr.rst:513
msgid ""
"A sequence of :code:`let` bindings can be considered as a dataflow graph,"
" where the bindings are a series of sub-graphs connected by bound "
"variables. Since these binding sequences are pure, a pair of bindings "
"where neither depends on the other can be safely reordered. For example, "
"the first and second :code:`let` bindings below may be evaluated in "
"either order because neither has a dataflow dependency on the other:"
msgstr ""
"一系列 :code:`let` 绑定可以被视为数据流图，其中绑定是通过绑定变量连接的一系列子图。"
"由于这些绑定序列是纯的，因此可以安全地重新排序彼此不依赖的绑定对。例如，下面的第一个和第二个 :code:`let` 绑定可以按任意顺序评估，因为它们之间没有数据流依赖关系："

#: ../../doc/docs/reference/langref/relay_expr.rst:527
msgid "See :py:class:`~tvm.relay.expr.Let` for its definition and documentation."
msgstr "请参阅 :py:class:`~tvm.relay.expr.Let` 以获取其定义和文档。"

#: ../../doc/docs/reference/langref/relay_expr.rst:530
msgid "Graph Bindings"
msgstr "图绑定"

#: ../../doc/docs/reference/langref/relay_expr.rst:532
msgid ""
"A :code:`let` binding creates a named variable that is bound to the given"
" value and scoped to the subsequent expression. By contrast, a graph "
"binding allows for explicitly constructing dataflow graphs in a Relay "
"program by binding an expression (graph node) directly to a temporary "
"variable, which is not scoped. Each reference to the variable corresponds"
" to an edge in the dataflow graph. This has the semantics of substituting"
" the expression wherever the variable appears, even though the graph node"
" will only be evaluated once by the compiled program."
msgstr ""
":code:`let` 绑定创建命名变量，该变量绑定到给定值并限定在后续表达式的范围内。相比之下，图绑定允许通过将表达式（图节点）直接绑定到不限范围的临时变量来显式构建 Relay 程序中的数据流图。"
"每次对变量的引用都对应于数据流图中的一条边。这具有在变量出现的任何地方替换表达式的语义，尽管编译后的程序只会对图节点进行一次评估。"

#: ../../doc/docs/reference/langref/relay_expr.rst:540
msgid ""
"These bindings allow for a style of programming that corresponds to that "
"already employed by NNVM and other dataflow graph-based input formats. "
"The fact that the variables are not scoped offers some flexibility in "
"evaluation order compared to :code:`let` bindings, though this can also "
"introduce some ambiguity in programs."
msgstr ""
"这些绑定允许一种编程风格，与 NNVM 和其他基于数据流图的输入格式已经采用的风格相对应。与 :code:`let` 绑定相比，变量不限范围的事实提供了一些评估顺序的灵活性，尽管这也可能在程序中引入一些歧义。"

#: ../../doc/docs/reference/langref/relay_expr.rst:545
msgid "*Note: Graph bindings are not currently parsed by the text format.*"
msgstr "*注意：图绑定目前尚未被文本格式解析。*"

#: ../../doc/docs/reference/langref/relay_expr.rst:547
msgid ""
"In Relay's text format, a graph binding can be written as below (note the"
" lack of a :code:`let` keyword and a semicolon):"
msgstr ""
"在 Relay 的文本格式中，图绑定可以写成如下形式（注意缺少 :code:`let` 关键字和分号）："

#: ../../doc/docs/reference/langref/relay_expr.rst:556
msgid ""
"Unlike a let binding, a graph binding is not represented as an AST node "
"in Relay, but rather as a meta-variable referencing its AST node value. "
"For example, a program like the above could be constructed in Relay's "
"Python front-end by setting *Python variables* equal to the corresponding"
" Relay AST node and using the variables repeatedly, as below (a C++ "
"program using the corresponding API bindings could accomplish the same "
"thing):"
msgstr ""
"与 let 绑定不同，图绑定在 Relay 中不作为 AST 节点表示，而是作为引用其 AST 节点值的元变量。"
"例如，像上面这样的程序可以通过在 Relay 的 Python 前端中将 *Python变量* 设置为相应的 Relay AST 节点并重复使用这些变量来构建，如下所示（使用相应 API 绑定的 C++ 程序可以实现相同的功能）："

#: ../../doc/docs/reference/langref/relay_expr.rst:568
msgid ""
"For development purposes and to enable certain optimizations, Relay "
"includes passes to convert between dataflow graphs defined using graph "
"bindings and programs with :code:`let` bindings in A-normal form, "
"employed by many compiler optimizations from the functional programming "
"community (see `\"A-Normalization: Why and How\" by Matt Might "
"<http://matt.might.net/articles/a-normalization/>`__ for an introduction "
"to A-normal form)."
msgstr ""
"出于开发目的和实现某些优化，Relay 包含了在数据流图和 A-normal 形式的 :code:`let` 绑定程序之间进行转换的步骤，"
"这种形式被许多来自函数式编程社区的编译器优化所采用（有关 A-normal 形式的介绍，请参见 Matt Might的 `\"A-Normalization: Why and How\" <http://matt.might.net/articles/a-normalization/>`__）。"

#: ../../doc/docs/reference/langref/relay_expr.rst:576
msgid "If-Then-Else"
msgstr ""

#: ../../doc/docs/reference/langref/relay_expr.rst:578
msgid ""
"Relay has a simple if-then-else expression that allows programs to branch"
" on a single value of type :code:`bool`, i.e., a zero-rank tensor of "
"booleans (:code:`Tensor[(), bool]`)."
msgstr ""
"Relay 有简单的 if-then-else 表达式，允许程序在类型为 :code:`bool` 的单个值上进行分支，即布尔类型的零秩张量（:code:`Tensor[(), bool]`）。"

#: ../../doc/docs/reference/langref/relay_expr.rst:590
msgid ""
"Since if-then-else branches are expressions, they may appear inline "
"wherever any other expression may be expected, like invocations of the "
"ternary operator in C-like languages. The if-then-else expression "
"evaluates to the value of the \"then\" branch if the condition value "
"evaluates to :code:`True` and evaluates to the value of the \"else\" "
"branch if the condition value evaluates to :code:`False`."
msgstr ""
"由于 if-then-else 分支是表达式，它们可以内联出现在任何其他表达式可能出现的地方，就像类 C 语言中的三元算子调用一样。"
"如果条件值评估为 :code:`True`，则 if-then-else 表达式评估为 “then” 分支的值；如果条件值评估为 :code:`False`，则评估为 “else” 分支的值。"

#: ../../doc/docs/reference/langref/relay_expr.rst:597
msgid "See :py:class:`~tvm.relay.expr.If` for its definition and documentation."
msgstr "请参阅 :py:class:`~tvm.relay.expr.If` 以获取其定义和文档。"

#: ../../doc/docs/reference/langref/relay_expr.rst:600
msgid "ADT Matching"
msgstr "ADT 匹配"

#: ../../doc/docs/reference/langref/relay_expr.rst:602
msgid ""
"Instances of algebraic data types (ADTs), as discussed in the :ref:`ADT "
"overview<adt-overview>`, are containers that store the arguments passed "
"to the constructor used to create them, tagged by the constructor name."
msgstr ""
"代数数据类型（ADT）的实例，如 :ref:`ADT概述 <adt-overview>` 中所述，是存储传递给用于创建它们的构造函数的参数的容器，并由构造函数名称标记。"

#: ../../doc/docs/reference/langref/relay_expr.rst:607
msgid ""
"Match expressions in Relay allow for retrieving the values stored in an "
"ADT instance (\"deconstructing\" it) based on their constructor tag. A "
"match expression behaves similarly to a C-style :code:`switch` statement,"
" branching on the different possible constructors for the type of the "
"value being deconstructed. As the ADT overview details, match expressions"
" are capable of more general pattern-matching than simply splitting by "
"constructors: any ADT instance nested inside an instance (e.g., a list of"
" lists) can be deconstructed at the same time as the outer instance, "
"while the different fields of the instance can be bound to variables. "
"(See :ref:`this section<adt-pattern>` for a detailed description of ADT "
"pattern-matching.)"
msgstr ""
"Relay 中的匹配表达式允许根据构造函数标签检索存储在 ADT 实例中的值（“解构”它）。"
"匹配表达式的行为类似于 C 风格的 :code:`switch` 语句，根据被解构值的类型的不同可能构造函数进行分支。"
"正如 ADT 概述中详细说明的那样，匹配表达式能够进行比简单按构造函数拆分更一般的模式匹配：任何嵌套在实例内部的ADT实例（例如，列表的列表）都可以与外部实例同时解构，而实例的不同字段可以绑定到变量。"
"（有关ADT模式匹配的详细描述，请参见 :ref:`此部分<adt-pattern>`。）"

#: ../../doc/docs/reference/langref/relay_expr.rst:619
msgid ""
"A match expression is defined using the input value (an expression) and a"
" list of clauses, each of which consists of a pattern and an expression. "
"When executed, the *first* clause whose pattern matches the structure of "
"the queried value is executed; the clause expression is evaluated and "
"returned."
msgstr ""
"匹配表达式使用输入值（表达式）和子句列表定义，每个子句由模式和表达式组成。执行时，*第一个* 模式与查询值结构匹配的子句将被执行；子句表达式被评估并返回。"

#: ../../doc/docs/reference/langref/relay_expr.rst:625
msgid "For example, suppose we have an ADT for natural numbers:"
msgstr "例如，假设有用于自然数的 ADT："

#: ../../doc/docs/reference/langref/relay_expr.rst:634
msgid "Then the following function subtracts one from a passed nat:"
msgstr "那么以下函数将从传入的 nat 中减去一："

#: ../../doc/docs/reference/langref/relay_expr.rst:645
msgid ""
"The following function subtracts two from its argument if it is at least "
"two and returns the argument otherwise, using a nested constructor "
"pattern:"
msgstr ""
"以下函数如果其参数至少为二，则从中减去二，否则返回参数，使用嵌套构造函数模式："

#: ../../doc/docs/reference/langref/relay_expr.rst:658
msgid ""
"As aforementioned, the ordering of match clauses is relevant. In the "
"below example, the first clause will always match so those below it can "
"never run:"
msgstr ""
"如前所述，匹配子句的顺序是相关的。在下面的示例中，第一个子句将始终匹配，因此其下面的子句永远不会运行："

#: ../../doc/docs/reference/langref/relay_expr.rst:673
msgid "See :py:class:`~tvm.relay.adt.Match` for its definition and documentation."
msgstr "请参阅 :py:class:`~tvm.relay.adt.Match` 以获取其定义和文档。"

#: ../../doc/docs/reference/langref/relay_expr.rst:676
msgid "TempExprs"
msgstr "临时表达式"

#: ../../doc/docs/reference/langref/relay_expr.rst:678
msgid ""
"Program transformations (passes) in Relay may require inserting temporary"
" state into the program AST to guide further transformations. The "
":code:`TempExpr` node is provided as a utility to developers for this "
"purpose; nodes inheriting from :code:`TempExpr` cannot appear directly in"
" user-provided code but may be inserted in a pass. Any :code:`TempExpr` "
"created in a pass should ideally be eliminated before the pass is "
"complete, as a :code:`TempExpr` only stores internal state and has no "
"semantics of its own."
msgstr ""
"在 Relay 中，程序转换（passes）可能需要向程序 AST 中插入临时状态以指导进一步的转换。"
"为此，:code:`TempExpr` 节点作为工具提供给开发者使用；继承自 :code:`TempExpr` 的节点不能直接出现在用户提供的代码中，但可以在 pass 中插入。"
"理想情况下，在 pass 完成之前应消除任何创建的 :code:`TempExpr`，因为 :code:`TempExpr` 仅存储内部状态，没有自身的语义。"

#: ../../doc/docs/reference/langref/relay_expr.rst:686
msgid ""
"For an example of :code:`TempExpr` being used in a pass, see "
":code:`src/relay/transforms/fold_scale_axis.cc`, which uses "
":code:`TempExpr` nodes to store information about scaling parameters as "
"the pass tries to fold these into the weights of a convolution."
msgstr ""
"有关在 pass 中使用 :code:`TempExpr` 的示例，请参见 :code:`src/relay/transforms/fold_scale_axis.cc`，该文件使用 :code:`TempExpr` 节点在 pass 尝试将这些参数折叠到卷积的权重中时存储有关缩放参数的信息。"

#: ../../doc/docs/reference/langref/relay_expr.rst:691
msgid ""
"See :py:class:`~tvm.relay.expr.TempExpr` for its definition and "
"documentation."
msgstr "请参阅 :py:class:`~tvm.relay.expr.TempExpr` 以获取其定义和文档。"

