# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, xinetzone
# This file is distributed under the same license as the tvm package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tvm doc\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-10-09 21:52+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.15.0\n"

#: ../../doc/docs/arch/debugger.rst:20
msgid "Debugger"
msgstr "调试器"

#: ../../doc/docs/arch/debugger.rst:22
msgid ""
"TVM Debugger is an interface for debugging TVM's computation graph "
"execution. It helps to provide access to graph structures and tensor "
"values at the TVM runtime."
msgstr ""
"TVM 调试器是用于调试 TVM 计算图执行的接口。它有助于在 TVM 运行时访问计算图结构和张量值。"

#: ../../doc/docs/arch/debugger.rst:26
msgid "Debug Exchange Format"
msgstr "调试交换格式"

#: ../../doc/docs/arch/debugger.rst:29
msgid "1. Computational Graph"
msgstr "1. 计算图"

#: ../../doc/docs/arch/debugger.rst:30
msgid ""
"The optimized graph build by relay in json serialized format is dumped as"
" it is. This contains the whole information about the graph. The UX can "
"either use this graph directly or transform this graph to the format UX "
"can understand."
msgstr ""
"通过 relay 以 JSON 序列化格式构建的优化计算图被转储为它包含有关计算图的所有信息。"
"UX 可以直接使用这个计算图，或者将此计算图转换为 UX 可以理解的格式。"

#: ../../doc/docs/arch/debugger.rst:35
msgid "The Graph JSON format is explained below"
msgstr "计算图 JSON 格式的说明如下"

#: ../../doc/docs/arch/debugger.rst:37
msgid ""
"1. ``nodes`` Nodes are either placeholders or computational nodes in "
"json. The nodes are stored as a list. A node contains the below "
"information"
msgstr ""
"1. ``nodes`` 节点是占位符或计算节点，以 JSON 格式存储为列表。节点包含以下信息"

#: ../../doc/docs/arch/debugger.rst:41
msgid ""
"``op`` - operation type, ``null`` means it is a "
"placeholder/variable/input node and``tvm_op`` means this node can be "
"executed"
msgstr ""
"``op`` - 运算类型，``null`` 表示这是占位符/变量/输入节点，``tvm_op`` 表示此节点可以执行"

#: ../../doc/docs/arch/debugger.rst:42
msgid "``name`` - Name of the node"
msgstr "``name`` - 节点名称"

#: ../../doc/docs/arch/debugger.rst:43
msgid ""
"``inputs`` - Position of the inputs for this operation, Inputs is a list "
"of tuples with (nodeid, index, version). (Optional)"
msgstr ""
"``inputs`` - 此运算的输入位置，输入是元组列表，元组包含 (nodeid, index, version)。(可选)"

#: ../../doc/docs/arch/debugger.rst:44
msgid ""
"``attrs`` - Attributes of the node which contains the following "
"information"
msgstr ""
"``attrs`` - 节点属性，包含以下信息"

#: ../../doc/docs/arch/debugger.rst:46
msgid "``flatten_data`` - Whether this data need to be flattened before execution"
msgstr "``flatten_data`` - 是否需要在执行前将数据展平"

#: ../../doc/docs/arch/debugger.rst:47
msgid ""
"``func_name`` - Fused function name, corresponds to the symbol in the lib"
" generated by relay compilation process."
msgstr ""
"``func_name`` - 融合函数的名称，对应于生成的库中的符号"

#: ../../doc/docs/arch/debugger.rst:48
msgid "``num_inputs`` - Number of inputs for this node"
msgstr "``num_inputs`` - 此节点的输入数量"

#: ../../doc/docs/arch/debugger.rst:49
msgid "``num_outputs`` - Number of outputs this node produces"
msgstr "``num_outputs`` - 此节点产生的输出数量"

#: ../../doc/docs/arch/debugger.rst:51
msgid ""
"2. ``arg_nodes`` arg_nodes is a list of indices of nodes which is "
"placeholder/variable/input or constant/param to the graph."
msgstr ""
"2. ``arg_nodes`` - 占位符/变量/输入或常量/param 节点的索引列表"

#: ../../doc/docs/arch/debugger.rst:54
msgid "3. ``heads`` heads is a list of entries as the output of the graph."
msgstr "3. ``heads`` - 输出为计算图的头的条目列表"

#: ../../doc/docs/arch/debugger.rst:57
msgid ""
"4. ``node_row_ptr`` node\\_row\\_ptr stores the history of forward path, "
"so you can skip constructing the entire graph in inference tasks."
msgstr ""
"4. ``node_row_ptr`` - 节点行指针，存储前向路径的历史，以便在推理任务中能够跳跃构建整个图"

#: ../../doc/docs/arch/debugger.rst:60
msgid ""
"5. ``attrs`` attrs can contain version numbers or similar helpful "
"information."
msgstr ""
"5. ``attrs`` - 可以包含版本号或类似的有用信息"

#: ../../doc/docs/arch/debugger.rst:63
msgid "``storage_id`` - Memory slot id for each node in the storage layout."
msgstr "``storage_id`` - 每个节点在存储布局中的内存槽的 ID"

#: ../../doc/docs/arch/debugger.rst:64
msgid "``dtype`` - Datatype of each node (enum value)."
msgstr "``dtype`` - 每个节点的数据类型（枚举值）"

#: ../../doc/docs/arch/debugger.rst:65
msgid "``dltype`` - Datatype of each node in order."
msgstr "``dltype`` - 每个节点的数据类型（按照顺序）"

#: ../../doc/docs/arch/debugger.rst:66
msgid "``shape`` - Shape of each node k order."
msgstr "``shape`` - 每个节点的形状（按照顺序）"

#: ../../doc/docs/arch/debugger.rst:67
msgid "``device_index`` - Device assignment for each entry in the graph."
msgstr "``device_index`` - 每个条目的设备分配（按照顺序）"

#: ../../doc/docs/arch/debugger.rst:69
msgid "Example of dumped graph:"
msgstr "导出的计算图示例："

#: ../../doc/docs/arch/debugger.rst:109
msgid "2. Tensor dumping"
msgstr "2. 张量转储"

#: ../../doc/docs/arch/debugger.rst:111
msgid ""
"The tensor received after execution is in ``tvm.ndarray`` type. All the "
"tensors will be saved as binary bytes in serialized format.  The result "
"binary bytes can be loaded by the API \"load_params\"."
msgstr ""
"执行后的张量以 ``tvm.ndarray`` 类型表示。所有张量将以二进制字节的形式保存为序列化格式。结果二进制字节可以通过 API \"load_params\" 加载。"

#: ../../doc/docs/arch/debugger.rst:120
msgid "Example of loading the parameters"
msgstr "加载参数的示例"

#: ../../doc/docs/arch/debugger.rst:120
msgid "::"
msgstr ""

#: ../../doc/docs/arch/debugger.rst:118
msgid "with open(path_params, \"rb\") as fi:"
msgstr ""

#: ../../doc/docs/arch/debugger.rst:118
msgid "loaded_params = bytearray(fi.read())"
msgstr ""

#: ../../doc/docs/arch/debugger.rst:120
msgid "module.load_params(loaded_params)"
msgstr ""

#: ../../doc/docs/arch/debugger.rst:124
msgid "How to use Debugger?"
msgstr "如何使用调试器？"

#: ../../doc/docs/arch/debugger.rst:126
msgid "In ``config.cmake`` set the ``USE_PROFILER`` flag to ``ON``"
msgstr "在 ``config.cmake`` 中设置 ``USE_PROFILER`` 标志为 ``ON``"

#: ../../doc/docs/arch/debugger.rst:133
msgid "Do 'make' tvm, so that it will make the ``libtvm_runtime.so``"
msgstr "执行 'make' tvm，这样它就会生成 ``libtvm_runtime.so``"

#: ../../doc/docs/arch/debugger.rst:135
msgid ""
"In frontend script file instead of ``from tvm.contrib import "
"graph_executor`` import the ``GraphModuleDebug`` ``from "
"tvm.contrib.debugger.debug_executor import GraphModuleDebug``"
msgstr ""
"在前端脚本文件中，而不是 ``from tvm.contrib import graph_executor``，"
"而是导入 ``GraphModuleDebug`` ``from tvm.contrib.debugger.debug_executor import GraphModuleDebug``"

#: ../../doc/docs/arch/debugger.rst:158
msgid ""
"If network previously was exported to external library using "
"``lib.export_library(\"network.so\")``"
msgstr ""
"如果网络先前已导出到外部库，则使用 ``lib.export_library(\"network.so\")``"

#: ../../doc/docs/arch/debugger.rst:157
msgid ""
"like shared object file/dynamic linked library, the initialization of "
"debug runtime will be slightly different"
msgstr ""
"像共享对象文件/动态链接库一样，调试运行时的初始化会略有不同"

#: ../../doc/docs/arch/debugger.rst:172
msgid ""
"The outputs are dumped to a temporary folder in ``/tmp`` folder or the "
"folder specified while creating the runtime."
msgstr ""
"输出被转储到 ``/tmp`` 文件夹中的临时文件夹或创建运行时时指定的文件夹中。"

#: ../../doc/docs/arch/debugger.rst:177
msgid "Sample Output"
msgstr "输出样例"

#: ../../doc/docs/arch/debugger.rst:179
msgid "The below is the an example output of the debugger."
msgstr "下面是调试器的输出示例。"

