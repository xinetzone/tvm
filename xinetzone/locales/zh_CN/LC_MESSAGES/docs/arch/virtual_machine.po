# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, xinetzone
# This file is distributed under the same license as the TVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: TVM \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-09 00:02+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../xin/docs/arch/virtual_machine.md:1
msgid "将 VM 放入 TVM：Relay Virtual Machine"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:3
msgid "Relay是一种新的程序表示方法，它实现了大量机器学习程序的表示和优化。不幸的是，通过支持更有表现力的程序集，引入了一些新的执行挑战。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:5
msgid ""
"Relay 的解释器可以执行完整的语言，但是有明显的限制，这使得它不适合生产部署。它被构造成执行 AST "
"遍历来执行程序的低效解释器。这种方法在概念上很简单，但效率很低，因为 AST 遍历严重依赖于其间接性。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:7
msgid ""
"在编译动态代码方面还有更多的挑战，比如动态调度（dynamic scheduling）和分配（allocation）、全动态张量形状（fully "
"dynamic tensor shapes）和控制流（control flow）。解释器为这些提供了简单的解决方案，但没有足够引人注目或优化的。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:9
msgid ""
"第二种执行机制是现有的图执行程序。为了使 Relay "
"程序达到这个目标，将它们中的一小部分编译成旧的图格式，并在运行时执行它们。图执行器提供了快速执行体验，但只适用于非常有限的 Relay 程序子集。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:11
msgid ""
"另一种替代的但不是标准的方法是 Relay 的提前编译器（ahead-of-time compiler），它将 Relay "
"程序编译到包含提前实现的共享库中。提前编译器提供了令人信服的性能，但是很难扩展和使用，这只能通过修改代码生成和优化机制来实现。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:13
msgid "Relay 虚拟机旨在成为平衡这些相互竞争的方法的框架，提供动态执行环境，可以通过灵活的扩展机制进行扩展、插装，并与其他方法(如提前编译)集成。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:15
msgid "设计虚拟机是为了在部署和执行 Relay 程序时在性能和灵活性之间取得平衡，而不放弃 TVM 的好处。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:17
msgid "在编程语言和系统中，虚拟机(VM)设计是得到充分研究的领域，已经有各种成熟的和嵌入式编程语言的虚拟机设计。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:19
msgid ""
"以前的语言 VM "
"设计都是针对传统程序的执行配置文件进行了大量的定制。传统程序操作小标量值，由大量低级指令组成。指令的数量要求指令的执行和调度非常高效。在机器学习的背景下，主要使用张量值，使用(相对)少量的高级指令。ML"
" 程序的成本中心是在大输入上昂贵的 operator 调用，例如 GEMM 或卷积。由于 ML 程序所展示的执行概要，在标量 vm "
"中进行微优化的重要性大大降低。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:21
msgid ""
"TVM "
"为视觉模型提供了强有力的支持，但我们希望发展到支持更广泛的模型。图执行器能够利用输入图的完全静态特性来执行主动优化，例如完全静态分配和最佳内存重用。当引入使用控制流、递归、动态形状（dynamic"
" shapes）和动态分配（dynamic allocation）的模型时，必须改变执行的工作方式。Relay 的虚拟机是自然的选择。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:23
msgid "本文档的其余部分提供了 Relay 虚拟机设计及其指令集的高级概述。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:25
msgid "设计"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:27
msgid "VM 的设计注重简单性，而不牺牲性能。为了实现这一点，着重设计了张量 VM，而不是标量 VM。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:29
msgid ""
"在张量 VM 设置中，优化了对象的廉价“allocation”(通过尝试避免真正的 allocation)、静态片段（static "
"fragments）的重用和动态形状(即 jagged tensors)的能力。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:31
msgid "指令集"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:33
msgid ""
"指令集和指令（instruction）表示的选择是虚拟机最关键的设计决策。指令的当前表示形式是 tagged union，包含 op-code 和"
" data payload。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:35
msgid ""
"重要的设计决策是指令的抽象级别（RISC vs. CISC）以及它们如何获取数据（固定宽度指令编码（fixed-width instruction"
" encoding） vs.可变长度指令编码（variable-length encoding））。当前版本更接近 CISC，使用了像 "
"AllocTensor 这样的复杂指令，并且由于在指令中包含了形状，所以是可变长度的。当前的指令集是非常高级的，大致对应于 Relay "
"中的高级运算。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:37
msgid "Ret"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:39
#: ../../xin/docs/arch/virtual_machine.md:48
#: ../../xin/docs/arch/virtual_machine.md:59
#: ../../xin/docs/arch/virtual_machine.md:71
#: ../../xin/docs/arch/virtual_machine.md:82
#: ../../xin/docs/arch/virtual_machine.md:93
#: ../../xin/docs/arch/virtual_machine.md:104
#: ../../xin/docs/arch/virtual_machine.md:115
#: ../../xin/docs/arch/virtual_machine.md:125
#: ../../xin/docs/arch/virtual_machine.md:136
#: ../../xin/docs/arch/virtual_machine.md:149
#: ../../xin/docs/arch/virtual_machine.md:157
#: ../../xin/docs/arch/virtual_machine.md:165
#: ../../xin/docs/arch/virtual_machine.md:175
#: ../../xin/docs/arch/virtual_machine.md:184
msgid "**参数**："
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:41
#: ../../xin/docs/arch/virtual_machine.md:61
#: ../../xin/docs/arch/virtual_machine.md:73
#: ../../xin/docs/arch/virtual_machine.md:84
#: ../../xin/docs/arch/virtual_machine.md:95
#: ../../xin/docs/arch/virtual_machine.md:106
#: ../../xin/docs/arch/virtual_machine.md:117
#: ../../xin/docs/arch/virtual_machine.md:139
#: ../../xin/docs/arch/virtual_machine.md:177
#: ../../xin/docs/arch/virtual_machine.md:187
msgid "RegName dst"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:42
msgid "RegName result"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:44
msgid "将 ``result`` 寄存器（register）中的对象返回给调用者的 ``dst`` 寄存器。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:46
msgid "InvokePacked"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:50
msgid "Index packed_index"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:51
msgid "Index arity"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:52
msgid "Index output_size"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:53
msgid "RegName* packed_args"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:55
msgid ""
"调用 ``packed_index`` 所表示的打包函数。``arity`` 和 ``output_size`` "
"用来告诉虚拟机预期有多少输入和输出。``packed_args`` 存储参数寄存器（register）列表。注意 ``Index`` 是 "
"``int64_t`` 的别名，它也会在其他指令中使用。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:57
msgid "AllocTensor"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:62
#: ../../xin/docs/arch/virtual_machine.md:74
msgid "RegName storage"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:63
msgid "uint32_t ndim"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:64
msgid "int64_t* shape"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:65
#: ../../xin/docs/arch/virtual_machine.md:76
msgid "DLDataType dtype"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:67
msgid ""
"从给定的存储块（storage block）``storage`` 中分配使用常量 shape（存储在 ``shape`` 中）和 "
"``dtype`` 的张量值。结果保存在 register ``dst``。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:69
msgid "AllocTensorReg"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:75
msgid "RegName shape_register"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:78
msgid ""
"从给定的存储块（存储在 ``storage``）中分配适当形状的张量值（存储在 ``shape_register`` 中）和 "
"``dtype``。结果保存在 register ``dst``。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:80
msgid "AllocStorage"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:85
msgid "RegName size"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:86
msgid "RegName alignment"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:87
msgid "DLDataType dtype_hint"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:89
msgid ""
"使用给定的 ``size``、``alignment``，数据类型和 ``dtype_hint`` 分配存储块。分配的存储块存储在寄存器 "
"``dst`` 中。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:91
msgid "AllocADT"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:96
msgid "Index tag"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:97
msgid "Index num_fields"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:98
msgid "RegName* datatype_fields"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:100
msgid ""
"使用来自注册表（register）``datatype_fields`` 的 ``num_fields`` 条目分配带有标记 ``tag`` "
"的数据类型。结果保存在 register ``dst``。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:102
msgid "AllocClosure"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:107
msgid "Index clo_index"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:108
msgid "Index num_freevar"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:109
msgid "RegName* free_vars;"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:111
msgid ""
"分配闭包，将 VMFunction 在 ``clo_index`` 处作为其代码，并从 ``free_vars`` 寄存器中分配 "
"``num_freevar`` 条目。结果保存在 register ``dst``。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:113
msgid "GetField"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:118
#: ../../xin/docs/arch/virtual_machine.md:138
msgid "RegName object"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:119
msgid "Index field_index"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:121
msgid "用索引 ``field_index`` 从 ``object`` 获取字段值。结果保存在 register ``dst``。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:123
msgid "If"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:127
msgid "RegName test"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:128
msgid "RegName target"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:129
msgid "Index true_offset"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:130
msgid "Index false_offset"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:132
msgid ""
"检查寄存器 ``test`` 处的对象是否等于 ``target``。如果相等，则相对跳转为 ``true_offset``，否则相对跳转为 "
"``false_offset``。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:134
msgid "GetTag"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:141
msgid "在寄存器 ``object`` 中获取 ADT 对象的对象 tag。结果保存在 register ``dst``。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:143
msgid "Fatal"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:145
msgid "虚拟机执行失败。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:147
msgid "Goto"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:151
msgid "Index pc_offset"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:153
msgid "通过 ``pc_offset`` 进行相对无条件跳转。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:155
msgid "Invoke"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:159
msgid "Index func_index"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:161
msgid "在 ``func_index`` 调用函数，消耗 VMFunction 的 arity 字段中包含的参数数量。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:163
msgid "InvokeClosure"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:167
msgid "RegName closure"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:168
msgid "Index num_closure_args"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:169
msgid "RegName* closure_args"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:171
msgid "调用 ``closure``，消耗闭包的 VMFunction 中声明的参数数量。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:173
msgid "LoadConst"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:178
msgid "Index const_index"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:180
msgid "从常量池中加载常量 ``const_index``。结果保存在 register ``dst``。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:182
msgid "LoadConsti"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:186
msgid "Index val"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:189
msgid "加载常量整数 ``val`` 来注册 ``dst``。结果是 0-rank 阶张量。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:191
msgid "Object 表示"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:193
msgid "利用对象协议来表示 VM 使用的对象。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:195
msgid ""
"目前，有三种类型的对象 ``NDArray``、``ADT`` 和 ``Closure`` "
"对象，分别用来表示张量、元组/列表和闭包数据。它们的详细信息可以分别在 "
"[include/tvm/runtime/ndarray.h](https://github.com/apache/tvm/blob/main/include/tvm/runtime/ndarray.h)、[include/tvm/runtime/vm/vm.h](https://github.com/apache/tvm/blob/main/include/tvm/runtime/vm/vm.h)"
" 和 "
"[include/tvm/runtime/container.h](https://github.com/apache/tvm/blob/main/include/tvm/runtime/container.h)"
" 中找到。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:197
msgid "Stack and State"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:199
msgid ""
"Relay VM 维护了 stack frame，其中包含关于如何恢复前一个调用的信息。在连续空间（虚拟 register 文件）中为每个函数分配"
" register。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:201
msgid "跟踪已调用的一组 Relay 函数，一个指向其字节码的指针，一个指向字节码的偏移量（称为程序计数器（program counter））。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:218
msgid "Dispatch Loop"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:220
msgid ""
"VM 的关键部分是 dispatch loop。dispatch loop 通常支配虚拟机的执行时间，但通过实验发现，对于 Relay "
"来说并非如此。刚刚实现了简单的 ``switch``/``goto`` dispatch loop，它基于 instruction op code"
" 进行 dispatch。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:222
msgid "此循环由 ``VirtualMachine::Run()`` 实现。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:224
msgid "VM Compiler"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:226
msgid ""
"这个基础结构的一个重要部分是编译器，从 Relay 的完整 IR 到 bytecode 序列。VM 编译器会将 "
"``tvm::relay::Module`` 变换为 "
"``tvm::relay::vm::Executable``。可执行文件包含一组编译函数，编译函数包含在 "
"``tvm::relay::vm::Function`` 中。函数包含关于函数的元数据以及已编译的字节码。然后，发出的可执行对象可以通过 "
"``tvm::relay::vm::VirtualMachine`` 对象加载和运行。有关数据结构的完整定义，请参见 "
"[include/tvm/runtime/vm/executable.h](https://github.com/apache/tvm/blob/main/include/tvm/runtime/vm/executable.h)"
" 和 "
"[include/tvm/runtime/vm/vm.h](https://github.com/apache/tvm/blob/main/include/tvm/runtime/vm/vm.h)。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:228
msgid "优化"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:230
msgid "VM 编译器需要相当多的优化。它们中的每一个都被实现为由 Relay pass manager 管理的 pass。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:232
msgid "标记为 `TODO` 的优化还没有实现。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:234
msgid "A-Normal Form"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:235
msgid ""
"Lambda Lift (see "
"[src/relay/vm/lambda_lift.cc](https://github.com/apache/tvm/blob/main/src/relay/backend/vm/lambda_lift.cc))"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:236
msgid ""
"Inline Primitives (see "
"[src/relay/vm/inline_primitives.cc](https://github.com/apache/tvm/blob/main/src/relay/backend/vm/inline_primitives.cc))"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:237
msgid ""
"Constant Pool Layout (see "
"[src/relay/backend/vm/compiler.cc](https://github.com/apache/tvm/blob/main/src/relay/backend/vm/compiler.cc))"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:238
msgid "Tail Call Optimization (TODO)"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:239
msgid "Liveness Analysis (TODO)"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:241
msgid "序列化"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:243
msgid ""
"序列化和反序列化由 Relay VM 编译器生成的可执行文件是必须的，因为可能想要将模型保存到磁盘上，然后执行推断。之前，Relay 已经在 "
"json 文件中为图执行器生成了序列化的形式。但是，同样的格式并不直接适用于 "
"VM，因为它会发出字节码，而不是图风格的程序。可执行文件的序列化本质上需要处理模型特定的（如 weights 和 kernels）和 VM "
"相关的（如字节码和全局函数名）数据。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:245
msgid ""
"对于 kernels，可以方便地利用现有的 TVM infra "
"来保存和加载已编译的库模块。这里只关注以二进制格式序列化其他几个组件，这些二进制格式按照以下部分的顺序组织。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:247
msgid "全局部分：包含虚拟机使用的全局变量（函数名）。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:248
msgid "Constant 部分：用于存储虚拟机的 constant pool（即模型的 weights）。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:249
msgid ""
"原语名称部分：为了适应将由虚拟机调用的原语算子名称列表（即以 ``fused_`` 开头的名称）引入。原语名称被用作在编译后的 kernel "
"库中查找函数指针的符号。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:250
msgid "Code 部分：VM 函数，包括字节码，都在这个部分。dispatching 循环遍历本部分以获取执行指令。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:252
msgid ""
"因此，与包含权重（`.params`）、graph json （.json）和编译的 kernel "
"库（`.so`）的图执行器工件不同，序列化的可执行工件是由 Relay 对象文件（`.ro`）和编译的 kernel 库（`.so`）组成的。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:254
msgid ""
"实现了 ``save`` 函数来将可执行文件存储到磁盘并将其序列化为上述格式。同时，使用 ``load_exec`` 函数加载序列化的 "
"kernel 二进制和可执行的相关二进制代码，这些代码将再次用于实例化 VM 对象。更多示例请参考 "
"[test_vm_serialization.py](https://github.com/apache/tvm/blob/main/tests/python/relay/test_vm_serialization.py)。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:256
msgid "未解决的问题"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:258
msgid "如何处理动态形状？"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:260
msgid ""
"动态形状支持是 TVM 升级 Relay，TVM 编译器正在进行的工作。关于动态形状支持的最新更新，建议在 TVM "
"的讨论[论坛](https://discuss.tvm.apache.org/)中进行追踪更新。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:262
msgid "如何修改 VM 以支持 JIT 编译某些代码路径？"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:264
msgid "在代码生成空间中，仍然有许多需要分析的权衡，VM 被设计得非常灵活，所以可以为未来的实验修改它。"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:266
msgid "如何支持异构执行？"
msgstr ""

#: ../../xin/docs/arch/virtual_machine.md:268
msgid "异构执行应该是开箱即用的，假设已经注解了适当的设备副本。为了正确地做到这一点，需要运行设备 annotation 和 copying passes。"
msgstr ""

#~ msgid "Putting the VM in TVM: The Relay Virtual Machine"
#~ msgstr ""

#~ msgid ""
#~ "Relay, a new program representation, has"
#~ " enabled the representation and "
#~ "optimization of a great breadth of "
#~ "machine learning programs. Unfortunately, by"
#~ " supporting a more expressive set of"
#~ " programs, we have introduced several "
#~ "new execution challenges."
#~ msgstr ""

#~ msgid ""
#~ "Relay's interpreter can execute the full"
#~ " language but has notable limitations "
#~ "that make it unsuited for production "
#~ "deployments. It is structured as an "
#~ "inefficient interpreter that performs AST "
#~ "traversal to execute the program. This"
#~ " approach is conceptually simple but "
#~ "inefficient, as the AST traversal "
#~ "heavily relies on indirection."
#~ msgstr ""

#~ msgid ""
#~ "There are further challenges in "
#~ "compiling dynamic code, such as dynamic"
#~ " scheduling and allocation, fully dynamic"
#~ " tensor shapes, and control flow. The"
#~ " interpreter offers simple solutions for"
#~ " these, but none is sufficiently "
#~ "compelling or optimized."
#~ msgstr ""

#~ msgid ""
#~ "The second execution mechanism is the"
#~ " existing graph executor. In order to"
#~ " target Relay programs to this, we"
#~ " compile a small subset of them "
#~ "to the old graph format and "
#~ "execute them on the runtime. Graph "
#~ "executor provides a fast execution "
#~ "experience but only for a very "
#~ "limited subset of Relay programs."
#~ msgstr ""

#~ msgid ""
#~ "An alternative but not-standard approach"
#~ " is Relay's ahead-of-time compiler,"
#~ " which compiles a Relay program into"
#~ " a shared library containing an "
#~ "ahead-of-time implementation. The ahead-"
#~ "of-time compiler provides compelling "
#~ "performance but is difficult to extend"
#~ " and instrument, which can only be"
#~ " done by modifying the code "
#~ "generation and optimization mechanisms."
#~ msgstr ""

#~ msgid ""
#~ "The Relay virtual machine is intended"
#~ " to be a framework that balances "
#~ "these competing approaches, providing a "
#~ "dynamic execution environment which can "
#~ "be extended, instrumented, and integrated "
#~ "with other approaches like ahead-of-"
#~ "time compilation via a flexible "
#~ "extension mechanism."
#~ msgstr ""

#~ msgid ""
#~ "The virtual machine is designed to "
#~ "strike a balance between performance and"
#~ " flexibility when deploying and executing"
#~ " Relay programs, without giving up "
#~ "the benefits of TVM."
#~ msgstr ""

#~ msgid ""
#~ "Virtual machine (VM) design is a "
#~ "well-studied area in programming languages"
#~ " and systems, and there have been "
#~ "various virtual machine designs for both"
#~ " full-fledged and embedded programing "
#~ "languages. Previous language VM designs "
#~ "have been heavily tailored to the "
#~ "execution profile of traditional programs. "
#~ "Traditional programs manipulate small scalar"
#~ " values and consist of a large "
#~ "number of low-level instructions. The"
#~ " sheer quantity of instructions requires"
#~ " instruction execution and dispatch to "
#~ "be extremely efficient. In the context"
#~ " of machine learning we manipulate "
#~ "primarily tensor values, using a "
#~ "(relatively) low number of high level"
#~ " instructions. ML programs' cost centers"
#~ " are expensive operator invocations, such"
#~ " as GEMM or convolution, over a "
#~ "large input. Due to the execution "
#~ "profile exhibited by ML programs, "
#~ "micro-optimizations present in scalar VMs"
#~ " are dramatically less important."
#~ msgstr ""

#~ msgid ""
#~ "TVM has provided strong support for "
#~ "vision models, but we want to grow"
#~ " to support a wider variety of "
#~ "models. The graph executor is able "
#~ "to utilize the fully static nature "
#~ "of the input graphs to perform "
#~ "aggressive optimization such as fully "
#~ "static allocation, and optimal memory "
#~ "reuse. When we introduce models which"
#~ " make use of control flow, recursion,"
#~ " dynamic shapes, and dynamic allocation,"
#~ " we must change how execution works."
#~ " A virtual machine for Relay is "
#~ "a natural choice."
#~ msgstr ""

#~ msgid ""
#~ "The rest of this document provides "
#~ "a high-level overview of the Relay"
#~ " virtual machine design and its "
#~ "instruction set."
#~ msgstr ""

#~ msgid "Design"
#~ msgstr ""

#~ msgid ""
#~ "The VM's design is focused on "
#~ "simplicity without sacrificing performance. In"
#~ " order to accomplish this we have "
#~ "focused on designing a tensor VM "
#~ "rather than a scalar VM."
#~ msgstr ""

#~ msgid ""
#~ "In the tensor VM setting, we "
#~ "optimize for cheap “allocation” of "
#~ "objects (by trying to avoid real "
#~ "allocation), reuse of static fragments, "
#~ "and the ability to do dynamic "
#~ "shape (i.e jagged tensors)."
#~ msgstr ""

#~ msgid "Instruction Set"
#~ msgstr ""

#~ msgid ""
#~ "The choices of an instruction set "
#~ "and instruction representation are the "
#~ "most critical design decisions for a "
#~ "VM. The current representation of the"
#~ " instructions is a tagged union "
#~ "containing the op-code and the "
#~ "data payload.  An important design "
#~ "decision is the level of abstraction "
#~ "of the instructions (RISC vs. CISC) "
#~ "and how they take their data "
#~ "(fixed-width instruction encoding vs. "
#~ "variable-length encoding). The current "
#~ "version is closer to CISC, with "
#~ "complex instructions like AllocTensor, and "
#~ "is variable-length due to the "
#~ "inclusion of the shape as part of"
#~ " the instruction. The current instruction"
#~ " set is very high-level and "
#~ "corresponds roughly to high-level "
#~ "operations in Relay."
#~ msgstr ""

#~ msgid "**Arguments**: ::"
#~ msgstr ""

#~ msgid "Returns the object in register ``result`` to caller's register ``dst``."
#~ msgstr ""

#~ msgid ""
#~ "Invoke the packed function denoted by"
#~ " ``packed_index``. The ``arity`` and "
#~ "``output_size`` are used to inform the"
#~ " VM how many inputs and outputs "
#~ "to expect. ``packed_args`` stores the "
#~ "list of argument registers. Note "
#~ "``Index`` is an alias of ``int64_t``,"
#~ " and it will be used in other"
#~ " instructions as well."
#~ msgstr ""

#~ msgid ""
#~ "Allocate a tensor value of using "
#~ "constant shape (stored in ``shape``) and"
#~ " ``dtype`` from the given storage "
#~ "block, ``storage``. The result is saved"
#~ " to register ``dst``."
#~ msgstr ""

#~ msgid ""
#~ "Allocate a tensor value of the "
#~ "appropriate shape (stored in "
#~ "``shape_register``) and ``dtype`` from the "
#~ "given storage block (stored in "
#~ "``storage``). The result is saved to "
#~ "register ``dst``."
#~ msgstr ""

#~ msgid ""
#~ "Allocate a storage block with the "
#~ "given ``size``, ``alignment`` and data "
#~ "type, ``dtype_hint``. The allocated storage"
#~ " block is stored in register ``dst``."
#~ msgstr ""

#~ msgid ""
#~ "Allocate a data type with the tag"
#~ " ``tag`` using the ``num_fields`` entries"
#~ " from registers ``datatype_fields``. The "
#~ "result is saved to register ``dst``."
#~ msgstr ""

#~ msgid ""
#~ "Allocate a closure with the VMFunction"
#~ " at ``clo_index`` as its code, and"
#~ " the ``num_freevar`` entries from registers"
#~ " in ``free_vars``. The result is "
#~ "saved to register ``dst``."
#~ msgstr ""

#~ msgid ""
#~ "Get the field value with index "
#~ "``field_index`` from ``object``. And saves "
#~ "the result to register ``dst``."
#~ msgstr ""

#~ msgid ""
#~ "Check if the object at register "
#~ "``test`` is equal to ``target``. If "
#~ "equal, relative jump by ``true_offset``, "
#~ "else relative jump by ``false_offset``."
#~ msgstr ""

#~ msgid ""
#~ "Get the object tag for ADT object"
#~ " in register ``object``. And saves "
#~ "the reult to register ``dst``."
#~ msgstr ""

#~ msgid "Fail the virtual machine execution."
#~ msgstr ""

#~ msgid "Relative unconditional jump by ``pc_offset``."
#~ msgstr ""

#~ msgid ""
#~ "Invoke function at ``func_index``, consumes"
#~ " the number of arguments contained in"
#~ " the VMFunction's arity field."
#~ msgstr ""

#~ msgid ""
#~ "Invokes ``closure``, consuming the number "
#~ "of arguments declared in the closure's"
#~ " VMFunction."
#~ msgstr ""

#~ msgid ""
#~ "Load the constant at ``const_index`` "
#~ "from the constant pool. The result "
#~ "is saved to register ``dst``."
#~ msgstr ""

#~ msgid ""
#~ "Load the constant integer ``val`` to "
#~ "register ``dst``. The result is a "
#~ "0-rank tensor."
#~ msgstr ""

#~ msgid "Object Representation"
#~ msgstr ""

#~ msgid ""
#~ "We leverage the object protocol to "
#~ "represent the objects that are used "
#~ "by the VM."
#~ msgstr ""

#~ msgid ""
#~ "Currently, three types of objects, "
#~ "``NDArray``, ``ADT``, and ``Closure`` objects,"
#~ " are used to represent tensor, "
#~ "tuple/list, and closure data, respectively."
#~ " More details for each of them "
#~ "can be found at "
#~ "`include/tvm/runtime/ndarray.h`_, "
#~ "`include/tvm/runtime/vm/vm.h`_, and "
#~ "`include/tvm/runtime/container.h`_, respectively."
#~ msgstr ""

#~ msgid ""
#~ "The Relay VM maintains a stack "
#~ "frame, which contains information about "
#~ "how to resume the previous call. "
#~ "Registers are allocated in a continuous"
#~ " space (virtual register file) for "
#~ "each function."
#~ msgstr ""

#~ msgid ""
#~ "We keep track of a set of "
#~ "Relay functions we have called, a "
#~ "pointer into its bytecode, an offset "
#~ "into the byte code (known as the"
#~ " program counter)."
#~ msgstr ""

#~ msgid ""
#~ "A critical piece of a VM is "
#~ "the dispatch loop. The dispatch loop "
#~ "usually dominates the execution time of"
#~ " a virtual machine, but we have "
#~ "experimentally found this not to be "
#~ "the case for Relay. We have just"
#~ " implemented a simple ``switch``/``goto`` "
#~ "dispatch loop which dispatches based on"
#~ " instruction op code."
#~ msgstr ""

#~ msgid "This loop is implemented by ``VirtualMachine::Run()``."
#~ msgstr ""

#~ msgid ""
#~ "An important part of this infrastructure"
#~ " is a compiler from Relay's full "
#~ "IR into a sequence of bytecode. "
#~ "The VM compiler transforms a "
#~ "``tvm::relay::Module`` into a "
#~ "``tvm::relay::vm::Executable``. The executable "
#~ "contains a set of compiled functions,"
#~ " the compiled functions are contained "
#~ "in ``tvm::relay::vm::Function``. The functions "
#~ "contain metadata about the function as"
#~ " well as its compiled bytecode. The"
#~ " emitted executable object then can "
#~ "be loaded and run by a "
#~ "``tvm::relay::vm::VirtualMachine`` object. For full"
#~ " definitions of the data structures, "
#~ "please see `include/tvm/runtime/vm/executable.h`_ "
#~ "and `include/tvm/runtime/vm/vm.h`_."
#~ msgstr ""

#~ msgid "Optimizations"
#~ msgstr ""

#~ msgid ""
#~ "There are quite a few optimizations "
#~ "required by the VM compiler. Each "
#~ "of them is implemented as a pass"
#~ " which is managed by the Relay "
#~ "pass manager."
#~ msgstr ""

#~ msgid "Optimizations marked with `TODO` are not implemented yet."
#~ msgstr ""

#~ msgid "Lambda Lift (see `src/relay/vm/lambda_lift.cc`_)"
#~ msgstr ""

#~ msgid "Inline Primitives (see `src/relay/vm/inline_primitives.cc`_)"
#~ msgstr ""

#~ msgid "Constant Pool Layout (see `src/relay/backend/vm/compiler.cc`_)"
#~ msgstr ""

#~ msgid "Serialization"
#~ msgstr ""

#~ msgid ""
#~ "Serializing and deserializing the executable"
#~ " generated by the Relay VM compiler"
#~ " is a must as we may want "
#~ "to save the model to the disk "
#~ "and perform inference later. Previously, "
#~ "Relay has produced a serialized form "
#~ "in a json file for the graph "
#~ "executor. However, the same format is"
#~ " not directly applicable to the VM"
#~ " as it emits bytecode instead of "
#~ "graph-style programs. Serialization of "
#~ "an executable essentially needs to "
#~ "handle both model specific (i.e. weights"
#~ " and kernels) and VM related (i.e."
#~ " bytecode and global function names) "
#~ "data."
#~ msgstr ""

#~ msgid ""
#~ "For kernels, we can conveniently "
#~ "leverage existing TVM infra to save "
#~ "and load the compiled library module."
#~ " Here we only focus on serializing"
#~ " other several components in a binary"
#~ " format that is organized with the"
#~ " following sections in order."
#~ msgstr ""

#~ msgid ""
#~ "Global section. This section contains "
#~ "the globals (function names) used by "
#~ "the virtual machine."
#~ msgstr ""

#~ msgid ""
#~ "Constant section. This section is used"
#~ " to store the constant pool (i.e. "
#~ "weights of the model) for a "
#~ "virtual machine."
#~ msgstr ""

#~ msgid ""
#~ "Primitive name section. This section is"
#~ " introduced to accommodate the list "
#~ "of primitive operator names that will"
#~ " be invoked by the virtual machine,"
#~ " i.e. the names starting with "
#~ "``fused_``. The primitive names are used"
#~ " as symbols to look up function "
#~ "pointers in the compiled kernel library."
#~ msgstr ""

#~ msgid ""
#~ "Code section. The VM functions, "
#~ "including bytecode, are sitting in this"
#~ " section. The dispatching loop iterates "
#~ "through this section to fetch "
#~ "instructions for execution."
#~ msgstr ""

#~ msgid ""
#~ "Hence, unlike the graph executor "
#~ "artifact that contains weight (.params), "
#~ "graph json (.json), and compiled kernel"
#~ " library (.so), the serialized executable"
#~ " artifact is composed of the Relay"
#~ " object file (.ro) and the compiled"
#~ " kernel library (.so)."
#~ msgstr ""

#~ msgid ""
#~ "A ``save`` function is implemented to"
#~ " store the executable to the disk "
#~ "and serialize it into the above "
#~ "format. Meanwhile, a ``load_exec`` function"
#~ " is used to load the serialized "
#~ "kernel binary and executable related "
#~ "binary code, which will be again "
#~ "used to instantiate a VM object. "
#~ "Please refer to the "
#~ "`test_vm_serialization.py`_ file for more "
#~ "examples."
#~ msgstr ""

#~ msgid "Unresolved Questions"
#~ msgstr ""

#~ msgid "How do we handle dynamic shapes?"
#~ msgstr ""

#~ msgid ""
#~ "Dynamic shape support is ongoing work"
#~ " in TVM as we upgrade Relay, "
#~ "TVM's compiler.  For the most recent "
#~ "updates on dynamic shape support, we "
#~ "recommend following updates in TVM's "
#~ "Discuss forum (https://discuss.tvm.apache.org/)."
#~ msgstr ""

#~ msgid ""
#~ "How can we modify the VM to "
#~ "support JIT compilation of certain code"
#~ " paths?"
#~ msgstr ""

#~ msgid ""
#~ "In the code generation space there "
#~ "are still many tradeoffs to be "
#~ "analyzed and the VM is designed to"
#~ " be very flexible so we can "
#~ "modify it for future experiments."
#~ msgstr ""

#~ msgid "How do we support heterogenous execution?"
#~ msgstr ""

#~ msgid ""
#~ "Heterogenous execution should work out "
#~ "of the box assuming we have "
#~ "annotated the appropriate device copies. "
#~ "In order to do this properly we"
#~ " need to run the device annotation"
#~ " and copying passes."
#~ msgstr ""

