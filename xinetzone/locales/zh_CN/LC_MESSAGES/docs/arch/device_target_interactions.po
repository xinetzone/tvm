# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, xinetzone
# This file is distributed under the same license as the tvm package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tvm doc\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-06-13 13:14+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../doc/docs/arch/device_target_interactions.rst:22
msgid "Device/Target Interactions"
msgstr "Device/Target 交互"

#: ../../doc/docs/arch/device_target_interactions.rst:24
msgid ""
"This documented is intended for developers interested in understanding "
"how the TVM framework interacts with specific device APIs, or who may "
"want to implement support for a new API or new hardware."
msgstr "本文档旨在为对理解 TVM 框架如何与特定设备 API 交互感兴趣的开发者提供指导，或者那些想要实现对新 API 或新硬件支持的开发者。"

#: ../../doc/docs/arch/device_target_interactions.rst:28
msgid ""
"There are three main aspects that must be implemented for any new runtime"
" environment."
msgstr "为了构建任何新的运行时环境，必须落实三个主要方面。"

#: ../../doc/docs/arch/device_target_interactions.rst:31
msgid ""
"The :ref:`DeviceAPI <tvm-target-specific-device-api>` class gives a "
"handle to a specific device, and the API used to interact with it. It "
"defines a common interface for querying device parameters (e.g. memory "
"available, number of threads, etc.) and for performing simple actions "
"(e.g. copying memory from the host, or between buffers on the device)."
msgstr ""
":ref:`DeviceAPI <tvm-target-specific-device-api>` 类提供了特定设备的句柄，以及与之交互的 "
"API。它定义了通用接口，用于查询设备参数（例如可用内存、线程数等），以及执行简单操作（例如从主机复制内存或在设备上的缓冲区之间复制）。"

#: ../../doc/docs/arch/device_target_interactions.rst:38
msgid ""
"The :ref:`Target <tvm-target-specific-target>` class contains a "
"description of the device on which a function will run.  It is exposed "
"both to the target code generators and to the optimization passes."
msgstr ""
":ref:`Target <tvm-target-specific-target>` "
"类包含了描述函数运行设备的说明。它既对目标代码生成器开放，也对优化过程开放。"

#: ../../doc/docs/arch/device_target_interactions.rst:43
msgid ""
"The :ref:`target code generators <tvm-target-specific-codegen>` construct"
" a :ref:`Module <tvm-runtime-system-module>` consisting of one or more "
":ref:`PackedFunc <tvm-runtime-system-packed-func>`, from an IRModule."
msgstr ""
":ref:`目标代码生成器 <tvm-target-specific-codegen>` 构建由一个或多个 :ref:`PackedFunc "
"<tvm-runtime-system-packed-func>` 组成的来自 IRModule 的 :ref:`模块 <tvm-runtime-"
"system-module>`。\""

#: ../../doc/docs/arch/device_target_interactions.rst:51
msgid "DeviceAPI"
msgstr ""

#: ../../doc/docs/arch/device_target_interactions.rst:53
msgid ""
"The ``DeviceAPI`` represents a handle to a specific hardware device API."
"  (e.g. ``CUDADeviceAPI`` handles all interactions through the CUDA "
"framework.)  Most ``DeviceAPI`` methods accept a ``device_id`` parameter "
"to specify which device should be accessed.  In Python, these are "
"typically accessed using the :py:func:`tvm.runtime.device` function, "
"which returns a handle to a specific device, accessed through a specific "
"API.  (e.g. ``tvm.runtime.device('cuda',0)`` gives access to physical "
"device ``0``, accessed through the CUDA API.)"
msgstr ""
"``DeviceAPI`` 表示对特定硬件设备 API 的句柄。（例如，``CUDADeviceAPI`` 处理通过 CUDA "
"框架进行的所有交互。）大多数 ``DeviceAPI`` 方法接受 ``device_id`` 参数，用于指定应访问哪个设备。在 Python "
"中，通常使用 :py:func:`tvm.runtime.device` 函数来访问这些设备，该函数返回通过特定 API "
"访问的特定设备的句柄。（例如，``tvm.runtime.device('cuda',0)`` 提供对物理设备 ``0`` 的访问，该设备通过 "
"CUDA API 进行访问。）"

#: ../../doc/docs/arch/device_target_interactions.rst:64
msgid ""
"Attribute queries - ``GetAttr`` allows different device-specific "
"parameters to be queried, such as the device name, number of threads, "
"etc.  The parameters that can be queried are defined in ``enum "
"DeviceAttrKind`` in `device_api.h`_.  Not all query-able parameters are "
"supported by all devices.  If a parameter cannot be queried (e.g. "
"``kMaxClockRate`` on Vulkan), or if a parameter isn't applicable (e.g. "
"``kWarpSize`` on CPU), then those queries should return ``nullptr``."
msgstr ""
"属性查询 - ``GetAttr`` 允许查询不同的设备特定参数，例如设备名称、线程数量等。可查询的参数定义在 `device_api.h`_ "
"中的 ``enum DeviceAttrKind`` 枚举中。并非所有设备都支持所有可查询的参数。如果某个参数无法查询（例如 Vulkan 上的 "
"``kMaxClockRate``），或者某个参数不适用（例如 CPU 上的 ``kWarpSize``），则这些查询应返回 "
"``nullptr``。"

#: ../../doc/docs/arch/device_target_interactions.rst:73
msgid ""
"Setting active device - ``SetDevice`` should set a particular device as "
"being active.  If a ``PackedFunc`` generated by the target-specific code "
"gen requires execution on a device, it should run on the active device."
msgstr ""
"设置活动设备 - ``SetDevice`` 应将特定设备设置为活动状态。如果由目标特定代码生成器生成的 ``PackedFunc`` "
"需要在设备上执行，则它应在活动设备上运行。"

#: ../../doc/docs/arch/device_target_interactions.rst:78
msgid ""
"Memory management - Utilities for allocating and deallocating memory on "
"the device."
msgstr "内存管理 - 提供在设备上分配和释放内存的工具。"

#: ../../doc/docs/arch/device_target_interactions.rst:81
msgid ""
"Allocate data space - ``AllocDataSpace`` and ``FreeDataSpace`` allocate "
"and free space on the device.  These allocations can be provided as "
"inputs and outputs to an operator and make up the primary data flow of "
"the operator graph.  It must be possible to transfer data from the host "
"to/from a data space.  The return value is an opaque ``void*``.  While "
"some implementations return a memory address, this is not required, and "
"the ``void*`` may be an opaque handle that is interpretable only by the "
"device backend that generated it.  The ``void*`` is used as an argument "
"to other backend-specific functions, such as ``CopyDataFromTo``."
msgstr ""
"分配数据空间 - ``AllocDataSpace`` 和 ``FreeDataSpace`` "
"用于在设备上分配和释放空间。这些分配可以作为算子的输入和输出，并构成算子图的主要数据流。必须能够将数据从主机传输到数据空间或从数据空间传输到主机。返回值是不透明的"
" ``void*``。虽然某些实现返回内存地址，但这并非必需，``void*`` 可能是仅由生成它的设备后端解释的不透明句柄。``void*`` "
"用作其他后端特定函数（例如 ``CopyDataFromTo``）的参数。"

#: ../../doc/docs/arch/device_target_interactions.rst:92
msgid ""
"Allocate work space - ``AllocWorkspace`` and ``FreeWorkspace`` allocate "
"and free space on the device.  Unlike data space, these are used for "
"storage of intermediate values within an operator definition, and are not"
" required to be transferable to/from the host device.  If a ``DeviceAPI``"
" subclass does not implement these methods, they will default to calling "
"the corresponding ``DataSpace`` functions."
msgstr ""
"分配工作空间 - ``AllocWorkspace`` 和 ``FreeWorkspace`` "
"用于在设备上分配和释放空间。与数据空间不同，这些空间用于存储算子定义中的中间值，并且不需要能够在主机设备之间传输。如果 ``DeviceAPI``"
" 的子类未实现这些方法，它们将默认调用相应的 ``DataSpace`` 函数。"

#: ../../doc/docs/arch/device_target_interactions.rst:100
msgid ""
"Copy data - ``CopyDataFromTo`` should copy data from one location to "
"another.  The type of copy is determined by the ``dev_from`` and "
"``dev_to`` parameters.  Implementations should support copying memory "
"from CPU to device, from device to CPU, and from one buffer to another on"
" a single device.  If the source or destination locations are on the CPU,"
" the corresponding ``void*`` points to a CPU address that can be passed "
"into ``memcpy``.  If the source or destinations locations are on the "
"device, the corresponding ``void*`` was previously generated by either "
"``AllocDataSpace`` or ``AllocWorkspace``."
msgstr ""
"复制数据 - ``CopyDataFromTo`` 应将数据从一个位置复制到另一个位置。复制的类型由 ``dev_from`` 和 "
"``dev_to`` 参数决定。实现应支持从 CPU 复制到设备、从设备复制到 CPU，以及在单个设备上的缓冲区之间复制数据。如果源或目标位置在 "
"CPU 上，则相应的 ``void*`` 指向可以传递给 ``memcpy`` 的 CPU 地址。如果源或目标位置在设备上，则相应的 "
"``void*`` 先前由 ``AllocDataSpace`` 或 ``AllocWorkspace`` 生成。"

#: ../../doc/docs/arch/device_target_interactions.rst:111
msgid ""
"These copies are queued to execute on a specific ``TVMStreamHandle``.  "
"However, implementations should not assume that CPU buffers remains valid"
" or accessible after the call to ``CopyDataFromTo`` completes."
msgstr ""
"这些复制操作会被排队在特定的 ``TVMStreamHandle`` 上执行。然而，实现不应假设在调用 ``CopyDataFromTo`` "
"完成后，CPU 缓冲区仍然有效或可访问。"

#: ../../doc/docs/arch/device_target_interactions.rst:117
msgid ""
"Execution stream management - Utilities for handling ``TVMStreamHandle``,"
" which represents parallel streams of execution used to execute commands."
msgstr "执行流管理 - 用于处理 ``TVMStreamHandle`` 的工具，``TVMStreamHandle`` 表示用于执行命令的并行执行流。"

#: ../../doc/docs/arch/device_target_interactions.rst:121
msgid ""
"Create stream - ``CreateStream`` and ``FreeStream`` should allocate/free "
"a handle to a stream of execution. If a device implements only a single "
"queue of commands, then ``CreateStream`` should return ``nullptr``."
msgstr ""
"创建流 - ``CreateStream`` 和 ``FreeStream`` 应分配/释放一个执行流的句柄。如果设备仅实现单个命令队列，则 "
"``CreateStream`` 应返回 ``nullptr``。"

#: ../../doc/docs/arch/device_target_interactions.rst:126
msgid ""
"Set active stream - ``SetStream`` should set a stream as being active.  "
"While active, if a ``PackedFunc`` generated by the target-specific code "
"gen requires execution on a device, the work should be submitted to the "
"active stream."
msgstr ""
"设置活动流 - ``SetStream`` 应将流设置为活动状态。在活动状态下，如果由目标特定代码生成器生成的 ``PackedFunc`` "
"需要在设备上执行，则工作应提交到活动流中。"

#: ../../doc/docs/arch/device_target_interactions.rst:131
msgid ""
"Synchronize to CPU - ``StreamSync`` should synchronize a stream of "
"execution to the CPU.  The call to ``StreamSync`` should return once all "
"memory transfers and computations submitted prior to the ``StreamSync`` "
"call have completed."
msgstr ""
"与 CPU 同步 - ``StreamSync`` 应将执行流与 CPU 同步。在 ``StreamSync`` "
"调用之前提交的所有内存传输和计算完成后，``StreamSync`` 的调用才会返回。"

#: ../../doc/docs/arch/device_target_interactions.rst:136
msgid ""
"Synchronize between streams - ``SyncStreamFromTo`` should introduce a "
"synchronization barrier between the source and destination stream.  That "
"is, the destination stream may not proceed beyond commands currently "
"queued until the source stream has completed all commands that are "
"currently queued."
msgstr ""
"流之间的同步 - ``SyncStreamFromTo`` "
"应在源流和目标流之间引入同步屏障。也就是说，在源流完成当前排队的所有命令之前，目标流不得继续执行当前排队的命令。"

#: ../../doc/docs/arch/device_target_interactions.rst:143
msgid ""
"In order to be usable by the TVM framework, the new DeviceAPI should then"
" be registered with the following steps."
msgstr "为了能够被 TVM 框架使用，新的 DeviceAPI 应按照以下步骤进行注册。"

#: ../../doc/docs/arch/device_target_interactions.rst:146
msgid ""
"Create a function that instantiates the new DeviceAPI, and returns a "
"pointer to it::"
msgstr "创建函数来实例化新的 DeviceAPI，并返回指向它的指针::"

#: ../../doc/docs/arch/device_target_interactions.rst:154
msgid "Register the function to the tvm registry::"
msgstr "将该函数注册到 tvm 注册表中::"

#: ../../doc/docs/arch/device_target_interactions.rst:160
#, fuzzy
msgid ""
"Add an entry for the new DeviceAPI to the ``TVMDeviceExtType`` enum in "
"`base.h`_.  The value should be an unused value greater than "
"``DLDeviceType::kDLExtDev``, but less than "
"``DeviceAPIManager::kMaxDeviceAPI``."
msgstr ""
"在 `c_runtime_api.h`_ 中的 ``TVMDeviceExtType`` 枚举中添加新 DeviceAPI 的条目。该值应为大于 "
"``DLDeviceType::kDLExtDev`` 但小于 ``DeviceAPIManager::kMaxDeviceAPI`` "
"的未使用值。"

#: ../../doc/docs/arch/device_target_interactions.rst:165
#, fuzzy
msgid ""
"Add a case in ``DeviceName`` in `device_api.h`_ to convert from the enum "
"value to a string representation.  This string representation should "
"match the name given to ``TVM_FFI_REGISTER_GLOBAL``."
msgstr ""
"在 `device_api.h`_ 中的 ``DeviceName`` 函数中添加 case，将枚举值转换为字符串表示形式。该字符串表示形式应与 "
"``TVM_REGISTER_GLOBAL`` 中给出的名称匹配。"

#: ../../doc/docs/arch/device_target_interactions.rst:169
#, fuzzy
msgid ""
"Add entries to the ``DEVICE_TYPE_TO_NAME`` and ``DEVICE_NAME_TO_TYPE`` "
"dictionaries of :py:class:`tvm.runtime.Device` for the new enum value."
msgstr ""
"为新的枚举值在 :py:class:`tvm.runtime.Device` 的 ``MASK2STR`` 和 ``STR2MASK`` "
"字典中添加条目。"

#: ../../doc/docs/arch/device_target_interactions.rst:176
msgid "Target Definition"
msgstr "目标定义"

#: ../../doc/docs/arch/device_target_interactions.rst:178
msgid ""
"The ``Target`` object is a lookup table of properties about a physical "
"device, its hardware/driver limits, and its capabilities.  The ``Target``"
" is accessible both during optimization and code generation stages.  "
"While the same ``Target`` class is used for all runtime targets, each "
"runtime target may need to add target-specific options."
msgstr ""
"``Target`` 对象是关于物理设备、其硬件/驱动程序限制及其功能的属性查找表。``Target`` "
"在优化和代码生成阶段均可访问。虽然所有运行时目标都使用相同的 ``Target`` 类，但每个运行时目标可能需要添加特定于目标的选项。"

#: ../../doc/docs/arch/device_target_interactions.rst:186
msgid ""
"In `target_kind.cc`_, add a new declaration of "
"``TVM_REGISTER_TARGET_KIND``, passing a string name of the new target, "
"and the ``TVMDeviceExtType`` or ``DLDeviceType`` enum value for the "
"device on which that target should run.  Typically, the target name and "
"the device name will match.  (e.g. The ``\"cuda\"`` target runs on the "
"``kDLCUDA`` device.)  There are exceptions, such as when multiple "
"different code generation targets can run on the same physical device. "
"(e.g. The ``\"llvm\"`` and ``\"c\"`` targets both run on the ``kDLCPU`` "
"device type.)"
msgstr ""
"在 `target_kind.cc`_ 中，添加新的 ``TVM_REGISTER_TARGET_KIND`` "
"声明，传递新目标的字符串名称，以及该目标应运行的设备的 ``TVMDeviceExtType`` 或 ``DLDeviceType`` "
"枚举值。通常，目标名称和设备名称会匹配。（例如，``\"cuda\"`` 目标在 ``kDLCUDA`` "
"设备上运行。）但也有例外情况，例如当多个不同的代码生成目标可以在同一物理设备上运行时。（例如，``\"llvm\"`` 和 ``\"c\"`` "
"目标都在 ``kDLCPU`` 设备类型上运行。）"

#: ../../doc/docs/arch/device_target_interactions.rst:196
msgid ""
"All options for a specific target kind are added with the "
"``add_attr_option`` function, with optional default values.  A `Target` "
"parser can be added with ``set_target_parser`` to process any parameters "
"that are dynamically based on other parameters or queried from device "
"properties."
msgstr ""
"特定目标类型的所有选项都通过 ``add_attr_option`` 函数添加，并可选择提供默认值。可以通过 "
"``set_target_parser`` 添加 `Target` 解析器，以处理基于其他参数动态生成或从设备属性查询的参数。"

#: ../../doc/docs/arch/device_target_interactions.rst:202
#, python-brace-format
msgid ""
"This argument definition defines a parser that can unpack a string "
"description of a target.  This is done in the ``Target::Target(const "
"String&)`` constructor in C++, which accepts a JSON-formatted string and "
"is typically called using the :py:class:`tvm.target.Target` python "
"object.  For example, ``tvm.target.Target('{\"kind\": \"cuda\", "
"\"max_num_threads\": 1024}')`` will create a ``cuda`` target, while "
"overriding the default maximum number of threads."
msgstr ""
"此参数定义了解析器，可以解包目标的字符串描述。这是在 C++ 的 ``Target::Target(const String&)`` "
"构造函数中完成的，该构造函数接受 JSON 格式的字符串，通常通过 :py:class:`tvm.target.Target` Python "
"对象调用。例如，``tvm.target.Target('{\"kind\": \"cuda\", \"max_num_threads\": "
"1024}')`` 将创建 ``cuda`` 目标，同时覆盖默认的最大线程数。"

#: ../../doc/docs/arch/device_target_interactions.rst:210
msgid ""
"In a code generator, the target properties can be accessed using "
"``target->GetAttr<T>(param_name)`` in C++, or with the ``target.attrs`` "
"dictionary in Python."
msgstr ""
"在代码生成器中，可以使用 C++ 中的 ``target->GetAttr<T>(param_name)`` 或 Python 中的 "
"``target.attrs`` 字典访问目标属性。"

#: ../../doc/docs/arch/device_target_interactions.rst:218
msgid "Target Code Generators"
msgstr "目标代码生成器"

#: ../../doc/docs/arch/device_target_interactions.rst:220
msgid ""
"The code generators take an optimized ``IRModule`` and converts it into "
"an executable representation.  Each code generator must be registered in "
"order to be used by the TVM framework.  This is done by registering a "
"function named ``\"target.build.foo\"``, where ``foo`` is the same name "
"as was used in the ``TVM_REGISTER_TARGET_KIND`` definition above. ::"
msgstr ""
"代码生成器接收优化后的 ``IRModule`` 并将其转换为可执行的表示形式。每个代码生成器都必须注册才能被 TVM 框架使用。这是通过注册名为"
" ``\"target.build.foo\"`` 的函数来完成的，其中 ``foo`` 与上述 "
"``TVM_REGISTER_TARGET_KIND`` 定义中使用的名称相同。::"

#: ../../doc/docs/arch/device_target_interactions.rst:230
msgid ""
"The code generator takes two arguments.  The first is the ``IRModule`` to"
" compile, and the second is the ``Target`` that describes the device on "
"which the code should run.  Because the environment performing the "
"compilation is not necessarily the same as the environment that will be "
"executing the code, code generators should not perform any attribute "
"lookups on the device itself, and should instead access parameters stored"
" in the ``Target``."
msgstr ""
"代码生成器接受两个参数。第一个是要编译的 ``IRModule``，第二个是描述代码应运行的设备的 "
"``Target``。由于执行编译的环境不一定与执行代码的环境相同，代码生成器不应在设备本身上执行任何属性查找，而应访问存储在 "
"``Target`` 中的参数。"

#: ../../doc/docs/arch/device_target_interactions.rst:238
msgid ""
"Each function in the input ``IRModule`` should be accessible by name in "
"the output ``runtime::Module``."
msgstr "输入 ``IRModule`` 中的每个函数都应通过名称在输出 ``runtime::Module`` 中可访问。"

