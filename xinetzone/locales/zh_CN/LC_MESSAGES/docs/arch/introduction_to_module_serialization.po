# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, xinetzone
# This file is distributed under the same license as the TVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: TVM \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-09 00:02+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:19
msgid "模块序列化简介"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:21
msgid ""
"部署 TVM 运行时模块时，无论是 CPU 还是 GPU, TVM 只需要一个动态共享库即可。关键是我们统一的模块序列化机制。本文档将介绍 TVM"
" 模块序列化格式标准及实现细节。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:25
msgid "Module 导出示例"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:27
msgid "以 GPU 构建 ResNet-18 工作负载作为例子。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:60
msgid "序列化"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:62
msgid "入口 API 是 ``tvm.module.Module`` 的 ``export_library`` 。在这个函数中，将执行以下步骤："
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:64
msgid "收集所有 DSO 模块（LLVM 模块和 C 模块）"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:65
msgid "一旦有了 DSO 模块，将调用 ``save`` 函数将它们保存到文件中。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:66
msgid ""
"接下来，将检查是否导入了模块，如 CUDA, OpenCL 或其他任何东西。 这里不限制模块类型。导入模块后，将创建名为 ``devc.o`` /"
" ``dev.cc`` 的文件（这样就可以将导入模块的二进制 blob 数据嵌入到动态共享库中）， 然后调用函数 "
"``_PackImportsToLLVM`` 或 ``_PackImportsToC`` 来进行模块序列化。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:69
msgid "最后，回调 ``fcompile``，它调用 ``_cc.create_shared`` 获取动态共享库。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:72
msgid "对于 C 源码模块，我们将编译它们，并将它们与 DSO 模块链接在一起。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:74
msgid "使用 ``_PackImportsToLLVM`` 或 ``_PackImportsToC`` 取决于我们是否在 TVM 中启用 LLVM。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:75
msgid "他们实际上达到了相同的目标。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:80
msgid "在序列化和格式标准的框架下"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:82
msgid ""
"如前所述，将在 ``_PackImportsToLLVM`` 或 ``_PackImportsToC`` 中进行序列化工作。 它们都调用 "
"``SerializeModule`` 来序列化运行时模块。在 ``SerializeModule`` 函数中，首先构造了辅助类 "
"``ModuleSerializer``。 它将需要模块做一些初始化工作，如标记模块索引。然后可以使用它的 ``SerializeModule``"
" 来序列化模块。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:86
msgid "为了更好地理解，更深入地研究这个类的实现。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:88
msgid "下面的代码用于构造 ``ModuleSerializer``："
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:101
msgid ""
"在 ``CreateModuleIndex()`` 中，将使用 DFS 检查模块导入关系，并为它们创建索引。注意，root 模块固定在位置 "
"0。在我们的例子中，有这样的模块关系："
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:108
msgid "所以 LLVM 模块的索引为 0，CUDA 模块的索引为 1。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:110
msgid ""
"在构造模块索引之后，尝试构造导入树（``CreateImportTree()``），当重新加载导出的库时，它将用于恢复模块导入关系。 "
"在我们的设计中，使用 CSR 格式来存储导入树，每一行是父索引，child 索引对应其 children 索引。 在代码中，使用 "
"``import_tree_row_ptr_`` 和 ``import_tree_child_indices_`` 来表示它们。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:114
msgid "在初始化之后，可以使用 ``SerializeModule`` 函数来序列化模块。在它的函数逻辑中，将假设序列化格式如下："
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:127
msgid ""
"``binary_blob_size`` 是这个序列化步骤中 blob 的数量。在我们的例子中有三个 blob，分别为 LLVM 模块、CUDA "
"模块和 ``_import_tree`` 创建。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:129
msgid ""
"``binary_blob_type_key`` 是模块的 blob 类型键。对于 LLVM / C 模块，其 blob 类型键为 "
"``_lib``。 对于 CUDA 模块，它是 ``cuda``，可以通过 ``module->type_key()`` 获取。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:132
msgid ""
"``binary_blob_logic`` 是对 blob 的逻辑处理。对于大多数 blob（如 CUDA, OpenCL），我们将调用 "
"``SaveToBinary`` 函数将 blob 序列化为二进制。 然而，像 LLVM / C 模块一样，将只写 ``_lib`` 来表明这是 "
"DSO 模块。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:136
msgid ""
"是否需要实现 ``SaveToBinary`` 虚函数（virtual function）取决于模块的使用方式。 "
"例如，如果模块中有我们在加载动态共享库时需要的信息，我们应该这样做。 与 CUDA 模块一样，我们在加载动态共享库时需要将其二进制数据传递给 "
"GPU 驱动，因此我们需要实现 ``SaveToBinary`` 对其二进制数据进行序列化。 但是对于主机模块（如 "
"DSO），在加载动态共享库时不需要其他信息，因此不需要实现 ``SaveToBinary``。 但是，如果将来我们想要记录 DSO "
"模块的一些元信息，我们也可以为 DSO 模块实现 ``SaveToBinary``。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:142
msgid ""
"最后，我们将写入一个键 ``_import_tree`` ，除非我们的模块只有一个 DSO 模块并且它位于根目录中。 "
"当我们像前面说的那样重新加载导出的库时，它被用来重建模块导入关系。 ``import_tree_logic`` 只是将 "
"``import_tree_row_ptr_`` 和 ``import_tree_child_indices_`` 写入流。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:146
msgid "在这一步之后，将把它打包到可以在动态库中恢复的 symbol ``runtime::symbol::tvm_dev_mblob`` 中。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:148
msgid "现在，完成了序列化部分。如您所见，理想情况下，可以支持导入任意模块。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:152
msgid "反序列化"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:154
msgid ""
"入口 API 是 ``tvm.runtime.load``。这个函数实际上是调用 ``_LoadFromFile``。 如果再深入一点，这就是 "
"``Module::LoadFromFile``。在示例中，该文件是 ``deploy.so``。 因此，根据函数逻辑，将在 "
"``dso_library.cc`` 中回调 ``module.loadfile_so``。关键点在："
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:170
msgid ""
"如前所述，把这个 blob 打包到 symbol ``runtime::symbol::tvm_dev_mblob`` 中。 "
"在反序列化部分，我们将检查它。如果我们有 ``runtime::symbol::tvm_dev_mblob``，我们将调用 "
"``ProcessModuleBlob``，其逻辑如下所示："
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:193
msgid ""
"在此之后，把 ``ctx_address`` 设置为 ``root_module``，以便允许从 root 查找 symbol（这样所有 "
"symbol 都是可见的）。"
msgstr ""

#: ../../xin/docs/arch/introduction_to_module_serialization.rst:195
msgid "最终，完成反序列化部分。"
msgstr ""

#~ msgid "Introduction to Module Serialization"
#~ msgstr ""

#~ msgid ""
#~ "When to deploy TVM runtime module, "
#~ "no matter whether it is CPU or "
#~ "GPU, TVM only needs one single "
#~ "dynamic shared library. The key is "
#~ "our unified module serialization mechanism."
#~ " This document will introduce TVM "
#~ "module serialization format standard and "
#~ "implementation details."
#~ msgstr ""

#~ msgid "Module Export Example"
#~ msgstr ""

#~ msgid "Let us build one ResNet-18 workload for GPU as an example first."
#~ msgstr ""

#~ msgid "Serialization"
#~ msgstr ""

#~ msgid ""
#~ "The entrance API is ``export_library`` "
#~ "of ``tvm.module.Module``. Inside this "
#~ "function, we will do the following "
#~ "steps:"
#~ msgstr ""

#~ msgid "Collect all DSO modules (LLVM modules and C modules)"
#~ msgstr ""

#~ msgid ""
#~ "Once we have DSO modules, we will"
#~ " call ``save`` function to save them"
#~ " into files."
#~ msgstr ""

#~ msgid ""
#~ "Next, we will check whether we "
#~ "have imported modules, such as CUDA, "
#~ "OpenCL or anything else. We don't "
#~ "restrict the module type here. Once "
#~ "we have imported modules, we will "
#~ "create one file named ``devc.o`` / "
#~ "``dev.cc`` (so that we could embed "
#~ "the binary blob data of import "
#~ "modules into one dynamic shared "
#~ "library), then call function "
#~ "``_PackImportsToLLVM`` or ``_PackImportsToC`` to "
#~ "do module serialization."
#~ msgstr ""

#~ msgid ""
#~ "Finally, we call ``fcompile`` which "
#~ "invokes ``_cc.create_shared`` to get dynamic"
#~ " shared library."
#~ msgstr ""

#~ msgid ""
#~ "For C source modules, we will "
#~ "compile them and link them together "
#~ "with the DSO module."
#~ msgstr ""

#~ msgid ""
#~ "Use ``_PackImportsToLLVM`` or ``_PackImportsToC``"
#~ " depends on whether we enable LLVM"
#~ " in TVM. They achieve the same "
#~ "goal in fact."
#~ msgstr ""

#~ msgid "Under the Hood of Serialization and Format Standard"
#~ msgstr ""

#~ msgid ""
#~ "As said before, we will do the "
#~ "serialization work in the "
#~ "``_PackImportsToLLVM`` or ``_PackImportsToC``. They"
#~ " both call ``SerializeModule`` to serialize"
#~ " the runtime module. In ``SerializeModule``"
#~ " function, we firstly construct one "
#~ "helper class ``ModuleSerializer``. It will "
#~ "take ``module`` to do some "
#~ "initialization work, like marking module "
#~ "index. Then we could use its "
#~ "``SerializeModule`` to serialize module."
#~ msgstr ""

#~ msgid ""
#~ "For better understanding, let us dig "
#~ "the implementation of this class a "
#~ "little deeper."
#~ msgstr ""

#~ msgid "The following code is used to construct ``ModuleSerializer``:"
#~ msgstr ""

#~ msgid ""
#~ "In ``CreateModuleIndex()``, We will inspect"
#~ " module import relationship using DFS "
#~ "and create index for them. Note "
#~ "the root module is fixed at "
#~ "location 0. In our example, we "
#~ "have module relationship like this:"
#~ msgstr ""

#~ msgid "So LLVM module will have index 0, CUDA module will have index 1."
#~ msgstr ""

#~ msgid ""
#~ "After constructing module index, we will"
#~ " try to construct import tree "
#~ "(``CreateImportTree()``), which will be used"
#~ " to restore module import relationship "
#~ "when we load the exported library "
#~ "back. In our design, we use CSR"
#~ " format to store import tree, each"
#~ " row is parent index, the child "
#~ "indices correspond to its children "
#~ "index. In code, we use "
#~ "``import_tree_row_ptr_`` and "
#~ "``import_tree_child_indices_`` to represent them."
#~ msgstr ""

#~ msgid ""
#~ "After initialization, we could serialize "
#~ "module using ``SerializeModule`` function. In"
#~ " its function logic, we will assume"
#~ " the serialization format like this:"
#~ msgstr ""

#~ msgid ""
#~ "``binary_blob_size`` is the number of "
#~ "blobs we will have in this "
#~ "serialization step. There will be three"
#~ " blobs in our example which are "
#~ "created for LLVM module, CUDA module,"
#~ " and ``_import_tree``, respectively."
#~ msgstr ""

#~ msgid ""
#~ "``binary_blob_type_key`` is the blob type "
#~ "key of module. For LLVM / C "
#~ "module, whose blob type key is "
#~ "``_lib``. For CUDA module, it is "
#~ "``cuda``, which could be got by "
#~ "``module->type_key()``."
#~ msgstr ""

#~ msgid ""
#~ "``binary_blob_logic`` is the logic handling"
#~ " of blob. For most of blob "
#~ "(like CUDA, OpenCL), we will call "
#~ "``SaveToBinary`` function to serialize blob"
#~ " into binary. However, like LLVM /"
#~ " C module, we will only write "
#~ "``_lib`` to indicate this is a DSO"
#~ " module."
#~ msgstr ""

#~ msgid ""
#~ "Whether or not it is required to"
#~ " implement the SaveToBinary virtual "
#~ "function depends on how the module "
#~ "is used. For example, If the "
#~ "module has information we need when "
#~ "we load the dynamic shared library "
#~ "back, we should do. Like CUDA "
#~ "module, we need its binary data "
#~ "passing to GPU driver when we load"
#~ " the dynamic shared library, so we"
#~ " should implement ``SaveToBinary`` to "
#~ "serialize its binary data. But for "
#~ "host module (like DSO), we don't "
#~ "need other information when we load "
#~ "the dynamic shared library, so we "
#~ "don't need to implement ``SaveToBinary``. "
#~ "However, if in the future, we want"
#~ " to record some meta information of"
#~ " DSO module, we could implement "
#~ "``SaveToBinary`` for DSO module too."
#~ msgstr ""

#~ msgid ""
#~ "Finally, we will write one key "
#~ "``_import_tree`` unless our module only "
#~ "has one DSO module and it is "
#~ "in the root. It is used to "
#~ "reconstruct the module import relationship "
#~ "when we load the exported library "
#~ "back as said before. The "
#~ "``import_tree_logic`` is just to write "
#~ "``import_tree_row_ptr_`` and "
#~ "``import_tree_child_indices_`` into stream."
#~ msgstr ""

#~ msgid ""
#~ "After this step, we will pack it"
#~ " into a symbol ``runtime::symbol::tvm_dev_mblob``"
#~ " that can be recovered in the "
#~ "dynamic libary."
#~ msgstr ""

#~ msgid ""
#~ "Now, we complete the serialization part."
#~ " As you have seen, we could "
#~ "support arbitrary modules to import "
#~ "ideally."
#~ msgstr ""

#~ msgid "Deserialization"
#~ msgstr ""

#~ msgid ""
#~ "The entrance API is ``tvm.runtime.load``. "
#~ "This function is to call "
#~ "``_LoadFromFile`` in fact. If we dig "
#~ "it a little deeper, this is "
#~ "``Module::LoadFromFile``. In our example, the"
#~ " file is ``deploy.so``, according to "
#~ "the function logic, we will call "
#~ "``module.loadfile_so`` in ``dso_library.cc``. The"
#~ " key is here:"
#~ msgstr ""

#~ msgid ""
#~ "As said before, we will pack the"
#~ " blob into the symbol "
#~ "``runtime::symbol::tvm_dev_mblob``. During deserialization"
#~ " part, we will inspect it. If "
#~ "we have ``runtime::symbol::tvm_dev_mblob``, we "
#~ "will call ``ProcessModuleBlob``, whose logic"
#~ " like this:"
#~ msgstr ""

#~ msgid ""
#~ "After this, we will set the "
#~ "``ctx_address`` to be the ``root_module`` "
#~ "so that allow lookup of symbol "
#~ "from root (so all symbols are "
#~ "visible)."
#~ msgstr ""

#~ msgid "Finally, we complete the deserialization part."
#~ msgstr ""

