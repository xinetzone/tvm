# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, xinetzone
# This file is distributed under the same license as the TVM package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: TVM \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-03-31 18:33+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../docs/reference/api/python/runtime.rst:19
msgid "tvm.runtime"
msgstr ""

#~ msgid ":py:obj:`Object <tvm.runtime.Object>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`PackedFunc <tvm.runtime.PackedFunc>`\\ "
#~ "\\(handle\\, is\\_global\\)"
#~ msgstr ""

#~ msgid ":py:obj:`Report <tvm.runtime.Report>`\\ \\(\\)"
#~ msgstr ""

#~ msgid ":py:obj:`Object <tvm.runtime.Object>`\\"
#~ msgstr ""

#~ msgid ":py:obj:`PackedFunc <tvm.runtime.PackedFunc>`\\"
#~ msgstr ""

#~ msgid ":py:obj:`Report <tvm.runtime.Report>`\\"
#~ msgstr ""

#~ msgid "TVM runtime namespace."
#~ msgstr "TVM runtime 名称空间"

#~ msgid "**Classes:**"
#~ msgstr ""

#~ msgid ":py:obj:`DataType <tvm.runtime.DataType>`\\ \\(type\\_str\\)"
#~ msgstr ""

#~ msgid "TVM datatype structure"
#~ msgstr ""

#~ msgid ":py:obj:`DataTypeCode <tvm.runtime.DataTypeCode>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "DataType code in DLTensor."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`Device <tvm.runtime.Device>`\\ "
#~ "\\(device\\_type\\, device\\_id\\)"
#~ msgstr ""

#~ msgid "TVM device strucure."
#~ msgstr ""

#~ msgid ":py:obj:`Module <tvm.runtime.Module>`\\ \\(handle\\)"
#~ msgstr ""

#~ msgid "Runtime Module."
#~ msgstr "运行时 Module。"

#~ msgid "Base class for all tvm's runtime objects."
#~ msgstr ""

#~ msgid ":py:obj:`ObjectGeneric <tvm.runtime.ObjectGeneric>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Base class for all classes that can be converted to object."
#~ msgstr ""

#~ msgid "The PackedFunc object used in TVM."
#~ msgstr ""

#~ msgid "A container for information gathered during a profiling run."
#~ msgstr ""

#~ msgid ":py:obj:`ShapeTuple <tvm.runtime.ShapeTuple>`\\ \\(shape\\)"
#~ msgstr ""

#~ msgid "TVM runtime ShapeTuple object."
#~ msgstr ""

#~ msgid ":py:obj:`String <tvm.runtime.String>`\\ \\(content\\)"
#~ msgstr ""

#~ msgid "TVM runtime.String object, represented as a python str."
#~ msgstr ""

#~ msgid "**Functions:**"
#~ msgstr ""

#~ msgid ":py:obj:`cl <tvm.runtime.cl>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a OpenCL device"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`const <tvm.runtime.const>`\\ \\(value\\[\\, "
#~ "dtype\\, span\\]\\)"
#~ msgstr ""

#~ msgid "construct a constant"
#~ msgstr ""

#~ msgid ":py:obj:`convert <tvm.runtime.convert>`\\ \\(value\\[\\, span\\]\\)"
#~ msgstr ""

#~ msgid "Convert value to TVM object or function."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`convert_to_object <tvm.runtime.convert_to_object>`\\"
#~ " \\(value\\[\\, span\\]\\)"
#~ msgstr ""

#~ msgid "Convert a Python value to corresponding object type."
#~ msgstr ""

#~ msgid ":py:obj:`cpu <tvm.runtime.cpu>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a CPU device"
#~ msgstr ""

#~ msgid ":py:obj:`cuda <tvm.runtime.cuda>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a CUDA GPU device"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`device <tvm.runtime.device>`\\ "
#~ "\\(dev\\_type\\[\\, dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a TVM device with given device type and id."
#~ msgstr ""

#~ msgid ":py:obj:`enabled <tvm.runtime.enabled>`\\ \\(target\\)"
#~ msgstr ""

#~ msgid "Whether module runtime is enabled for target"
#~ msgstr ""

#~ msgid ":py:obj:`ext_dev <tvm.runtime.ext_dev>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a extension device"
#~ msgstr ""

#~ msgid ":py:obj:`gpu <tvm.runtime.gpu>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`load_module <tvm.runtime.load_module>`\\ "
#~ "\\(path\\[\\, fmt\\]\\)"
#~ msgstr ""

#~ msgid "Load module from file."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`load_param_dict <tvm.runtime.load_param_dict>`\\ "
#~ "\\(param\\_bytes\\)"
#~ msgstr ""

#~ msgid "Load parameter dictionary to binary bytes."
#~ msgstr ""

#~ msgid ":py:obj:`metal <tvm.runtime.metal>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a metal device"
#~ msgstr ""

#~ msgid ":py:obj:`mtl <tvm.runtime.mtl>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid ":py:obj:`opencl <tvm.runtime.opencl>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid ":py:obj:`rocm <tvm.runtime.rocm>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a ROCM device"
#~ msgstr ""

#~ msgid ":py:obj:`save_param_dict <tvm.runtime.save_param_dict>`\\ \\(params\\)"
#~ msgstr ""

#~ msgid "Save parameter dictionary to binary bytes."
#~ msgstr ""

#~ msgid ":py:obj:`system_lib <tvm.runtime.system_lib>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Get system-wide library module singleton."
#~ msgstr ""

#~ msgid ":py:obj:`vpi <tvm.runtime.vpi>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a VPI simulated device"
#~ msgstr ""

#~ msgid ":py:obj:`vulkan <tvm.runtime.vulkan>`\\ \\(\\[dev\\_id\\]\\)"
#~ msgstr ""

#~ msgid "Construct a Vulkan device"
#~ msgstr ""

#~ msgid ""
#~ "Typically constructed using convenience "
#~ "function :meth:`tvm.runtime.device`."
#~ msgstr ""

#~ msgid ""
#~ "Exposes uniform interface to device-"
#~ "specific APIs such as CUDA or "
#~ "OpenCL.  Some properties may return None"
#~ " depending on whether an API exposes"
#~ " that particular property."
#~ msgstr ""

#~ msgid "**Attributes:**"
#~ msgstr ""

#~ msgid ":py:obj:`api_version <tvm.runtime.Device.api_version>`\\"
#~ msgstr ""

#~ msgid "Returns version number of the SDK used to compile TVM."
#~ msgstr ""

#~ msgid ":py:obj:`compute_version <tvm.runtime.Device.compute_version>`\\"
#~ msgstr ""

#~ msgid "Get compute version number as string."
#~ msgstr ""

#~ msgid ":py:obj:`device_name <tvm.runtime.Device.device_name>`\\"
#~ msgstr ""

#~ msgid "Return the vendor-specific name of device."
#~ msgstr ""

#~ msgid ":py:obj:`driver_version <tvm.runtime.Device.driver_version>`\\"
#~ msgstr ""

#~ msgid "Returns version number of the driver"
#~ msgstr ""

#~ msgid ":py:obj:`exist <tvm.runtime.Device.exist>`\\"
#~ msgstr ""

#~ msgid "Whether this device exists."
#~ msgstr ""

#~ msgid ":py:obj:`max_clock_rate <tvm.runtime.Device.max_clock_rate>`\\"
#~ msgstr ""

#~ msgid "Return the max clock frequency of device (kHz)."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`max_shared_memory_per_block "
#~ "<tvm.runtime.Device.max_shared_memory_per_block>`\\"
#~ msgstr ""

#~ msgid "Total amount of shared memory per block in bytes."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`max_thread_dimensions "
#~ "<tvm.runtime.Device.max_thread_dimensions>`\\"
#~ msgstr ""

#~ msgid "Return the maximum size of each thread axis"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`max_threads_per_block "
#~ "<tvm.runtime.Device.max_threads_per_block>`\\"
#~ msgstr ""

#~ msgid "Maximum number of threads on each block."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`multi_processor_count "
#~ "<tvm.runtime.Device.multi_processor_count>`\\"
#~ msgstr ""

#~ msgid "Return the number of compute units in the device."
#~ msgstr ""

#~ msgid ":py:obj:`warp_size <tvm.runtime.Device.warp_size>`\\"
#~ msgstr ""

#~ msgid "Number of threads that execute concurrently."
#~ msgstr ""

#~ msgid "**Methods:**"
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`create_raw_stream "
#~ "<tvm.runtime.Device.create_raw_stream>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Create a new runtime stream at the context."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`free_raw_stream <tvm.runtime.Device.free_raw_stream>`\\"
#~ " \\(stream\\)"
#~ msgstr ""

#~ msgid "Free a created stream handle."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`set_raw_stream <tvm.runtime.Device.set_raw_stream>`\\"
#~ " \\(stream\\)"
#~ msgstr ""

#~ msgid "Set a created stream handle."
#~ msgstr ""

#~ msgid ":py:obj:`sync <tvm.runtime.Device.sync>`\\ \\(\\[stream\\]\\)"
#~ msgstr ""

#~ msgid "Synchronize until jobs finished at the context."
#~ msgstr ""

#~ msgid "For example, CUDA_VERSION for cuda or VK_HEADER_VERSION for Vulkan."
#~ msgstr ""

#~ msgid ""
#~ "Returns device value for cuda, rocm, "
#~ "opencl, and vulkan. Returns remote "
#~ "device value for RPC devices.  Returns"
#~ " None for all other devices."
#~ msgstr ""

#~ msgid "返回"
#~ msgstr ""

#~ msgid "**version** -- The version of the SDK"
#~ msgstr ""

#~ msgid "返回类型"
#~ msgstr ""

#~ msgid ""
#~ "Returns maximum API version (e.g. "
#~ "CUDA/OpenCL/Vulkan) supported by the device."
#~ msgstr ""

#~ msgid "**version** -- The version string in `major.minor` format."
#~ msgstr ""

#~ msgid "User should free the stream after use."
#~ msgstr ""

#~ msgid "**stream** -- The created runtime stream."
#~ msgstr ""

#~ msgid "**device_name** -- The name of the device."
#~ msgstr ""

#~ msgid ""
#~ "Returns driver vendor's internal version "
#~ "number. (e.g. \"450.408.256\" for nvidia-"
#~ "driver-450)"
#~ msgstr ""

#~ msgid ""
#~ "Returns device value for opencl and "
#~ "vulkan.  Returns remote device value for"
#~ " RPC devices.  Returns None for all"
#~ " other devices."
#~ msgstr ""

#~ msgid "**version** -- The version string in `major.minor.patch` format."
#~ msgstr ""

#~ msgid ""
#~ "Returns True if TVM has support "
#~ "for the device, if the physical "
#~ "device is present, and the device "
#~ "is accessible through appropriate drivers "
#~ "(e.g. cuda/vulkan)."
#~ msgstr ""

#~ msgid "**exist** -- True if the device exists"
#~ msgstr ""

#~ msgid "参数"
#~ msgstr ""

#~ msgid "The stream which should to be released."
#~ msgstr ""

#~ msgid ""
#~ "Returns device value for cuda, rocm, "
#~ "and opencl.  Returns remote device value"
#~ " for RPC devices.  Returns None for"
#~ " all other devices."
#~ msgstr ""

#~ msgid "**max_clock_rate** -- The maximum clock frequency of the device (kHz)"
#~ msgstr ""

#~ msgid ""
#~ "**max_shared_memory_per_block** -- Total amount "
#~ "of shared memory per block in "
#~ "bytes"
#~ msgstr ""

#~ msgid "**dims** -- The maximum length of threadIdx.x, threadIdx.y, threadIdx.z"
#~ msgstr ""

#~ msgid ""
#~ "Returns device value for cuda, metal,"
#~ " rocm, opencl, and vulkan devices.  "
#~ "Returns remote device value for RPC "
#~ "devices. Returns None for all other "
#~ "devices."
#~ msgstr ""

#~ msgid "**max_threads_per_block** -- The number of threads on each block"
#~ msgstr ""

#~ msgid "**multi_processor_count** -- Thee number of compute units in the device"
#~ msgstr ""

#~ msgid "The stream which should to be set to the device."
#~ msgstr ""

#~ msgid "Jobs in this stream should be finished."
#~ msgstr ""

#~ msgid ""
#~ "Returns device value for for cuda, "
#~ "rocm, and vulkan.  Returns 1 for "
#~ "metal and opencl devices, regardless of"
#~ " the physical device.  Returns remote "
#~ "device value for RPC devices.  Returns"
#~ " None for all other devices."
#~ msgstr ""

#~ msgid "**warp_size** -- Number of threads that execute concurrently"
#~ msgstr ""

#~ msgid ":py:obj:`entry_func <tvm.runtime.Module.entry_func>`\\"
#~ msgstr ""

#~ msgid "Get the entry function"
#~ msgstr ""

#~ msgid ":py:obj:`format <tvm.runtime.Module.format>`\\"
#~ msgstr ""

#~ msgid "Get the format of the module."
#~ msgstr ""

#~ msgid ":py:obj:`imported_modules <tvm.runtime.Module.imported_modules>`\\"
#~ msgstr ""

#~ msgid "Get imported modules"
#~ msgstr ""

#~ msgid ":py:obj:`type_key <tvm.runtime.Module.type_key>`\\"
#~ msgstr ""

#~ msgid "Get type key of the module."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`export_library <tvm.runtime.Module.export_library>`\\"
#~ " \\(file\\_name\\[\\, fcompile\\, ...\\]\\)"
#~ msgstr ""

#~ msgid ""
#~ "Export the module and all imported "
#~ "modules into a single device library."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`get_function <tvm.runtime.Module.get_function>`\\ "
#~ "\\(name\\[\\, query\\_imports\\]\\)"
#~ msgstr ""

#~ msgid "Get function from the module."
#~ msgstr ""

#~ msgid ":py:obj:`get_source <tvm.runtime.Module.get_source>`\\ \\(\\[fmt\\]\\)"
#~ msgstr ""

#~ msgid "Get source code from module, if available."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`import_module <tvm.runtime.Module.import_module>`\\ "
#~ "\\(module\\)"
#~ msgstr ""

#~ msgid "Add module to the import list of current one."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`save <tvm.runtime.Module.save>`\\ "
#~ "\\(file\\_name\\[\\, fmt\\]\\)"
#~ msgstr ""

#~ msgid "Save the module to file."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`time_evaluator <tvm.runtime.Module.time_evaluator>`\\"
#~ " \\(func\\_name\\, dev\\[\\, number\\, ...\\]\\)"
#~ msgstr ""

#~ msgid "Get an evaluator that measures time cost of running function."
#~ msgstr ""

#~ msgid "**f** -- The entry function if exist"
#~ msgstr ""

#~ msgid ""
#~ "This function only works on host "
#~ "LLVM modules, other runtime::Module subclasses"
#~ " will work with this API but "
#~ "they must support implement the save "
#~ "and load mechanisms of modules "
#~ "completely including saving from streams "
#~ "and files. This will pack your "
#~ "non-shared library module into a "
#~ "single shared library which can later"
#~ " be loaded by TVM."
#~ msgstr ""

#~ msgid "The name of the shared library."
#~ msgstr ""

#~ msgid ""
#~ "The compilation function to use create"
#~ " the final library object during "
#~ "export.  For example, when "
#~ "fcompile=_cc.create_shared, or when it is "
#~ "not supplied but module is \"llvm,\" "
#~ "this is used to link all produced"
#~ " artifacts into a final dynamic "
#~ "library.  This behavior is controlled by"
#~ " the type of object exported. If "
#~ "fcompile has attribute object_format, will "
#~ "compile host library to that format. "
#~ "Otherwise, will use default format "
#~ "\"o\"."
#~ msgstr ""

#~ msgid ""
#~ "The compilation function to use create"
#~ " the final library object during "
#~ "export."
#~ msgstr ""

#~ msgid ""
#~ "For example, when fcompile=_cc.create_shared, "
#~ "or when it is not supplied but "
#~ "module is \"llvm,\" this is used "
#~ "to link all produced artifacts into "
#~ "a final dynamic library."
#~ msgstr ""

#~ msgid ""
#~ "This behavior is controlled by the "
#~ "type of object exported. If fcompile "
#~ "has attribute object_format, will compile "
#~ "host library to that format. Otherwise,"
#~ " will use default format \"o\"."
#~ msgstr ""

#~ msgid ""
#~ "The path of the directory used to"
#~ " create the intermediate artifacts when "
#~ "exporting the module. If this is "
#~ "not provided a temporary dir will "
#~ "be created."
#~ msgstr ""

#~ msgid "Additional arguments passed to fcompile"
#~ msgstr ""

#~ msgid ""
#~ "**result of fcompile()** -- If the "
#~ "compilation function returns an artifact "
#~ "it would be returned via export_library,"
#~ " if any."
#~ msgstr ""

#~ msgid "The name of the function"
#~ msgstr ""

#~ msgid "Whether also query modules imported by this module."
#~ msgstr ""

#~ msgid "**f** -- The result function."
#~ msgstr ""

#~ msgid "The specified format."
#~ msgstr ""

#~ msgid "**source** -- The result source code."
#~ msgstr ""

#~ msgid "The other module."
#~ msgstr ""

#~ msgid "**modules** -- The module"
#~ msgstr ""

#~ msgid "This do not save the dependent device modules. See also export_shared"
#~ msgstr ""

#~ msgid "The name of the file."
#~ msgstr ""

#~ msgid "The format of the file."
#~ msgstr ""

#~ msgid ":obj:`runtime.Module.export_library`"
#~ msgstr ""

#~ msgid "export the module to shared library."
#~ msgstr ""

#~ msgid "The name of the function in the module."
#~ msgstr ""

#~ msgid "The device we should run this function on."
#~ msgstr ""

#~ msgid ""
#~ "The number of times to run this"
#~ " function for taking average. We call"
#~ " these runs as one `repeat` of "
#~ "measurement."
#~ msgstr ""

#~ msgid ""
#~ "The number of times to repeat the"
#~ " measurement. In total, the function "
#~ "will be invoked (1 + number x "
#~ "repeat) times, where the first one "
#~ "is warm up and will be discarded."
#~ " The returned result contains `repeat` "
#~ "costs, each of which is an average"
#~ " of `number` costs."
#~ msgstr ""

#~ msgid ""
#~ "The minimum duration of one `repeat` "
#~ "in milliseconds. By default, one "
#~ "`repeat` contains `number` runs. If this"
#~ " parameter is set, the parameters "
#~ "`number` will be dynamically adjusted to"
#~ " meet the minimum duration requirement "
#~ "of one `repeat`. i.e., When the "
#~ "run time of one `repeat` falls "
#~ "below this time, the `number` parameter"
#~ " will be automatically increased."
#~ msgstr ""

#~ msgid ""
#~ "The preprocess function name we want "
#~ "to execute before executing the time "
#~ "evaluator."
#~ msgstr ""

#~ msgid ""
#~ "The function will be invoked  (1 +"
#~ " number x repeat) times, with the "
#~ "first call discarded in case there "
#~ "is lazy initialization."
#~ msgstr ""

#~ msgid ""
#~ "**ftimer** -- The function that takes"
#~ " same argument as func and returns"
#~ " a BenchmarkResult. The ProfileResult "
#~ "reports `repeat` time costs in seconds."
#~ msgstr ""

#~ msgid ":py:obj:`asobject <tvm.runtime.ObjectGeneric.asobject>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Convert value to object"
#~ msgstr ""

#~ msgid ""
#~ "Function plays an key role to "
#~ "bridge front and backend in TVM. "
#~ "Function provide a type-erased "
#~ "interface, you can call function with"
#~ " positional arguments."
#~ msgstr ""

#~ msgid ""
#~ "The compiled module returns Function. "
#~ "TVM backend also registers and exposes"
#~ " its API as Functions."
#~ msgstr ""

#~ msgid ""
#~ "The following are list of common "
#~ "usage scenario of tvm.runtime.PackedFunc."
#~ msgstr ""

#~ msgid "Automatic exposure of C++ API into python"
#~ msgstr ""

#~ msgid "To call PackedFunc from python side"
#~ msgstr ""

#~ msgid "To call python callbacks to inspect results in generated code"
#~ msgstr ""

#~ msgid "Bring python hook into C++ backend"
#~ msgstr ""

#~ msgid ":obj:`tvm.register_func`"
#~ msgstr ""

#~ msgid "How to register global function."
#~ msgstr ""

#~ msgid ":obj:`tvm.get_global_func`"
#~ msgstr ""

#~ msgid "How to get global function."
#~ msgstr ""

#~ msgid "Per-call profiling metrics (function name, runtime, device, ...)."
#~ msgstr ""

#~ msgid "type"
#~ msgstr ""

#~ msgid "Array[Dict[str, Object]]"
#~ msgstr ""

#~ msgid "Per-device metrics collected over the entire run."
#~ msgstr ""

#~ msgid "Dict[Device, Dict[str, Object]]"
#~ msgstr ""

#~ msgid ":py:obj:`csv <tvm.runtime.Report.csv>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Convert this profiling report into CSV format."
#~ msgstr ""

#~ msgid ":py:obj:`from_json <tvm.runtime.Report.from_json>`\\ \\(s\\)"
#~ msgstr ""

#~ msgid "Deserialize a report from JSON."
#~ msgstr ""

#~ msgid ":py:obj:`json <tvm.runtime.Report.json>`\\ \\(\\)"
#~ msgstr ""

#~ msgid "Convert this profiling report into JSON format."
#~ msgstr ""

#~ msgid ""
#~ ":py:obj:`table <tvm.runtime.Report.table>`\\ \\(\\[sort\\,"
#~ " aggregate\\, col\\_sums\\]\\)"
#~ msgstr ""

#~ msgid "Generate a human-readable table"
#~ msgstr ""

#~ msgid "This only includes calls and not overall metrics."
#~ msgstr ""

#~ msgid "**csv** -- `calls` in CSV format."
#~ msgstr ""

#~ msgid "Report serialize via :py:meth:`json`."
#~ msgstr ""

#~ msgid "**report** -- The deserialized report."
#~ msgstr ""

#~ msgid "Example output:"
#~ msgstr ""

#~ msgid "**json** -- Formatted JSON"
#~ msgstr ""

#~ msgid ""
#~ "If aggregate is true, whether to "
#~ "sort call frames by descending duration."
#~ "  If aggregate is False, whether to"
#~ " sort frames by order of appearancei"
#~ " n the program."
#~ msgstr ""

#~ msgid "Whether to join multiple calls to the same op into a single line."
#~ msgstr ""

#~ msgid "Whether to include the sum of each column."
#~ msgstr ""

#~ msgid "**table** -- A human-readable table"
#~ msgstr ""

#~ msgid ""
#~ "TVM runtime ShapeTuple object. :param "
#~ "shape: The shape list used to "
#~ "construct the object. :type shape: "
#~ "list[int]"
#~ msgstr ""

#~ msgid "The content string used to construct the object."
#~ msgstr ""

#~ msgid "The integer device id"
#~ msgstr ""

#~ msgid "**dev** -- The created device"
#~ msgstr ""

#~ msgid "The content of the constant number."
#~ msgstr ""

#~ msgid "The data type."
#~ msgstr ""

#~ msgid "The location of the constant value in the source."
#~ msgstr ""

#~ msgid "**const_val** -- The result expression."
#~ msgstr ""

#~ msgid "The location of this statement in the source code."
#~ msgstr ""

#~ msgid "**tvm_val** -- Converted value in TVM"
#~ msgstr ""

#~ msgid "The value to be inspected."
#~ msgstr ""

#~ msgid "The location of this itervar in the source code."
#~ msgstr ""

#~ msgid "**obj** -- The corresponding object value."
#~ msgstr ""

#~ msgid "The device type mask or name of the device."
#~ msgstr ""

#~ msgid "**dev** -- The corresponding device."
#~ msgstr ""

#~ msgid "实际案例"
#~ msgstr ""

#~ msgid ""
#~ "Device can be used to create "
#~ "reflection of device by string "
#~ "representation of the device type."
#~ msgstr ""

#~ msgid "The target device type."
#~ msgstr ""

#~ msgid "**enabled** -- Whether runtime is enabled."
#~ msgstr ""

#~ msgid "The following code checks if gpu is enabled."
#~ msgstr ""

#~ msgid ""
#~ "This API is reserved for quick "
#~ "testing of new device by plugin "
#~ "device API as ext_dev."
#~ msgstr ""

#~ msgid "deprecated:: 0.9.0 Use :py:func:`tvm.cuda` instead."
#~ msgstr ""

#~ msgid "The path to the module file."
#~ msgstr ""

#~ msgid ""
#~ "The format of the file, if not "
#~ "specified it will be inferred from "
#~ "suffix of the file."
#~ msgstr ""

#~ msgid "**module** -- The loaded module"
#~ msgstr ""

#~ msgid ""
#~ "This function will automatically call "
#~ "cc.create_shared if the path is in "
#~ "format .o or .tar"
#~ msgstr ""

#~ msgid "Serialized parameters."
#~ msgstr ""

#~ msgid "**params** -- The parameter dictionary."
#~ msgstr ""

#~ msgid ""
#~ "The result binary bytes can be "
#~ "loaded by the GraphModule with API "
#~ "\"load_params\"."
#~ msgstr ""

#~ msgid "The parameter dictionary."
#~ msgstr ""

#~ msgid "**param_bytes** -- Serialized parameters."
#~ msgstr ""

#~ msgid ""
#~ "System lib is a global module that"
#~ " contains self register functions in "
#~ "startup. Unlike normal dso modules which"
#~ " need to be loaded explicitly. It "
#~ "is useful in environments where dynamic"
#~ " loading api like dlopen is banned."
#~ msgstr ""

#~ msgid ""
#~ "To build system lib function, simply "
#~ "specify target option ```llvm --system-"
#~ "lib``` The system lib will be "
#~ "available as long as the result "
#~ "code is linked by the program."
#~ msgstr ""

#~ msgid ""
#~ "The system lib is intended to be"
#~ " linked and loaded during the entire"
#~ " life-cyle of the program. If "
#~ "you want dynamic loading features, use"
#~ " dso modules instead."
#~ msgstr ""

#~ msgid "**module** -- The system-wide library module."
#~ msgstr ""

